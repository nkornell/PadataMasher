<!DOCTYPE html>
<html lang="en">

<head>
	<title>Lenient Scorer</title>
	<meta charset="UTF-8">
	<meta name="description" content="Lenient Scorer: quick, easy, private, and free way to grade/score responses in a datafile">
	<meta name="keywords" content="data, analysis, easy, free, clean, analyze, organize, application, program">
	<meta name="author" content="Nate Kornell">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="stylesheet" type="text/css" href="mystyle.css">
</head>

<body> 
	<!--  navigation menu -->
	<nav>
		<ul>
			<li><div class="navMenuItem selected"><a href="index.html">Home</a></div></li>
			<li style="float:right"><div class="navMenuItem" id = 'about_link' style="display: inline-block; cursor: pointer"" onclick="show_or_hide_about()">About ▾</div></li>
		</ul>
	</nav>

	<!-- about -->
	<div id='about' style="display: none;">
		<div class='boxAroundTable'>
			<p><b>About</b>
			<p>Start by selecting which of the two datafile formats suits you. 
			After you pass it your datafile, it will show you all of your column names. 
			Common responses are shown below each one. Just click on the correct responses!
			(Or start by clicking the Auto-Score button.) 
			<p>When you are done, press export. A new datafil will be created on your desktop. 
			Any responses you've clicked will be given a score of 1. 
			<p>Autoscore selects the most common answer in each column for you. It also selects
			misspelled versions of that answer. It ignores columns where accuracy is perfect, or very low, and any 
			column name that starts with the word "Timing."
			It 
			<p>This process keps your data private. The program never uploads your data 
			and no one can access it except you.
			
		</div>
	</div>

<!-- 
dfd
let you choose which columns to analyze
add option to hide correct responses? maybe not
 -->
	<!-- ~~- processing files ~~- -->
	<div id="processingBox">
		<div class="dragDropBox" id="processing" style='text-align: left; vertical-align: bottom; padding: 5px'></div>
	</div>

	<!-- ~~- choosing a file ~~- -->
	<div id="formatSelectorBox" class='boxAroundTable' style="margin: 25px; line-height: 2"> 
		How is your data file organized?
		<br>&emsp;
		<input type="radio" id="in_columns" name="file_format" value="in_columns" onchange='formatButtonClicked(this.id)'>
		<label for="in_columns">Like Qualtrics <div style="display: inline-block; color: grey">(each column of user responses has a single correct answer)</div></label>
		<br>&emsp;
		<input type="radio" id="verified_answers" name="file_format" value="verified_answers" onchange='formatButtonClicked(this.id)'> <!-- checked="checked" -->
		<label for="verified_answers">Compare two columns <div style="display: inline-block; color: grey"> (one with correct answers and the other with user responses)</div></label>
	</div>

	<div id="fileSelectorBox" style="display: none">
		<center>
		<div class="roundedBox dragDropBox" id="drop_zone">
			<img src="images/pm.png" style="position: relative; width: 300px; opacity: 0.2; ">
			<div class="middleCenter">
				<h1>Lenient Scorer</h1>
				<h2>drag a text file here</h2>
			</div>
		</div>
		
		Or if you prefer <input type="file" id="files" name="files[]" single />
		</center>

<!-- 		The checkbox below works. I made it invisible because I think I will always want to ignore capitalization and it makes the visuals too busy/complicated -->
		<p style="display: none"><input type="checkbox" id="ignore_case" checked ><label for="ignore_case">Ignore capitalization of user responses (e.g., Smith = smith)</label> </p>
	</div>


<div class='bigBox' id='lsBigBox' style="display: none">
<!-- 	Variable selector -->
	<div class='bigBox' style="width:100%;"> 
		<p style="margin-left: 10px">Select correct responses </p>
		<div class='boxAroundTable' id='scrollable_box' style="overflow-x: scroll; height: 20rem; overflow-y: scroll; margin-bottom: 10px">
			<div id="variable_selector_table"></div>
		</div>
		
		<p><div id='status_text' style='display: inline-block; margin-left: 10px'></div> <!--  0 columns selected -->
		<div id='jump_arrows' style="display: inline-block; float: right; text-align:right; margin-right: 10px"> jump to next selected column <button onclick="autoScroll('left')">←</button><button onclick="autoScroll('right')">→</button></div></p>

		<br>
		<div class='boxAroundTable' id="auto_score_box">
			<p><button onclick="autoScore()">Auto-Score</button>
			<input type="checkbox" id="lenient_checkbox" checked><label for="lenient_checkbox">Count misspelled answers as correct</label> 
		</div>
		<div class='boxAroundTable'>
			<p><a id="exportButton" href="#" class='coolButton'>Export Results to File</a> 	
		</div>

		<div class='boxAroundTable'>
			<div style="font-weight: bold">Settings</div>
			<p>Mark blank responses as 
			<select id='UseNA'>
				<option value='Zero'>Zero</option>
				<option value='na'>na</option>
			</select>
		</div>
	</div>
</div>


</body>
</html>



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- -->


<script src="file_select.js"></script>
<script src="file_importExportContent.js"></script>
<script src="functions_indexpage.js"></script>
<script src="functions_stats.js"></script>

<script>
var answer_group = []
var maximum_num_checkboxes = 9;
var good_match_threshold = .80 // score when comparing two strings
var correct_answer = [];


if (localStorage.getItem("leneint_scorer_file_format") != null) {
	// if the user's preference for which file format is locally stored in the browser, click on that radio button
	document.getElementById(localStorage.getItem("lenient_scorer_file_format")).click()
}


function show_or_hide_about() {
	if (document.getElementById("about").style.display === "none") {
		document.getElementById("about").style.display = "block";
		document.getElementById("about_link").innerHTML = "About ▴"

	} else {
		document.getElementById("about").style.display = "none";
		document.getElementById("about_link").innerHTML = "About ▾"
	}
}

function answer_group_object(input_name, column_number, input_values, input_verified_answer) { 
	// this is an object that represents a correct answer. it might be a column of data (in qualtrics format) or responses that all have the same target
	this.column_name = input_name;
	this.verified_answer = input_verified_answer;
	this.level_text = []
	this.level_num_observations = []
	this.sorted_array = []
	this.array_of_selected_items = []
	this.total_responses = 0
	for (i = 0; i < input_values.length; i++) {
		if (input_values[i].length > 0) {
			this.total_responses++
		}
	}

	this.compute_levels = function() {
		// figure out what different values are in the column, and how many times each one apears
		var i = 0;
		var tempLevel = '';
		
		for (i = 0; i < input_values.length; i++) {
			tempLevel = input_values[i];

			if (this.level_text.indexOf(tempLevel) == -1) { // it's identified a novel unique between-level combination
				this.level_text.push(tempLevel);
				this.level_num_observations[tempLevel] = 1;
			} else {
				this.level_num_observations[tempLevel]++
			}
		}
		
		for (i = 0; i < this.level_text.length; i++) {
			this.sorted_array.push([this.level_text[i], this.level_num_observations[this.level_text[i]]])
		}
		
		this.sorted_array.sort(function(a, b) {
		    return b[1] - a[1]; // because it's b then a, it sorts descending
		});
	}
	
	
	this.binary_array = function() {
		// This returns an array with a value of 1 or 0 for each item in the column. 
		// It's a 1 if the item is in the list of checked items and 0 if it's not. 
		var out = [];
		out.push('score_'+this.column_name)
		for (i = 0; i < input_values.length; i++) {
			if (this.array_of_selected_items.indexOf(input_values[i]) > -1) {
				out.push('1')
			} else if (input_values[i].length == 0 && document.getElementById("UseNA").value == "na") {
				out.push('na')
			} else {
				out.push('0')
			}
		}
		return out
	}
	
	this.binary_item = function(resp_string) {
		// This returns a value of 1 or 0 for the specific item that's passed as the parameter. 
// 		console.log( 'is this in the list below: '+resp_string)
// 		console.log( this.array_of_selected_items)
		resp_string = resp_string.toLowerCase();
		if (this.array_of_selected_items.indexOf(resp_string) > -1) {
			return 1;
		} else if (resp_string.length == 0 && document.getElementById("UseNA").value == "na") {
			return 'na';
		} else {
			return 0;
		}
	}
	
	
	this.guess_what_is_correct = function() {
		// this will check boxes for columns where it thinks there is a correct answer.
		// It chooses columns where the top item's proportion correct is in a certain range, 
		// and it ignores any column that starts with "Timing" (because of qualtrics conventions)
		var i = 0;
		var temp_sim = 0;
		if (this.verified_answer == undefined || this.verified_answer.length == 0){
			// if there isn't a verified answer
			var top_response = this.sorted_array[0][0]
			var highest_proportion = this.sorted_array[0][1]/this.total_responses
			if (highest_proportion > .2 && highest_proportion < 1 && this.column_name.indexOf("Timing") !== 0) {
				// if it's a column that should be scored automatically
				try {
					if (document.getElementById(column_number+'*0').checked != true) {
						document.getElementById(column_number+'*0').click();
					}
					if (document.getElementById('lenient_checkbox').checked) {
						// this loop goes through the other responses and if any look like misspellings
						// (i.e., are similar) it marks them as correct as well
						for (i = 1; i < this.sorted_array.length; i++) {
							temp_sim = similarity(top_response, this.sorted_array[i][0]);
							if (temp_sim >= good_match_threshold) {
								if (document.getElementById(column_number+'*'+i).checked != true) {
									document.getElementById(column_number+'*'+i).click();
								}
	// 							console.log('Selected multiple in '+this.column_name+" "+this.sorted_array[i][0]+'=' + temp_sim)
							}
						}
					}
				} catch(err) {
					// I think this error occurs in columns where the most common response is a blank, but 
					// other responses are also given (i.e., it's not all blanks). 
					// It's not actually a problem because the blank isn't correct anyway. Just ignore it.
	// 				console.log( 'error in ' + this.column_name+', '+column_number+'*0'+': '+err)
				}
			}
		} else {
			for (i = 0; i < this.sorted_array.length; i++) {
// 			console.log( 'checking '+this.sorted_array[i][0])
				temp_sim = similarity(this.verified_answer, this.sorted_array[i][0]);
				if (temp_sim >= good_match_threshold) {
					if (document.getElementById(column_number+'*'+i).checked != true) {
						document.getElementById(column_number+'*'+i).click();
					}
// 							console.log('Selected multiple in '+this.column_name+" "+this.sorted_array[i][0]+'=' + temp_sim)
				}
			}

		}
	}
}

function showLSstuff() {
	var x = document.getElementById("lsBigBox");
	x.style.display = "flex";
	x = document.getElementById("formatSelectorBox");
	x.style.display = "none";

	if (document.getElementById("lsBigBox").scrollWidth >= document.getElementById("scrollable_box").scrollWidth) {
		// if the window with the checkboxes doesn't go beyond the margin, don't show the number of columns selected or jump arrows
		document.getElementById("jump_arrows").style.display = "none";
		document.getElementById("status_text").style.display = "none";		
	}
	
	if (document.getElementById('verified_answers').checked) {
		document.getElementById("auto_score_box").style.display = "none";
		autoScore();
	}
}

function computeLevels_verified_correct(columnNum) {
	// The input parameter identifies the column num that has the correct answers in it. 
	// This doesn't return anything. It sets values for an array called correct_answer. 
	var tempCorrect = ''
	
	for (i = 1; i < inputCell.length; i++) { // start with 1 to avoid column name
		tempCorrect = inputCell[i][columnNum].toLowerCase()

		if (correct_answer.indexOf(tempCorrect) == -1) { // it's identified a novel unique between-level combination
			correct_answer.push(tempCorrect);
		}
	}

	correct_answer.sort();
}

function computeLevels(input_array) {
	// This takes an input array and return the same array but in lowercase (if appropriate) and with nulls
	// having been replaced with ''
	var i = 0;
	var data_values = [];
	
	for (i = 0; i < input_array.length; i++) {
		if (input_array[i] !== undefined && input_array[i] !== null) {
			if (document.getElementById('ignore_case').checked && typeof input_array[i] == 'string') {
				input_array[i] = input_array[i].toLowerCase();
			}
			data_values.push(input_array[i])
		} else {
			data_values.push('')
		}
	}
	return data_values
}

function buildVariableSelectorTable_lenientScorer() {
	// this is called by file_importExportContent.js
	var i = 0;
	var temp_array = [];
	
	
	// turn empty cells into blanks
	for (i = 0; i < inputCell[0].length; i++) { 
		for (j = 1; j < inputCell.length; j++) {
			if (inputCell[j][i] == undefined || inputCell[j][i] == null) {
				inputCell[j][i] = '';
			}
		}
	}

	if (document.getElementById('verified_answers').checked) {
		computeLevels_verified_correct(0)
		
		for (i = 0; i < correct_answer.length; i++) { 
			temp_array = [];
			for (j = 0; j < inputCell.length; j++) {
				if (inputCell[j][0].toLowerCase() == correct_answer[i]) { 
					temp_array.push(inputCell[j][1])
				}
			}

			answer_group[i] = new answer_group_object(correct_answer[i], i, computeLevels(temp_array), correct_answer[i])
			answer_group[i].compute_levels()
		}
	} else {	
		for (i = 0; i < inputCell[0].length; i++) { 
			temp_array = [];
			for (j = 1; j < inputCell.length; j++) {
				temp_array.push(inputCell[j][i])
			}

			answer_group[i] = new answer_group_object(inputCell[0][i], i, computeLevels(temp_array))
			answer_group[i].compute_levels()
		}
	}
	
	// Build Header
	var tempColName = '';
	var tempValueToShow = '';
	var out = "";
	out = out + "<div><table><tr>";
	// Build column names and checkboxes.
	for (i = 0; i < answer_group.length; i++) {
		tempColName = answer_group[i].column_name;
		out = out + "<td id='"+i+"*header' style='vertical-align: top; min-width: 10em; padding-bottom: 1em'>"
		out += "<b>" + tempColName + "</b><br>";
		for (j = 0; j < answer_group[i].level_text.length; j++) {
			tempValueToShow = answer_group[i].sorted_array[j][0];
			if (tempValueToShow !== undefined && tempValueToShow !== null) {
				if (tempValueToShow.length > 0) {
					tempID = i+'*'+j; // col*row
					if (document.getElementById('verified_answers').checked) {
// 						tempValueToShow = tempColName+' - '+tempValueToShow;

					}
					out = out + '<input type="checkbox" name="'+i+'" id="'+tempID+'" onchange="boxClicked(this.id)" ><label for="'+tempID+'">'+tempValueToShow+'</label> <div style="display: inline-block; color: grey">n='+answer_group[i].sorted_array[j][1]+'</div><br>'
     				}
			} else {
				console.log( 'null: tempid = '+tempID+' tempcolnam='+tempColName+' tempValueToShow='+tempValueToShow)
			}
			if (j >= maximum_num_checkboxes-1) {break;} // this means it never gives you more than x options
		}
		out = out + "</td>";
		if (document.getElementById('verified_answers').checked) {
			out += "</tr><tr>"
		}
	}
	out = out + "</tr></table></div>";

	// Show the table
	document.getElementById("variable_selector_table").innerHTML = out;
	
	hideFileSelectorStuff();
	showLSstuff();
}

function autoScore() {
	var i;

	for (i = 0; i < answer_group.length; i++) {
		answer_group[i].guess_what_is_correct()
	}
}

function autoScroll(direction) {
	var i = 0;
	var pos = '';
	var w = document.getElementById("scrollable_box").offsetWidth 	
	
	if (direction == "right") {
		// Loop through columns from left to right and find the first selected column that is to the right of the visible window. Jump to it. 
		for (i = 0; i < answer_group.length; i++) {
			if (answer_group[i].array_of_selected_items.length > 0) { // if something has been selected in the column
				pos = document.getElementById(i+"*header").getBoundingClientRect().left
				if (pos > w) { // this means if pos is beyond the visible area
					document.getElementById(i+"*header").scrollIntoView();
					break;
				}
			}
		}
	} else if (direction == "left") {
		// Loop through columns from right to left and find the first selected column that is to the left of the visible window. Jump to it. 
		for (i = answer_group.length-1; i >= 0; i--) {
			if (answer_group[i].array_of_selected_items.length > 0) { // if something has been selected in the column
				pos = document.getElementById(i+"*header").getBoundingClientRect().left
				if (pos < 0) { // this means if pos is beyond the visible area
					document.getElementById(i+"*header").scrollIntoView();
					break;			
				}
			}
		}
	}
}

function formatButtonClicked(element_id) {
	document.getElementById("fileSelectorBox").style.display = "block" // show the file selector box
	localStorage.setItem("lenient_scorer_file_format", element_id); // put which format they selected in the local browser storage
}

function boxClicked(element_id) {
	// when a checkbox is clicked, update the answer_group object so it knows what's selected.
	var ij = element_id.split('*')
	var tempColumnNum = ij[0]
	var tempItemValue = answer_group[tempColumnNum].sorted_array[ij[1]][0]

	if (document.getElementById(element_id).checked) {
 		// if the element was just checked
		answer_group[tempColumnNum].array_of_selected_items.push(tempItemValue)
	} else {
		// if the element has just been unchecked
		const index = answer_group[tempColumnNum].array_of_selected_items.indexOf(tempItemValue);
		answer_group[tempColumnNum].array_of_selected_items.splice(index, 1);
	}
	
	// figure out how many columns have a checkbox selected, and the total number of checkboxes selected
	var i;
	var num = 0;
	var num_columns_selected = 0;
	var num_boxes_selected = 0;
	for (i = 0; i < answer_group.length; i++) {
		num = answer_group[i].array_of_selected_items.length
		if (num > 0) {
			num_columns_selected++;
			num_boxes_selected += num;	
		}
	}
	var temp_status = num_columns_selected+' columns selected'
	if (num_boxes_selected > num_columns_selected) {
		temp_status += ' ('+num_boxes_selected+' boxes)'
	}
	document.getElementById('status_text').innerHTML = temp_status
		
}

function buildOutputStringLenientScorer() {
	// have the answer_group objects compute their scores (the objects already know what boxes are checked)
	// and then turn that into an output string.
	var i = 0;
	var out = "";
	var out_array = [];
	var temp_index = 0;
		
// 	console.log( '-building output string-')
	
	if (document.getElementById('verified_answers').checked) {
		for (i = 1; i < inputCell.length; i++) { // go through the rows
			temp_index = answer_group.findIndex(x => x.column_name === inputCell[i][0].toLowerCase())
// 			console.log( temp_index+' '+inputCell[i][0]+' '+inputCell[i][1]+' '+answer_group[temp_index].binary_item(inputCell[i][1]))
			out_array.push(inputCell[i][0]+'\t'+inputCell[i][1]+'\t'+answer_group[temp_index].binary_item(inputCell[i][1]))
		}
	} else {
		for (i = 0; i < answer_group.length; i++) {
			// have each answer_group object compute it's binary_array, which is the 0 or 1 scoring of each response
			// then add the resulting array to the variable out_array. 
			if (answer_group[i].array_of_selected_items.length > 0) { // if at least one thing is selected in the column, score it
				out_array.push(answer_group[i].binary_array())
			}
		}
	}

	// take out_array and turn it into a tab-delimited string 
	// Out array is an array where each element is a binary array for a column. 
	if (out_array.length < 1) {
		return "No Output Data Available";
	} else if (typeof out_array[0] == 'string') {
		// if it's a one dimensional array because use verified answers is true
		for (j = 0; j < out_array.length; j++) {
			out += out_array[j]+'\r\n'
		}
	} else {
		for (i = 0; i < out_array[0].length; i++) {
			for (j = 0; j < out_array.length; j++) {
				out += out_array[j][i]+'\t'
			}
			out += '\r\n'
		}
	}
	return out;
}
</script>