<!DOCTYPE html>
<html lang="en">

<head>
	<title>Lenient Scorer</title>
	<meta charset="UTF-8">
	<meta name="description" content="Lenient Scorer: quick, easy, private, and free way to grade/score responses in a datafile">
	<meta name="keywords" content="data, analysis, easy, free, clean, analyze, organize, application, program">
	<meta name="author" content="Nate Kornell">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="stylesheet" type="text/css" href="mystyle.css">
</head>

<body> 
	<!--  navigation menu -->
	<nav>
		<ul>
			<li><div class="navMenuItem selected"><a href="index.html">Home</a></div></li>
			<li style="float:right"><div class="navMenuItem" id = 'about_link' style="display: inline-block; cursor: pointer"" onclick="show_or_hide_about()">About ▾</div></li>
		</ul>
	</nav>

	<!-- about -->
	<div id='about' style="display: none;">
		<div class='boxAroundTable'>
			<p><b>About</b>
			<p>This program assumes your datafile format is similar to Qualtrics, where each
			column of data represents a single question. 
			After you pass it your datafile, it will show you all of your column names. 
			Common responses are shown below each one. Just click on the correct responses!
			(Or start by clicking the Auto-Score button.) 
			<p>When you are done, press export. A new datafil will be created on your desktop. 
			Any responses you've clicked will be given a score of 1. 
			<p>Autoscore selects the most common answer in each column for you. It also selects
			misspelled versions of that answer. It ignores columns where accuracy is perfect, or very low, and any 
			column name that starts with the word "Timing."
			It 
			<p>This process keps your data private. The program never uploads your data 
			and no one can access it except you.
			
		</div>
	</div>


	<!-- ~~- processing files ~~- -->
	<div id="processingBox">
		<div class="dragDropBox" id="processing" style='text-align: left; vertical-align: bottom; padding: 5px'></div>
	</div>

	<!-- ~~- choosing a file ~~- -->
	<div id="fileSelectorBox">
		<center>
		<div class="roundedBox dragDropBox" id="drop_zone">
			<img src="images/pm.png" style="position: relative; width: 300px; opacity: 0.2; ">
			<div class="middleCenter">
				<h1>Lenient Scorer</h1>
				<h2>drag a text file here</h2>
			</div>
		</div>
		
		Or if you prefer <input type="file" id="files" name="files[]" single />
		</center>

<!-- 		The checkbox below works. I made it invisible because I think I will always want to ignore capitalization and it makes the visuals too busy/complicated -->
		<p style="display: none"><input type="checkbox" id="ignore_case" checked ><label for="ignore_case">Ignore capitalization of user responses (e.g., Smith = smith)</label> </p>
	</div>


<div class='bigBox' id='lsBigBox' style="display: none">
<!-- 	Variable selector -->
	<div class='bigBox'> 
		<p style="margin-left: 10px">Select correct responses </p>
		<div class='boxAroundTable' id='scrollable_box' style="overflow-x: scroll; height: 20rem; overflow-y: scroll; margin-bottom: 10px">
			<div id="variable_selector_table"></div>
		</div>
		
		<p><div id='status_text' style='display: inline-block; margin-left: 10px'></div> <!--  0 columns selected -->
		<div style="display: inline-block; float: right; text-align:right; margin-right: 10px"> jump to next selected column <button onclick="autoScroll('left')">←</button><button onclick="autoScroll('right')">→</button></div></p>
		<br>
		<div class='boxAroundTable'>
<!-- 			<div style="font-weight: bold">Selection Tools</div> -->
			<p><button onclick="autoScore()">Auto-Score</button>
			<input type="checkbox" id="lenient_checkbox" checked><label for="lenient_checkbox">Count misspelled answers as correct</label> 
			</div>
		<div class='boxAroundTable'>
			<p><a id="exportButton" href="#" class='coolButton'>Export Results to File</a> 	
		</div>

		<div class='boxAroundTable'>
			<div style="font-weight: bold">Settings</div>
			<p>Mark blank responses as 
			<select id='UseNA'>
				<option value='Zero'>Zero</option>
				<option value='na'>na</option>
			</select>
		</div>
	</div>
</div>


</body>
</html>



<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- -->


<script src="file_select.js"></script>
<script src="file_importExportContent.js"></script>
<script src="functions_indexpage.js"></script>
<script src="functions_stats.js"></script>

<script>

var column_data = []
var maximum_num_checkboxes = 9;
var good_match_threshold = .80 // score when comparing two strings

function show_or_hide_about() {
	if (document.getElementById("about").style.display === "none") {
		document.getElementById("about").style.display = "block";
		document.getElementById("about_link").innerHTML = "About ▴"

	} else {
		document.getElementById("about").style.display = "none";
		document.getElementById("about_link").innerHTML = "About ▾"
	}
}

function column_data_object(input_name, column_number, input_values) { 
	// this is an object that represents a column of data
	this.column_name = input_name;
	
	this.level_text = []
	this.level_num_observations = []
	this.sorted_array = []
	this.array_of_selected_items = []
	this.total_responses = 0
	for (i = 0; i < input_values.length; i++) {
		if (input_values[i].length > 0) {
			this.total_responses++
		}
	}

	this.compute_levels = function(input_search_status) {
		// figure out what different values are in the column, and how many times each one apears
		var i = 0;
		var tempLevel = '';
		
		for (i = 0; i < input_values.length; i++) {
			tempLevel = input_values[i];

			if (this.level_text.indexOf(tempLevel) == -1) { // it's identified a novel unique between-level combination
				this.level_text.push(tempLevel);
				this.level_num_observations[tempLevel] = 1;
			} else {
				this.level_num_observations[tempLevel]++
			}
		}
		
		for (i = 0; i < this.level_text.length; i++) {
			this.sorted_array.push([this.level_text[i], this.level_num_observations[this.level_text[i]]])
		}
		
		this.sorted_array.sort(function(a, b) {
		    return b[1] - a[1]; // because it's b then a, it sorts descending
		});
	}
	
	this.binary_array = function() {
		// This returns an array with a value of 1 or 0 for each item in the column. 
		// It's a 1 if the item is in the list of checked items and 0 if it's not. 
		var out = [];
		out.push('score_'+this.column_name)
		for (i = 0; i < input_values.length; i++) {
			if (this.array_of_selected_items.indexOf(input_values[i]) > -1) {
				out.push('1')
			} else if (input_values[i].length == 0 && document.getElementById("UseNA").value == "na") {
				out.push('na')
			} else {
				out.push('0')
			}
		}
		return out
	}
	
	this.guess_what_is_correct = function() {
		// this will check boxes for columns where it thinks there is a correct answer.
		// It chooses columns where the top item's proportion correct is in a certain range, 
		// and it ignores any column that starts with "Timing" (because of qualtrics conventions)
		var i = 0;
		var temp_sim = 0;
		var top_response = this.sorted_array[0][0]
		var highest_proportion = this.sorted_array[0][1]/this.total_responses
		if (highest_proportion > .2 && highest_proportion < 1 && this.column_name.indexOf("Timing") !== 0) {
			// if it's a column that should be scored automatically
			try {
				if (document.getElementById(column_number+'*0').checked != true) {
					document.getElementById(column_number+'*0').click();
				}
				if (document.getElementById('lenient_checkbox').checked) {
					// this loop goes through the other responses and if any look like misspellings
					// (i.e., are similar) it marks them as correct as well
					for (i = 1; i < this.sorted_array.length; i++) {
						temp_sim = similarity(top_response, this.sorted_array[i][0]);
						if (temp_sim >= good_match_threshold) {
							if (document.getElementById(column_number+'*'+i).checked != true) {
								document.getElementById(column_number+'*'+i).click();
							}
// 							console.log('Selected multiple in '+this.column_name+" "+this.sorted_array[i][0]+'=' + temp_sim)
						}
					}
				}
			} catch(err) {
				// I think this error occurs in columns where the most common response is a blank, but 
				// other responses are also given (i.e., it's not all blanks). 
				// It's not actually a problem because the blank isn't correct anyway. Just ignore it.
// 				console.log( 'error in ' + this.column_name+', '+column_number+'*0'+': '+err)
			}
		}
	}
}

function showLSstuff() {
	var x = document.getElementById("lsBigBox");
	x.style.display = "flex";
}

function computeLevels(colNum) {
	// Return an array listing all observed levels of the requested colNum.
	
	var i = 0;
	var data_values = [];
	for (i = 0; i < inputCell.length; i++) {
// 		console.log( inputCell.length)
		if (inputCell[i][colNum] !== undefined && inputCell[i][colNum] !== null) {
			if (document.getElementById('ignore_case').checked && i > 0 && typeof inputCell[i][colNum] == 'string') {
				inputCell[i][colNum] = inputCell[i][colNum].toLowerCase();
			}
			data_values.push(inputCell[i][colNum])
		} else
			data_values.push('')
	}

	var columnName = data_values.shift(); // get rid of the first element, which is the column name
	column_data[colNum] = new column_data_object(columnName, colNum, data_values)
	column_data[colNum].compute_levels()
}

function buildVariableSelectorTable_lenientScorer() {
	var i = 0;

	for (i = 0; i < inputCell[0].length; i++) { 
		computeLevels(i);
	}

	// Build Header
	var tempColName = '';
	var tempItemValue = '';
	var out = "";
	out = out + "<div><table><tr>";
	// Build column names and checkboxes.
	for (i = 0; i < inputCell[0].length; i++) {
		tempColName = inputCell[0][i];
		out = out + "<td id='"+i+"*header' style='vertical-align: top; min-width: 10em'><b>" + tempColName + "</b><br>";
		for (j = 0; j < column_data[i].level_text.length; j++) {
			tempItemValue = column_data[i].sorted_array[j][0];
			if (tempItemValue !== undefined && tempItemValue !== null) {
				if (tempItemValue.length > 0) {
					tempID = i+'*'+j; // col*row
					out = out + '<input type="checkbox" name="'+i+'" id="'+tempID+'" onchange="boxClicked(this.id)" ><label for="'+tempID+'">'+tempItemValue+'</label> <div style="display: inline-block; color: grey">n='+column_data[i].sorted_array[j][1]+'</div><br>'
				}
			} else {
				console.log( 'null: tempid = '+tempID+' tempcolnam='+tempColName+' tempItemValue='+tempItemValue)
			}
			if (j >= maximum_num_checkboxes-1) {break;} // this means it never gives you more than x options
		}
		out = out + "</td>";
	}
	out = out + "</tr></table></div>";

	// Show the table
	document.getElementById("variable_selector_table").innerHTML = out;
	
	hideFileSelectorStuff();
	showLSstuff();
}

function autoScore() {
	var i;

	for (i = 0; i < inputCell[0].length; i++) {
		column_data[i].guess_what_is_correct()
	}
}

function autoScroll(direction) {
	var i = 0;
	var pos = '';
	var w = document.getElementById("scrollable_box").offsetWidth 	
	
	if (direction == "right") {
		// Loop through columns from left to right and find the first selected column that is to the right of the visible window. Jump to it. 
		for (i = 0; i < inputCell[0].length; i++) {
			if (column_data[i].array_of_selected_items.length > 0) { // if something has been selected in the column
				pos = document.getElementById(i+"*header").getBoundingClientRect().left
				if (pos > w) { // this means if pos is beyond the visible area
					document.getElementById(i+"*header").scrollIntoView();
					break;
				}
			}
		}
	} else if (direction == "left") {
		// Loop through columns from right to left and find the first selected column that is to the left of the visible window. Jump to it. 
		for (i = inputCell[0].length-1; i >= 0; i--) {
			if (column_data[i].array_of_selected_items.length > 0) { // if something has been selected in the column
				pos = document.getElementById(i+"*header").getBoundingClientRect().left
				if (pos < 0) { // this means if pos is beyond the visible area
					document.getElementById(i+"*header").scrollIntoView();
					break;			
				}
			}
		}
	}
}

function boxClicked(element_id) {
	// when a checkbox is clicked, update the column_data object so it knows what's selected.
	var ij = element_id.split('*')
	var tempColumnNum = ij[0]
	var tempItemValue = column_data[tempColumnNum].sorted_array[ij[1]][0]

	if (document.getElementById(element_id).checked) {
 		// if the element was just checked
		column_data[tempColumnNum].array_of_selected_items.push(tempItemValue)
	} else {
		// if the element has just been unchecked
		const index = column_data[tempColumnNum].array_of_selected_items.indexOf(tempItemValue);
		column_data[tempColumnNum].array_of_selected_items.splice(index, 1);
	}
	
	// figure out how many columns have a checkbox selected, and the total number of checkboxes selected
	var i;
	var num = 0;
	var num_columns_selected = 0;
	var num_boxes_selected = 0;
	for (i = 0; i < inputCell[0].length; i++) {
		num = column_data[i].array_of_selected_items.length
		if (num > 0) {
			num_columns_selected++;
			num_boxes_selected += num;	
		}
	}
	var temp_status = num_columns_selected+' columns selected'
	if (num_boxes_selected > num_columns_selected) {
		temp_status += ' ('+num_boxes_selected+' boxes)'
	}
	document.getElementById('status_text').innerHTML = temp_status
		
}

function buildOutputStringLenientScorer() {
	// have the column_data objects compute their scores (the objects already know what boxes are checked)
	// and then turn that into an output string.
	var i = 0;
	var out = "";
	var out_array = [];
	
	for (i = 0; i < inputCell[0].length; i++) {
		// have each column_data object compute it's binary_array, which is the 0 or 1 scoring of each response
		// then add the resulting array to the variable out_array. 
		if (column_data[i].array_of_selected_items.length > 0) { // if at least one thing is selected in the column, score it
			out_array.push(column_data[i].binary_array())
		}
	}

	// take out_array and turn it into a tab-delimited string 
	// Out array is an array where each element is a binary array for a column. 
	if (out_array.length < 1) {
		return "No Output Data Available";
	} else {
		for (i = 0; i < out_array[0].length; i++) {
			for (j = 0; j < out_array.length; j++) {
				out += out_array[j][i]+'\t'
			}
			out += '\r\n'
		}
		return out;
	}
}
</script>