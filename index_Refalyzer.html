<!-- 
To do: 

- this returns wrong. what it means is, the user was wrong. that's different than thinking the answer its giving is wrong. 
	Besken, M. (2016). Picture-perfect is not perfect for metamemory: Testing the perceptual fluency hypothesis with degraded images. Journal of Experimental Psychology: Learning, Memory, and Cognition, 42, 1417–1433. go to the store and buy a carpet, buy a floor https://doi.org/10.1037/xlm0000246
- same here, except here, maybe the user was right. it's not showing the subtitle
	Zhang, Y., Pan, Z., Li, K., & Guo, Y. (2018). Self-serving bias in memories: Selectively forgetting the connection between negative information and the self. Experimental Psychology, 65, 236–244. http://dx.doi.org/10.1027/1618-3169/a000409	

- If you ask it to do too many rows, it barfs after doing some of the doi rows. I'd like to make it handle those errors better. 
- It would speed things up to not wait for all of the lines to come in before trying to combine. Maybe if an obj is correct it should try to combine right away?
- With two non-user-doi rows, it's possible that neither doi it finds is right. In this case, maybe it could find the right doi if they were combined and then sent to the server, but as of now the program doesn't check the database for the combo. 
- Just looking at the output, it seems like maybe some of the ones marked wrong are actually right. Should they be marked probable instead? 


Author table
- Look for cases where it's the same author but the name is different (e.g., Bjork, E. L. and Bjork, 
Elizabeth Ligon). Combine them. Also, check if they're the same when ignoring case

-->

<!-- stuff to test-->
<!--
This makes it decide the other doi will be better, and therefore return, during decide to combine

metacognitive judgments. Journal of 
Experimental Psychology: Learning, frank
Memory, and Cognition, 43, 680–693. 


-->

<!-- 
Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning 

(JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL 

effect”. Memory, 26, 771–783. 

https://doi.org/10.3758/s13421-013-0307-8

Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL 
 -->
 
<!-- 
Hicks, J. L., & Cockman, D. W. (2003). The effect of general knowledge on source memory

and decision processes. Journal of Memory and Language, 48, 489–501.

https://doi.org/10.1016/S0749-596X(02)00537-5

Johnson, M. K., Hashtroudi, S., & Lindsay, D. S. (1993). Source monitoring. Psychological

Bulletin, 114, 3–28. https://doi.org/10.1037/0033-2909.114.1.3


Dunlosky, J., & Nelson, T. O. (1997). Similarity between the cue for judgments of 

learning (JOL) and the cue for test is not the primary determinant of JOL 

accuracy. Journal of Memory and Language, 36, 34–49. 
 -->


<!-- 
Heck, D. W., Gronau, F. Q., & Wagenmakers &, E.-J. (2019). metaBMA: Bayesian Model

Averaging for Random and Fixed Effects Meta-Analysis. https://CRAN.R-project.org/package=metaBMA.

Henkel, L. A., Johnson, M. K., & De Leonardis, D. M. (1998). Aging and source monitoring:

Cognitive processes and neuropsychological correlates. Journal of Experimental

Psychology: General, 127, 251–268. https://doi.org/10.1037/0096-3445.127.3.251 Hicks, J. L., & Cockman, D. W. (2003). The effect of general knowledge on source memory

and decision processes. Journal of Memory and Language, 48, 489–501.

https://doi.org/10.1016/S0749-596X(02)00537-5
 -->

<!--
~~
this causes ABCABC to get messed up. I think basically, if there's only dois plus duplicates, it's a problem. 

Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL effect”. Memory, 26, 771–783. https://doi.org/10.1080/09658211.2017.1406523

DELAYED JUDGMENTS IN SOURCE MONITORING 53


DELAYED JUDGMENTS IN SOURCE MONITORING 54
~~~

When you do this one of the lines ('remembered?...') gets deleted from user input
Besken, M., & Mulligan, N. W. (2013). Easily perceived, easily 
remembered? Perceptual interference produces a double dissociation 
between metamemory and memory performance. Memory & Cognition, 41, 
897–903. 

~~~

test this and see if it still causes an error. having the same reference appear twice (with or without doi) causes a breakdown where some references aren't found at all

Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect.

Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x 

Meiser, T., Sattler, C., & Von Hecker, U. (2007). Metacognitive inferences in source memory

judgements: The role of perceived differences in item recognition. Quarterly Journal of

Experimental Psychology, 60, 1015–1040. https://doi.org/10.1080/17470210600875215 Metcalfe, J. (2009). Metacognitive judgments and control of study. Current Directions in

Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x 

~~~
if there are duplicate lines but they're good, it gets rid of both. maybe it should keep one. to do this, I could
have it run the duplicate line array through the database and see if anything good comes out

aDunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20(4), 374–380.
aklsdkjf
bDunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20(4), 374–380.
~~~

 -->

<!--
Basic procedure:
// Step 1: take care of all of the user-input DOIs. Then try to combine.
// Step 2: search crossref for DOIs. Once they're all returned, try to combine.
-->


<!DOCTYPE html>
<html lang="en">

<head>
	<title>Citation Fixer</title>
	<meta charset="utf-8" />
	<meta name="description" content="format citations">
	<meta name="keywords" content="program">
	<meta name="author" content="Nate Kornell">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="stylesheet" type="text/css" href="mystyle.css">
	
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/citation-js"></script> <!-- this is to use citation-js -->
<!-- 	<script src="https://cdn.jsdelivr.net/npm/string-similarity"></script> -->
<!-- 	<script src="https://cdn.jsdelivr.net/npm/string-algorithms"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/string-similarity@4/package.json"></script> -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-2GM67KQ52J"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-2GM67KQ52J');
</script>

<script>
	var author_obj = [];
	var reference_obj = [];
	var text_obj = []
	var duplicate_input_text = [];
	var articleTableText = "";
	var startTime = 0;
	var started_notFoundYet = false;
	var doi_pattern = /10.\d{4,9}\/[-._;()/:A-Z0-9<>]+/gi; // doi_pattern is used to find a DOI within the input string. note: I added in the g, which makes it return all of the DOIs instead of just 1
    const cc = [];
    cc['fragment'] = 'blue';
    cc['wrong'] = 'red';
    var good_match_threshold = 80;
    var current_mode = '';

// 	var doi_pattern = \b(10[.][0-9]{4,}(?:[.][0-9]+)*/(?:(?!["&\'<>])\S)+)\b; // original from somewhere, I had to change it to make it work, see: https://www.regexpal.com/
// 	var doi_pattern = /\b(10[.][0-9]{4,}(?:[.][0-9]+)*\/(?:(?!["&\'<>])\S)+)\b/i; // works
// 	var doi_pattern = /^10.\d{4,9}/[-._;()/:A-Z0-9]+$/i; // from crossref

	let Cite = require('citation-js');

	function Text_object(input_userInput, input_doi, input_doi_type, input_ord) { 
		this.user_input = input_userInput;
        this.doi = input_doi.toLowerCase();
        this.doi_type = input_doi_type;
        this.input_order = input_ord;
        this.search_status = "not started";
        this.match_status = "unknown";
        this.combine_status = "not done";
		this.notes = "";
		this.removed = false;
		this.score = 0;
		this.letter_match = 0;
		this.letter_match_percentage = 0;
		
        
        this.table_row_number = function() {
            return document.getElementById(this.user_input).rowIndex;
        }

		this.update_input = function(input_search_status) {
			var temp_ref_to_show = '';
		    // possible search status values:
            //    not started, searching, incorrect doi entered; searching again, done 
		    // possible match status values
		    //    unknown, wrong, fragment, correct
		    
            if (this.removed) {
                console.log( 'updateinput called for .removed object (returned instead): '+this.user_input);
                return;
            }

		    if (input_search_status != '') {
    		    this.search_status = input_search_status;
    		}
		    
		    // if the user-entered doi was incorrect, change doi type
            if (input_search_status == 'incorrect doi entered; searching again') {
                this.doi_type = 'not_found_yet';
            }

			if (typeof reference_obj[this.doi] != 'undefined') { 
				// compute scores and statuses
				const temp_apa_no_html = reference_obj[this.doi].apa_no_html;
				temp_ref_to_show = reference_obj[this.doi].apa_no_html;
				temp_ref_to_show = temp_ref_to_show.replace('&#38;amp;', "&"); // otherwise it shows &amp; in place of the & character
				this.score = compute_score(temp_apa_no_html, this.user_input); // order has to be database version, user version 
				this.letter_match = compute_letter_match(temp_apa_no_html, this.user_input);
				this.letter_match_percentage = compute_letter_match_percentage(this.user_input, temp_apa_no_html); // order has to be user, database
				if (this.score > good_match_threshold) {
					this.good_match = true;
					this.match_status = 'correct';
				} else {
					if (this.letter_match_percentage > good_match_threshold) {
						this.good_match = true;
						this.match_status = 'fragment';
					} else {
						this.good_match = false;
						this.match_status = 'wrong';
					}
				}

				// set stuff up to show (this.notes)
                const c  = ['tomato','black'];                
                var temp_stringToShow = "";
				if (this.match_status != 'correct') {
					temp_stringToShow += '<div style="color:' + cc[this.match_status]  + ';">' + this.match_status+'</div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.score/60)] + ';">' + this.score+'=score </div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.letter_match/60)] + ';">' + this.letter_match+'=letter_match </div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.letter_match_percentage/60)] + ';">' + this.letter_match_percentage+"=letter_match_percentage</div>"; 
	                this.notes = temp_stringToShow;
				} else {
					this.notes = '';
				}
			} else {
			    // it wasn't found
// 				console.log( 'no obj: '+this.doi)
				this.match_status = 'unknown';
				temp_ref_to_show = '';
				if (this.search_status == 'done') {
				    this.combine_status = 'cannot be combined';
				    this.notes = "not found";
				}
			}
            
		    if (this.match_status == 'unknown' || this.match_status == 'correct') {
		        var temp_match_status_to_show = '';
		    } else {
    		    var temp_match_status_to_show = '<div style="color:' + cc[this.match_status]  + ';">' + this.match_status + '</div>';
		    }
		    if (this.search_status == 'done') {
		        var temp_search_status_to_show = '';
		    } else {
		        var temp_search_status_to_show = this.search_status;
		    }
		    
            if (this.notes == '') {
                this.notes = temp_search_status_to_show + temp_match_status_to_show; 
            }
//             console.log( this.user_input)
     		    		
            try { 
                // update html
                document.getElementById('inputText_'+this.user_input).innerHTML = this.user_input; 
                document.getElementById('reference_'+this.user_input).innerHTML = temp_ref_to_show; 
                document.getElementById('notes_'+this.user_input).innerHTML = this.notes; 
            } catch(err) {
                console.log( '<---------')
    		    console.log('*error in update input, for: ');
    		    console.log( this.user_input);
    		    console.log( temp_ref_to_show);
    		    console.log( err);
                console.log( '--------->')
            }
//             console.log( 'up this.updateinput')
    		update_progress(); // if this comes before the update html above, it causes errors (at least in the console). I failed to figure out why. 
		}
	}
	
	function Reference_object(input_userInput, input_json, input_apa) {
		this.user_input = input_userInput;
		this.json = input_json;
		this.apa = input_apa; // maybe this should be figured out here, not passed as a parameter?
		this.apa_no_html = jQuery(input_apa).text().trim(); // apa without the html tags
		this.doi = this.json.DOI;
 	}

	function Author_object(input_familyname, input_firstname) {
		// this creates instances of an author object, which is how I keep track of authors. 
		this.name = input_familyname + ", " + input_firstname;
		this.citation_count = 1;
		this.coauthors = [];
		this.checked = false;
		
		var firstName_array = input_firstname.replaceAll('. ',' ').replaceAll('.',' ').trim().split(" "); //array of first names with the periods replaced by spaces (which is only necessary for things like "T.O." as a first name)
		this.name_apa = input_familyname + ", " + first_letters(firstName_array);

		this.all_coauthors_string = function() {
			var i = 0;
			var temp = "";
			for (i = 0; i < this.coauthors.length; i++) {
				temp += this.coauthors[i].name + "; ";
			}
			return temp.substring(0, temp.length-2); // removes the final ";"
		};
	}


	async function getAllUrls(doi_type_to_handle) {
		// this gets called twice. First, for rows that have a doi. Then, when they're done, for rows that don't. 
        
		if (current_mode == 'completely done') {
            return;
        }

        var row_queue = [];
        var i = 0;

		for (let key in text_obj) { // this loops through all of text_obj
		    // if it's the right kind of doi, and has the right search status, add it to the row queue. 
            if (text_obj[key].doi_type === doi_type_to_handle) {
                if (text_obj[key].search_status === 'not started' || text_obj[key].search_status === 'incorrect doi entered; searching again') {
                    row_queue.push(text_obj[key].user_input);
                    if (text_obj[key].removed) {
                        console.log('**error: getting url for removed row: ' + text_obj[key].user_input)
                    }
                }
            }
		}

		console.log('-A- getting [' + row_queue.length + '] rows ('+doi_type_to_handle+')--')
        if (row_queue.length > 0) {
		    current_mode = "searching for dois"
            for (i = 0; i < row_queue.length; i++) {
                getOneURL(row_queue[i]); 
            }
		}
	}

	
	async function getOneURL(input_string) {	
// 		Be careful here! This calls everything async, which means that some of this code might 
// 		execute for item 12 before it gets to item 8, etc. Things can get out of order. Which means, 
// 		for example, that by the time it arrives at item x (e.g., 2), item x + y (e.g., 5) might have 
// 		already decided that x shouldn't be shown. And stuff. This is why the program does all the  
//		rows that have dois before starting on the ones that don't. 
        
	// If this function finds a doi in crossref, it recursively calls itself and returns. 
	// This is wasteful because it means going to a server to find JSON that's already 
	// been found, but I need the JSON in the format Cite uses, which is called Citation 
	// Style Language (CSL). And I couldn't figure out any other way. 

        var temp_ignore_doi = false;
        var temp_search_string = '';
        
        if (text_obj[input_string].search_status == "not started") {
       		text_obj[input_string].update_input('searching');
        } else if (text_obj[input_string].search_status == 'incorrect doi entered; searching again') {
       		text_obj[input_string].update_input('searching');
            temp_ignore_doi = true;
        }
        
		var stringToSend = '';
		var inputDOI = text_obj[input_string].doi;

		try {
			if (inputDOI === "" || temp_ignore_doi == true) {
                // if we're not using a doi (either there isn't on or it's bad), search crossref w/o a doi
                if (temp_ignore_doi == true) {
                    temp_search_string = remove_doi_from_string(input_string, inputDOI);
                    // maybe check if it's an empty string and if so, abandon ship?
                } else {
                    temp_search_string = input_string;
    			}
// 	       		pagelog( 'getOneURL [no doi]: '+temp_search_string)

   				stringToSend = 'https://api.crossref.org/works?mailto=nkornell@gmail.com&rows=1&query.bibliographic=' + temp_search_string.replaceAll(' ', '+');
				let myJSON = await $.getJSON(encodeURI(stringToSend));
				if (typeof myJSON.message.items[0] === 'undefined') { // if it's not in the database
					if (duplicate_input_text.indexOf(input_string) < 0) { // if it's not a duplicate
					    // this happens when a doi is bad	
		                text_obj[input_string].update_input('done');
					    console.log( "** found a doi that's bad, trying again (yay, delete this line)");
					} else {
					    console.log( "** 823 i didn't' think THIS HAPPENING WAS POSSIBLE");
					}
				} else {
					// if a doi was found, run this thing again but with the doi in the parameter, so Cite will work.
					text_obj[input_string].doi = myJSON.message.items[0].DOI;
// 					console.log( '774 happened;')
					getOneURL(input_string);
					return;
				}
			} else { 
			    // if a doi was found and we're using it (for now at least, unless we find out it's bad)
                let myJSON = await Cite.async(inputDOI);
                let bibliography = myJSON.format ('bibliography', {
                    format: 'html'
                });
            
                if (typeof reference_obj[myJSON.data[0].DOI] === 'undefined') { 
                    // create new reference
                    reference_obj[myJSON.data[0].DOI] = new Reference_object(input_string, myJSON.data[0], bibliography);
                }
                text_obj[input_string].doi = reference_obj[myJSON.data[0].DOI].doi; // this is helpful because sometimes an incorrect doi will be corrected when the json is returned (eg // turns into /)
                text_obj[input_string].update_input('done');
			}
		}
		catch(err) {
			if (err == "Error: Server responded with status code 404") {
			    //if it tried a doi that is incorrect, search again without the doi
				console.log( "could not find DOI " + inputDOI + " [searching again with doi removed]") // this is fine. it's supposed to happen when a doi is incorrect.
				if (text_obj[input_string].search_status == 'searching') {
            		text_obj[input_string].update_input('incorrect doi entered; searching again');
	    		} 
	    		   			
			} else if (err == 'Error: This format is not supported or recognized') { 
			    // if it found a doi that is correct, but the citation can't be found by Cite, give up.
                text_obj[input_string].update_input('done');
            } else if (err == 'Network request failed') {
			    console.log( 'Network request failed: '+input_string);
                text_obj[input_string].update_input('done');            
			} else {
			    console.log( '*error in get one url: '+input_string);
				console.log(err);
			}
		}
	}	
	
	function remove_duplicate_references() {
        // dfd could this whole function be merged with remove duplicate rows?
        var i = 0;
        var foof = 0;
        var temp_doi = '';
        var temp_doi_array = [];
	
       for (i = 1; i <= document.getElementById('article_table').rows.length - 1; i++) { // start at 1 to skip header row
			try {
				temp_row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
			} catch(err) {
			    console.log( "error 1244")
			    continue;
			}
			try {
				temp_doi = text_obj[temp_row_text].doi;
                if (temp_doi == '') {
                    // this just means this item doesn't have a doi yet
                	continue;
                }
			} catch(err) {
			    console.log( "error 1974")
			    continue;
			}
			
// 		    console.log( 'tempdoi='+temp_doi)
			if (temp_doi_array.includes(temp_doi)) {
                const r1 = temp_doi_array.indexOf(temp_doi) + 1;
                const r2 = i;
			    const r1_text = document.getElementById("article_table").rows[r1].cells[0].textContent
// 			    console.log( 'found a duplicate doi ['+temp_doi+'] in rows '+r1+', '+r2+': ' + r1_text)
                if (decide_whether_to_combine_rows(r1_text, r2 - r1) == true) {
                	foof++;
                }
			} else {
			    temp_doi_array.push(temp_doi);
			}			
        }
        console.log( '-E-removed ['+foof+'] duplicate references--');
	}

	function remove_duplicate_rows() {
	    // this is called once, after user dois have been processed
        // it's a 2-step process
        // 1. for each item, first it checks if it's on the remove list, then it checks whether it matches any other row
        // 2. after finding all the removable rows, it removes them all. 
	
		var i = 0;
		var target = 0;
		var target_string = '';
		var tempScore = 0;
		var target_has_been_found = false;
		var foof = 0;
		var local_list = [];
		var temp_row_text = '';
		       
        // go through the table and create an array that needs to be checked for whether it contains duplicates. 
		for (i = 1; i <= document.getElementById('article_table').rows.length - 1; i++) { // start at 1 to skip header row
			try {
				temp_row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
			} catch(err) {
			    console.log( "error 99833")
			}
           if (text_obj[temp_row_text].search_status === 'not started' || text_obj[temp_row_text].search_status === 'incorrect doi entered; searching again') {
                local_list.push(text_obj[temp_row_text].user_input);
                if (text_obj[temp_row_text].removed) {
                    console.log('**error: in remove duplicate rows, found removed row: ' + text_obj[temp_row_text].user_input)
                }
            }		
		}
		
		// find duplicate rows
        for (target = 0; target < local_list.length; target++) {
            target_has_been_found = false;
            target_string = local_list[target];
            for (i = 0; i < duplicate_input_text.length-1; i++) {
                tempScore = compute_letter_match(target_string, duplicate_input_text[i]);
                if (tempScore > 90) { // if it's the same as a previous row
                    if (duplicate_input_text.includes(target_string) == false) {
                        duplicate_input_text.push(target_string);
                    }
                    target_has_been_found = true;
                    break; // exit this loop
                }
            }
            if (target_has_been_found) {
                continue; // skip the rest of this loop and start with the next value (i.e., target+1). Because this target is already labelled a duplicate.
            } else {           
                for (i = target + 1; i < local_list.length; i++) {
                    tempScore = compute_letter_match(target_string, local_list[i]);
                    if (tempScore > 90) { // if it's the same as a previous row
                        if (duplicate_input_text.includes(local_list[i]) == false) {
                          duplicate_input_text.push(local_list[i]);
                        }

                        if (text_obj[target_string].match_status !== 'correct') {
                            if (duplicate_input_text.includes(target_string) == false) {
                                duplicate_input_text.push(target_string);
                            }
                        }
                    }   
                }
            }
        }
        
        // remove duplicate rows
        for (i = local_list.length - 1; i >= 0; i--) {
            if (duplicate_input_text.includes(local_list[i])) {
                if (text_obj[local_list[i]].doi_type != 'from_user') { // don't remove if it has a doi
                    remove_row(local_list[i]);                
                    foof++;
                }
            }
        }
//         if (foof > 0) {
            console.log('-C-removed ['+foof+'] duplicate rows--');
//         }
	}
	
	
	function pagelog(instring) {
        document.getElementById("outputText").innerHTML += '<p>' +instring;
	}
	
	function remove_row(input_string) {
		// remove a row that is no longer needed
		
        if (text_obj[input_string].removed) {
            // if it's already removed, don't remove it. 
            return;
        } else {
            try {
                if (text_obj[input_string].match_status == "correct") {
                    console.log('removing a "correct" row');
                }
                
                var row_to_remove = document.getElementById(input_string).rowIndex;
                document.getElementById("article_table").deleteRow(row_to_remove);
                
//                 console.log( 'removing row: '+input_string)

				text_obj[input_string].search_status = 'done';				
                text_obj[input_string].removed = true; // I think I did this rather than deleting it because get URL might be looking for it later. 
        
            }
            catch(err) {
                console.log( '*error in remove_row. input_string='+ input_string + " [error next line]");
                console.log( err);
            }
	        update_progress();
        }
	}

	function check_table_for_combinations() {
		var i = 0;
        var run_me_again = false;
        
	    current_mode = "checking combos"

		for (i = 1; i <= document.getElementById('article_table').rows.length - 1; i++) { // start at 1 to skip header row
			try {
				temp_row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
			} catch(err) {
				console.log( '*error setting temprowtext (i='+i+'): '+err);
				continue;
			}
			
			try {
                if (typeof text_obj[temp_row_text] == "undefined" || text_obj[temp_row_text] == null) {
                	// if the text obj can't be found, go to the next one (continue goes back up to the for loop)
					console.log( 'text_obj not found for '+temp_row_text);
                	continue;
                }
                
				temp_DOI = text_obj[temp_row_text].doi;
                if (temp_DOI == '') {
                    // this just means this item doesn't have a doi yet
                	continue;
                } 
                if (typeof reference_obj[temp_DOI] == "undefined" || reference_obj[temp_DOI] == null) {
                    // this will happen when there's one where the doi is correct but it's not in the database (it should be rare. but it's fine.)
                	continue;
                }
// 				console.log( 'deciding about: '+temp_DOI)
				if (decide_whether_to_combine_rows(temp_row_text,-1) == true) {
					run_me_again = true;
                    break; // exit this loop

				}
				if (decide_whether_to_combine_rows(temp_row_text, 1) == true) {
					run_me_again = true;
                    break; // exit this loop
				}
				if (run_me_again == false) {
                    text_obj[temp_row_text].combine_status = 'done';
//                     console.log( 'set cs to done: '+text_obj[temp_row_text].doi)
                }
			} catch(err) {
 				console.log( '*error could not run decide whether...: ')
 				console.log( ' *'+temp_row_text)
 				console.log( ' *'+err)
			}
		}
		if (run_me_again) {
// 			console.log( ';again;')
			check_table_for_combinations();
		} else {
			console.log( '-D-checked for combinations--')
		    current_mode = "done combining"
		    update_progress();
		}
	}

	function decide_whether_to_combine_rows(input_string, shift) {
        // make sure we're looking at two legitimate rows
        // this returns true if it makes any changes (i.e., removes a row or changes user input)
		if (document.getElementById(input_string) == null) { // this can happen when the user_input has changed but the reference obj hasn't)
			console.log( '**error: in decide whether to combine... null found for '+input_string)
			return false;
		}

         if (text_obj[input_string].removed) {
            console.log( '*tried to combine with a removed reference obj: '+input_string); 
            return false;
        }
        var row_index = text_obj[input_string].table_row_number();
		var other_row_index = text_obj[input_string].table_row_number() + shift;

        // don't try it if it would go outside the table
    	if (other_row_index < 1) { // it's 1 because row 0 is the table header
    	    return false;
    	} else if (other_row_index >= document.getElementById("article_table").rows.length) {
    	    return false;
    	}
        
        try {
	        var otherRow_input_string = document.getElementById("article_table").rows[other_row_index].cells[0].textContent;
	    } catch(err) {
	    	console.log( "**error: in decide whether... can't find this row: " + other_row_index)
	    	return false;
	    }
	    
	    if (text_obj[otherRow_input_string].removed) {
	        console.log( 'returning because otherRow has been removed: '+ otherRow_input_string)
	        return false;
	    }
	    
	    // see if the other row has a doi
	    var this_row_doi = text_obj[input_string].doi;
	    var otherRow_doi = text_obj[otherRow_input_string].doi;

	    // decide what to do
	    	    
        var shouldCombine = false;
        var shouldChangeUserInput = false;

		if (text_obj[input_string].match_status == "wrong") {
		    // this is where it would be smart to check whether the other one is also wrong, and if it is, join the strings and send that to the database.  
			return false; 
		}
        
        try {
            if (otherRow_doi == text_obj[input_string].doi) {
                // if they have the same doi
                shouldCombine = true;
//                 console.log( 'is this correlated with problems??????????')
            } else if (text_obj[otherRow_input_string].search_status == "searching") {
                // if it's still searching for the other row, return. it'll try again with that row later. 
                return false; 
            } else if (text_obj[otherRow_input_string].match_status == "correct") {
                // if the other one is correct (and we already know the dois are different), return. when the other one gets its chance, it'll combine with this one (if appropriate)
                return false;
            }
        } catch(err) {
            console.log( "*error palm frond for "+otherRow_input_string)
            console.log( err);
        }

        try {

            var bestcombo = best_combination(otherRow_input_string, input_string, reference_obj[this_row_doi].apa_no_html);
 
            // if the best match is the combo, combine them. 
            if (input_string !== bestcombo) {
                shouldCombine = true;
                shouldChangeUserInput = true;
            }
            
            if (shouldCombine) {
				if (otherRow_doi != '') {
					if (typeof reference_obj[otherRow_doi] != "undefined" && reference_obj[otherRow_doi] != null) {
						if (otherRow_doi != this_row_doi) {
							var bestcombo_other = best_combination(input_string, otherRow_input_string, reference_obj[otherRow_doi].apa_no_html);
							var s1 = compute_letter_match(bestcombo, reference_obj[this_row_doi].apa_no_html);
							var s2 = compute_letter_match(bestcombo_other, reference_obj[otherRow_doi].apa_no_html);
							if (s2 > s1) {
								console.log( 'using the other doi will be better!!! [returning]')
								console.log( '-score [' + s1 + '] ' + bestcombo)
								console.log( '-score [' + s2 + '] ' + bestcombo_other)
								return false; 
							}
						}
					}
				}
			}

            // if appropriate, remove the row
            if (shouldCombine == true) {
                remove_row(otherRow_input_string);
                if (shouldChangeUserInput == true) {
                    if (current_mode == "completely done") {
                        console.log( '...when completely done')
                        return true; // true because a row was removed above
                    }
                    change_user_input(input_string, bestcombo); // is input_string OK? 
                } else {
                    if (input_string == bestcombo) {
//                         console.log( "[didn't change user input] they're the same")
                    } else {
                        console.log( "[didn't change user input] "+input_string + " != "+bestcombo)
                    }
                }
                return true;
            } else {
                return false;
            }
        }
        catch(err) {
            console.log('*error in combine rows, otherRow_input_string:')
            console.log( otherRow_input_string);
            console.log( err)
        }
	}
	
	function change_user_input(from_string, to_string) { 
	    // this changes the user input in: the table, the reference obj, and...
	    // it also deletes the text obj and creates a new one in its place.
	
        try {
			if (text_obj[from_string].removed == true) {
				console.log( '**error: trying to change user input for a removed thing;)')
			}
			if (typeof text_obj[to_string] !== 'undefined' && text_obj[to_string] !== null) {
			    console.log( '**error 8484: tried to change user input to something that already existed [returning]')
			    return;
			}
        
            change_elementIDs(from_string, to_string);
        
//             console.log( 'change user input (from/to): ')
//             console.log( ' '+from_string)
//             console.log( ' '+to_string)

            // create a new version of the input obj (with a new array index), but then copy the old one into it. I think I did this because get url is going to be expecting to return info to this thingy
            text_obj[to_string] = new Text_object(to_string, "","",-1); // not giving it a doi means it won't add 1 to numRows withDOIsTotal
            text_obj[to_string] = Object.assign({}, text_obj[from_string]);
            text_obj[to_string].user_input = to_string;
            // update reference obj (i.e., from obj)
            reference_obj[text_obj[to_string].doi].user_input = to_string;
            text_obj[to_string].update_input('');

            update_progress();
        }
        catch(err) {
            console.log( '*error in change user input, from = '+from_string+' to = '+to_string+' error:')
            console.log( err)
        }
	}
	
	
	function best_combination(user_input_addition, user_input_target, goal) {
	    // tries the first two input parameters alone and in combination, to see which one matches the 3rd parameter best.
	    // the order of the first two parameters only matters because checks its percentage at the start
		var out = "";
    	var verbose = false;

		// if the new piece by itself is not a good percentage match for the target, don't combine
		var addition_Score_percent = compute_letter_match_percentage(user_input_addition, goal);
		if (addition_Score_percent < good_match_threshold) {
			return user_input_target;
		}

		// figure out the input, and put it in the order of the table (so that only forward combos will be accepted)
        if (document.getElementById(user_input_addition).rowIndex > document.getElementById(user_input_target).rowIndex) {
            aText = user_input_target;
            bText = user_input_addition;
		} else {
            aText = user_input_addition;
            bText = user_input_target;
		}
		comboText = aText + " " + bText;
		reverse_comboText = bText + " " + aText;
				
        try {
            aScore = compute_letter_match(aText, goal);
            bScore = compute_letter_match(bText, goal);
            comboScore = compute_letter_match(comboText, goal);
            reverse_comboScore = compute_letter_match(reverse_comboText, goal);
            
            // maybe to really be smart, it should look at where the fragment is (in the goal string). If it's the end, don't add 
            // something after it; if it's the start, don't add something before it. 
            
            if (verbose == true) {
                console.log( '--running best combination--');
                console.log('a = ['+text_obj[aText].search_status+', '+text_obj[aText].match_status+'] ' + aText)
                console.log('b = ['+text_obj[bText].search_status+', '+text_obj[bText].match_status+'] ' + bText)
                console.log( 'goal = '+goal)
                console.log( aScore, bScore, comboScore, reverse_comboScore)
                console.log( compute_letter_match_percentage(aText, goal),compute_letter_match_percentage(bText, goal),compute_letter_match_percentage(comboText, goal),compute_letter_match_percentage(reverse_comboText, goal))
            }
        }
        catch(err) {
            console.log('*error in best combination:')
            console.log('aText was='+aText);
            console.log('bText was='+bText);
        }
        
        reverse_comboScore = 0; // doing this makes it so reverse can't win. 
		maxScore = Math.max(aScore,bScore,comboScore,reverse_comboScore);
		if (maxScore == comboScore) {
		    if (verbose == true) {console.log( 'winner=comboText');}
			return comboText;
		} else if (maxScore == reverse_comboScore) {
		    if (verbose == true) {console.log( 'winner=reverse comboText');}
			return reverse_comboText;
		} else if (maxScore == aScore) {
		    if (verbose == true) {console.log( 'winner=returning earlier table entry');}
			return aText;
		} else if (maxScore == bScore) {
		    if (verbose == true) {console.log( 'winner=returning later table entry');}
			return bText;
		}
	}
	
	function compute_score(databaseString, userString) {
		// figure out whether a DOI was found in the user input
		var userDOI = userString.match(doi_pattern); 
		var databaseDOI = databaseString.match(doi_pattern); 
		
		// return a score
		if (typeof userDOI !== 'undefined' && userDOI !== null && userDOI.length > 0) {	// with typeof, put undefined in quotes
			// if there was a valid DOI in the user input, return a score of 100
			if (userDOI[0].toLowerCase() == databaseDOI[0].toLowerCase()) { 
			    // if a doi was found, it returns percentage. why? basically, if it's part of a reference with the right doi, this 
			    // will be high. but if it's the wrong reference, it'll be low. 
			    return compute_letter_match_percentage(userString,databaseString);
			} else {
				// if the user doi wasn't the same as the database one (is this possible?!) return the match strength without removing the doi
				// this happens when there's a bad doi, it searches without the doi, and finds a good doi to replace the bad one
				return compute_letter_match(databaseString,userString);
			}
		} else {
			// if there is not a valid doi in the user input, remove the doi from the database string for the sake of comparison. 
			// this does not use percentage because without a doi, I can't assume either side is good 
			databaseString = remove_doi_from_string(databaseString, databaseDOI);
			return compute_letter_match(databaseString,userString);
		}
	}
	
	function compute_letter_match(a, b) {
		return Math.ceil(100*similarity(a,b));
	}
	
	function compute_letter_match_percentage(a, b) {
        // This returns how good a match it is in terms of doing the best it could. 
        // In other words, the amount of letter match divided by the total possible amount of letter match. 
        
		var tempMatch = compute_letter_match(a, b);
		var maxPossible = a.length / b.length;
		
       // This would make it so that the order of the input parameters would not matter. However, the second parameter (b) is the target string, so here it does matter.
// 		if (maxPossible > 1) {
// 			maxPossible = 1/maxPossible;
// 		}
		maxPossible = 100*maxPossible;
        
        var return_value = Math.ceil(100*tempMatch/maxPossible);
        if (return_value > 100) {
            return_value = 100
        }
// 		console.log('match: ' + tempMatch + '/' + maxPossible + ' = '+ return_value);
		
		return return_value;
	}

	function change_elementIDs(from, to) {
	    try {
            document.getElementById(from).id = to;
            document.getElementById('reference_'+from).id = 'reference_'+to;
            document.getElementById('inputText_'+from).id = 'inputText_'+to;
            document.getElementById('notes_'+from).id = 'notes_'+to;			
        } catch(err) {
            console.log( '*error in change element IDs')
            console.log( 'from = '+from)
            console.log( 'to = '+to)
            console.log( err)
        }
	}
	
	function remove_doi_from_string(input_string, input_doi) {
	    var foof = '';
	    
        foof = input_string.replace("https://doi.org/"+input_doi,""); // assuming what seems like the standard format from the database
        foof = input_string.replace("https://dx.doi.org/"+input_doi,""); // I'm not even sure this can happen or is necessary, but it doesn't seem to hurt. 
        foof = foof.replace(input_doi,""); // in case that wasn't found, remove just the doi
        
        return foof;
	}
	
	function parse_JSON_for_authors(input_json) {
		var tempAuthor_full = "";
		var temp_list_of_co_authors_from_this_article = [];
				
		// figure out author stuff (for author table)
		try {
			if (typeof input_json.author === 'undefined') { // if crossref didn't find it, ignore it 
// 				console.log('no authors found ' + input_json.DOI);
			} else {
				for (a = 0; a < input_json.author.length; a++) {
					if (input_json.author[a].family !== undefined && input_json.author[a].family !== null) {
						temp_firstname = input_json.author[a].given.replaceAll('. ',' ').replaceAll('.',' ').trim();
						tempAuthor_full = input_json.author[a].family + ", " + temp_firstname;
					
						// keep track of how many times this author has appeared for the table of authors
						if (author_obj[tempAuthor_full] === undefined) {
							author_obj[tempAuthor_full] = new Author_object(input_json.author[a].family, temp_firstname);
						} else {
							author_obj[tempAuthor_full].citation_count++;
						}
						temp_list_of_co_authors_from_this_article.push(tempAuthor_full);
					}
				}

				connect_coauthors(temp_list_of_co_authors_from_this_article);
			}
		} catch(err) {
// 			console.log( 'error in parse_JSON_for_authors');
		}
	}

	function connect_coauthors(list_of_coauthors) {
		var i = 0;
		var j = 0;
		
		// if it's a single-author paper, don't do anything
		if (list_of_coauthors.length == 1) {
			return;
		}
		
// 		go through each pair of authors in the author list and connect each to the other (i.e., add them to each other's list of coauthors)
		for (i = 0; i < list_of_coauthors.length + 1; i++) {			
			for (j = i + 1; j < list_of_coauthors.length; j++) {
				if (author_obj[list_of_coauthors[i]].coauthors.includes(author_obj[list_of_coauthors[j]]) === false) { // if they aren't already connected
					author_obj[list_of_coauthors[i]].coauthors.push(author_obj[list_of_coauthors[j]]);
					author_obj[list_of_coauthors[j]].coauthors.push(author_obj[list_of_coauthors[i]]);
				}
			}
		}
	}
	
	function parse_user_input() {
		var inputText = document.getElementById("myText").value;
		// below, not taking out the ampersand causes errors. so I take it out even though it does change the input in a meaningful way. If you want to make things 100% perfect, leave it in the input but do not send it to the server.
		// also, I took out the question mark (it used to be /[&\\#$~%'"*?{}]/g) but that seems to work just fine.
		inputText = inputText.replace(/[&\\#$~%'"*{}]/g, ''); // remove illegal characters. 
		inputText = inputText.replaceAll("- ","-"); 
		
		var urlSuffix = inputText.split(/\r\n|\r|\n/g);
		var tempDOIArray = [];
		var tempDOItype = "";
        var tempDOI = '';
        var tempDOIsFoundSoFar = [];
        
		// get rid of rows with too few characters
		for (i = urlSuffix.length - 1; i >= 0; i--) { 
			urlSuffix[i] = urlSuffix[i].trim();
			if (urlSuffix[i].length < 5) {
				urlSuffix.splice(i, 1);
			}
		}
			
		for (i = 0; i < urlSuffix.length; i++) {
            tempDOIArray = [];
            tempDOIArray = urlSuffix[i].match(doi_pattern); // match returns an array, so this is just to get that array and help convert it to a string. 
            if (typeof tempDOIArray !== 'undefined' && tempDOIArray !== null && tempDOIArray.length > 0) { // if it found a doi
                var tempArraySplit = urlSuffix[i].split(tempDOIArray[0]);
                var a = tempArraySplit[0]+tempDOIArray[0];
                var b = tempArraySplit[1].trim();
                // if the string after the delimiter has something in it, split that stuff (everything after the 1st doi) into a different string
                if (b.length > 0) {
                    urlSuffix[i] = a; // change suffix to be equal to the first part
                    urlSuffix.splice(i+1, 0, b); // add an item to the suffix array that's got the second part in it. 
                }
                tempDOItype = "from_user";
                tempDOI = tempDOIArray[0];
            } else {
                tempDOItype = "not_found_yet";
                tempDOI = '';
            }
            
            if (tempDOIsFoundSoFar.includes(tempDOI)) { // if the doi has already been found in the user input
                console.log( 'duplicate doi found in user input. not added: ' + tempDOI);
            } else {
                if (typeof text_obj[urlSuffix[i]] != 'undefined' ) {
                    console.log( "**error: textobj already exists [skipping it]: "+urlSuffix[i])
					duplicate_input_text.push(urlSuffix[i]);
                    continue;
                    // dfd here's a known issue: If two rows are identical (and don't have a doi), there's a problem. 
                    // you can't make two text_obj because they'll have the same index and therefore be indistinuishable. 
                    // so only one gets added to the html table. basically, the second one (and beyond) kinda disappears. 
                    // And you won't see a problem in the output, necessarily, because the disappeared line doesn't get processed. 
                    // And btw, here's why I don't want to just disappear: it's possible that the same line appearing twice is correct. (by contrast, disappearing a duplicate doi is fine.) 
                }
                text_obj[urlSuffix[i]] = new Text_object(urlSuffix[i], tempDOI, tempDOItype, i); // if there's no doi, or the doi is new, use it. 
                if (tempDOI.length > 0) {
                    tempDOIsFoundSoFar.push(tempDOI);
                }
            }
        }
		build_article_table();
	}
	
	function build_article_table() {
		// Build article table
		var s = '';
		
		articleTableText = "<table id='article_table'>";
		articleTableText += '<tr><th style="width:40%">Input text</th>';
    	articleTableText += '<th style="width:40%">Article found</th>';
    	articleTableText += '<th style="width:20%">Notes</th></tr>';
    	
		for (let key in text_obj) { // this loops through all of text_obj
            s = text_obj[key].user_input;
            articleTableText += "<tr id='"+s+"'>";
            articleTableText += "<td id='inputText_"+ s +"'>"+ s +"</td>";
            articleTableText += "<td id='reference_" + s + "'></td>";
            articleTableText += "<td id='notes_" + s + "'></td>";
            articleTableText += "</tr>";
		}

		articleTableText += "</table>";
		
		document.getElementById('articleTable').innerHTML = articleTableText;

	}

	function first_letters(input_string) {
		var foof = "";
		
		for (i = 0; i < input_string.length; i++) {
			foof += input_string[i].slice(0,1)+". "; 
		}
		return foof.trim();
	}

	function authorCheckBoxPress(whichOne) {
		// this is called when a checkbox is pressed
		var i = 0;
		const nameString = whichOne.id;
		author_obj[nameString].checked = whichOne.checked; // set this author's status (i.e., checked or not) to the status of the checkbox
		
		// for this author and their coauthors, compute their status 
		computeStatus(nameString);
		for (i = 0; i < author_obj[nameString].coauthors.length; i++) {
			computeStatus(author_obj[nameString].coauthors[i].name);
		}
	}
	
	function computeStatus(nameString) {
		// this figures out whether an author should be highlighted (i.e., whether they or their coauthors are checked)
		var i = 0;
				
		if (author_obj[nameString].checked == true) {
			// if this author is checked, turn them red
			document.getElementById('name_' + nameString).style.color = 'red';
		} else {
			// if this author has a co-author that is checked, turn them red and return
			for (i = 0; i < author_obj[nameString].coauthors.length; i++) {
				if (author_obj[nameString].coauthors[i].checked) {
					document.getElementById('name_' + nameString).style.color = 'red';
					return;
				}
			}
			// otherwise, turn them black		
			document.getElementById('name_' + nameString).style.color = 'black';
		}
	}

	
    function build_author_table() {
		// Figure out the authors and build a table with all of them in it. This happens after all the articles are parsed.
// 		console.log( 'calling build author table')

		var i = 0;
		author_obj = [];

        // parse authors
        var rows_total = document.getElementById('article_table').rows.length - 1;
		for (i = 1; i <= rows_total; i++) { // start at 1 to skip header row
			try {
				temp_row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
				temp_DOI = text_obj[temp_row_text].doi;
				parse_JSON_for_authors(reference_obj[temp_DOI].json)
			} catch(err) {
// 				console.log( 'could not parse author: ' + temp_row_text)
			}
		}

		// build table
        var authorTableText = "";
        // create the html table 
        authorTableText = "<table><tr>";
        authorTableText += "<th onclick='sortTable(0, "+'"authorTable","checkboxes"'+")' title='Click to Sort'>Highlight</th>";
        authorTableText += "<th onclick='sortTable(1, "+'"authorTable","letters"'+")' title='Click to Sort'>Author</th>";
        authorTableText += "<th onclick='sortTable(2, "+'"authorTable","numbers"'+")' title='Click to Sort'>Citations</th>";
        authorTableText += "<th onclick='sortTable(3, "+'"authorTable","letters"'+")' title='Click to Sort'>Co-Authors</th>";
        authorTableText += "</tr>";

        for (var key in author_obj) {
            authorTableText += "<tr>";
            authorTableText += '<td><input type="checkbox" id="'+key+'" onclick="authorCheckBoxPress(this)"></td>';
            authorTableText += "<td><div id='name_" + author_obj[key].name + "'>" + author_obj[key].name + "</td>";
            authorTableText += "<td>" + author_obj[key].citation_count + "</td>";
            authorTableText +=  "<td>" + author_obj[key].all_coauthors_string();
            authorTableText += "</td></tr>";
        }

        authorTableText += "</table>"
        document.getElementById('authorTable').innerHTML = authorTableText;		
        sortTable(1, "authorTable", "letters");
    }
    
	function showBoxes() {
		var x = document.getElementById("refalyzerArticleListBox");
		x.style.display = "flex";
		x = document.getElementById("progressBox");
		x.style.display = "flex";
	}
	
	function start() {
		reference_obj = [];
		text_obj = [];
		duplicate_input_text = [];
		started_notFoundYet = false;
		current_mode = "searching for dois"
		startTime = Date.now();
		
		console.log( '')
		console.log( '---------start----------')


		document.getElementById("outputText").innerHTML = "";
        document.getElementById("myProgress").style = "display: flex;"
        document.getElementById("refalyzerAuthorsBox").style = "display: none;"

		showBoxes();
		
        if (document.getElementById('progressHeader').innerHTML != "Working... ") {
            document.getElementById('progressHeader').innerHTML = "Working... ";
            document.getElementById('progressText').innerHTML = '&nbsp;'; // this space is just so it looks good
		}

		parse_user_input();
		getAllUrls('from_user');
		update_progress();
	}

	function update_progress() {
// 	    console.log('current mode: ' + current_mode)
	
	    if (current_mode == "completely done") {
	        console.log( ' called up when completely done [returning]')
	        return; // is this ok?
	    }
	    
	    var row_text = '';
	    var rows_searched = 0;
	    var rows_combined = 0;
	    var rows_with_user_dois_total = 0;
	    
        var rows_total = document.getElementById('article_table').rows.length - 1;
        try {
            for (i = 1; i <= rows_total; i++) { // start at 1 to skip header row
                row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
                if (text_obj[row_text].search_status == "done") {
                    rows_searched++;
                }
                if (text_obj[row_text].doi_type == "from_user") {
                    rows_with_user_dois_total++;
                }
                if (text_obj[row_text].combine_status == "done" || text_obj[row_text].combine_status == 'cannot be combined') {
                    rows_combined++;
                }
            }
        } catch (err) {
            console.log('*error in update progress: '+row_text);
            console.log( err);
        }
		
		if (rows_combined >= rows_total && current_mode == "done combining") {
		    // it's already attempted to combine all rows
		    current_mode = "wrap up";
		    remove_duplicate_references();
			finish();
		} else if (rows_searched >= rows_total && current_mode == "searching for dois") {
		    // if done searching for all dois
			console.log( '-B- searched all--')
			check_table_for_combinations(); 
		} else if (rows_searched == rows_with_user_dois_total && started_notFoundYet == false  && current_mode == "searching for dois") {
		    // if it's done searching for user-entered dois
			console.log( '-B- searched dois--')
		    started_notFoundYet = true;
			remove_duplicate_rows();
			check_table_for_combinations();
            getAllUrls('not_found_yet');
        }
//         console.log( 'upd_prog: searched,combined,total= '+ rows_searched+', '+rows_combined+', '+rows_total)
        
        // update progress bar
        document.getElementById("myBar").style.width = 100*rows_searched/rows_total + "%";
	}
	
	function finish() {
        if (current_mode == 'completely done') {
            console.log( '*error called finish() when already completely done [returning]')
            return;
        }
        
        current_mode = 'completely done'
        
        var rows_total = document.getElementById('article_table').rows.length - 1;
		document.getElementById('progressHeader').innerHTML = 'Done ';
		document.getElementById('progressText').innerHTML = '&nbsp;' + rows_total + " rows (" +  Math.floor((Date.now() - startTime)/1000) + ' seconds)';
		document.getElementById("myProgress").style = "display: none;"
		
		build_author_table();
		document.getElementById("refalyzerAuthorsBox").style = "display: flex;"	
		
		console.log( '---------finish----------')
		console.log( '')
	}
</script>
</head>


<body>

	<!--  navigation menu -->
<!-- 
	<nav>
		<ul>
			<li><a href="index.html"><div class="navMenuItem"><img src="images/pm.png" > Masher Home</div></a></li>
			<li><a href="index_CombineAndClean.html"><div class="navMenuItem"><img src="images/cac.png"> Combine Datafiles</div></a></li>
			<li><a href="index_StatBuddy.html"><div class="navMenuItem"><img src="images/ptp.png"> StatBuddy</div></a></li>
			<li style="float:right"><a href="index_About.html"><div class="navMenuItem">About</div></a></li>
		</ul>
	</nav>
 -->

<textarea id="myText" name="inputTextArea" rows="20" cols="80">
Finn, B., & Metcalfe, J. (2008). Judgments of learning are influenced by memory for past test. Journal of Memory and Language, 58, 19–34. https://doi.org/10.1016/j.jml.2007.03.006

Frank, D. J., & Kuhlmann, B. G. (2017). More than just beliefs: Experience and beliefs jointly contribute to volume effects on metacognitive judgments. Journal of Experimental Psychology: Learning, Memory, and Cognition, 43, 680–693. https://doi.org/10.1037/xlm0000332
</textarea>


<p id="outputText"></p>

<p><button onclick="start()">run</button>
<!-- 
<button onclick="update_progress()">update_progress</button>
<button onclick="check_table_for_combinations()">check_table_for_combinations</button>
<button onclick="remove_duplicate_references()">remove_duplicate_references</button>
<button onclick="finish()">finish</button>
 -->



<div class='bigBox' id='progressBox' style="display: none;">
	<div class='boxAroundTable' style="min-width: 300px">
		<div class='heading' id='progressHeader'></div>
		<div id='progressText'>Working </div>
		<br>
        <div id="myProgress">
          <div id="myBar"></div>
        </div>
	</div>
</div>



<!-- 	Article table 	-->
<div class='bigBox' id='refalyzerArticleListBox' style="display: none">
	<div class='bigBox' display="block"> 
		<div class='boxAroundTable'>
			<div class='heading'>Articles</div><br>
			<p>
			<div id='articleTable' class='dataTable'></div>
		</div>
	</div>
</div>

<!-- 	Author table 	-->
<div class='bigBox' id='refalyzerAuthorsBox' style="display: none">
	<div class='bigBox' display="block"> 
		<div class='boxAroundTable'>
			<div class='heading'>Authors (click headings to sort)</p></div><br>
			<p>
			<div id='authorTable' class='dataTable'></div>
		</div>
	</div>
</div>


</body>
</html>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- -->


<!-- <script src="file_select.js"></script> -->
<!-- <script src="file_importExportContent.js"></script> -->
<!-- <script src="functions_fileOverlap.js"></script> -->
<script src="functions_stats.js"></script>
<script src="functions_tables.js"></script>


<p>Besken, M. (2016). Picture-perfect is not perfect for metamemory: Testing the perceptual fluency hypothesis with degraded images. Journal of Experimental Psychology: Learning, Memory, and Cognition, 42, 1417–1433. https://doi.org/10.1037/xlm0000246
<p>Besken, M., & Mulligan, N. W. (2013). Easily perceived, easily remembered? Perceptual interference produces a double dissociation between metamemory and memory performance. Memory & Cognition, 41, 897–903. https://doi.org/10.3758/s13421-013-0307-8
<p>Besken, M., & Mulligan, N. W. (2014). Perceptual fluency, auditory generation, and
metamemory: Analyzing the perceptual fluency hypothesis in the auditory modality. Journal of Experimental Psychology: Learning, Memory, and Cognition, 40, 429–440. https://doi.org/10.1037/a0034407

<p>Bröder, A., & Meiser, T. (2007). Measuring source memory. Zeitschrift für Psychologie/Journal of Psychology, 215, 52–60. https://doi.org/10.1027/0044- 3409.215.1.52
<p>Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL effect”. Memory, 26, 771–783. https://doi.org/10.1080/09658211.2017.1406523
<p>Carroll, M., Mazzoni, G., Andrews, S., & Pocock, P. (1999). Monitoring the future: Object and source memory for real and imagined events. Applied Cognitive Psychology, 13, 373–390. https://doi.org/10.1002/(SICI)1099-0720(199908)13:4<373::AID- ACP605>3.0.CO;2-F
<p>Dodson, C. S., Darragh, J., & Williams, A. (2008). Stereotypes and retrieval-provoked illusory source recollections. Journal of Experimental Psychology: Learning, Memory, and Cognition, 34, 460–477. https://doi.org/10.1037/0278-7393.34.3.460
<p>Dougherty, M. R., Scheck, P., Nelson, T. O., & Narens, L. (2005). Using the past to predict the future. Memory & Cognition, 33, 1096–1115. https://doi.org/10.3758/BF03193216
<p>Dunlosky, J., & Hertzog, C. (2000). Updating knowledge about encoding strategies: A componential analysis of learning about strategy effectiveness from task experience. Psychology and Aging, 15, 462–474. https://doi.org/10.1037//0882-7974.15.3.462
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 53
<p>Dunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20, 374–380. https://doi.org/10.3758/BF03210921
<p>Dunlosky, J., & Nelson, T. O. (1994). Does the sensitivity of judgements of learning (JOLs) to the effects of various study activities depend on when the JOLs occur? Journal of Memory and Language, 33, 545–565. https://doi.org/10.1006/jmla.1994.1026
<p>Dunlosky, J., & Nelson, T. O. (1997). Similarity between the cue for judgments of learning (JOL) and the cue for test is not the primary determinant of JOL accuracy. Journal of Memory and Language, 36, 34–49. https://doi.org/10.1006/jmla.1996.2476
<p>Ehrenberg, K., & Klauer, K. C. (2005). Flexible use of source information: Processing components of the inconsistency effect in person memory. Journal of Experimental Social Psychology, 41, 369–387. https://doi.org/10.1016/j.jesp.2004.08.001
<p>England, B. D., & Serra, M. J. (2012). The contributions of anchoring and past-test performance to the underconfidence-with-practice effect. Psychonomic Bulletin & Review, 19, 715–722. https://doi.org/10.3758/s13423-012-0237-7
<p>Erdfelder, E., Auer, T.-S., Hilbig, B. E., Aßfalg, A., Moshagen, M., & Nadarevic, L. (2009). Multinomial processing tree models: A review of the literature. Zeitschrift für Psychologie/Journal of Psychology, 217, 108–124. https://doi.org/10.1027/0044- 3409.217.3.108
<p>Erdfelder, E., & Bredenkamp, J. (1998). Recognition of script-typical versus script-atypical information: Effects of cognitive elaboration. Memory & Cognition, 26, 922–938. https://doi.org/10.3758/BF03201173
<p>Finley, J. R., Tullis, J. G., & Benjamin, A. S. (2010). Metacognitive control of learning and remembering. In M. S. Knine & I. M. Saleh (Eds.), New Science of Learning (pp. 109– 131). New York, NY: Springer. https://doi.org/10.1007/978-1-4419-5716-0_6
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 54
<p>Finn, B., & Metcalfe, J. (2007). The role of memory for past test in the underconfidence with practice effect. Journal of Experimental Psychology: Learning, Memory, and Cognition, 33, 238–244. https://doi.org/10.1037/0278-7393.33.1.238
<p>Finn, B., & Metcalfe, J. (2008). Judgments of learning are influenced by memory for past test. Journal of Memory and Language, 58, 19–34. https://doi.org/10.1016/j.jml.2007.03.006
<p>Frank, D. J., & Kuhlmann, B. G. (2017). More than just beliefs: Experience and beliefs jointly contribute to volume effects on metacognitive judgments. Journal of Experimental Psychology: Learning, Memory, and Cognition, 43, 680–693. https://doi.org/10.1037/xlm0000332
<p>Friedman, A. (1979). Framing pictures: The role of knowledge in automatized encoding and memory for gist. Journal of Experimental Psychology: General, 108, 316–355. https://doi.org/10.1037/0096-3445.108.3.316
<p>Gelman, A., & Rubin, D. B. (1992). Inference from iterative simulation using multiple sequences. Statistical Science, 7, 457–472. http://dx.doi.org/10.1214/ss/1177011136
<p>Gronau, Q. F., Heck, D. W., Berkhout, S. W., Haaf, J. M., & Wagenmakers, E. (2020, April 24). A Primer on Bayesian Model-Averaged Meta-Analysis. https://doi.org/10.31234/osf.io/97qup
<p>Gronau, Q. F., Van Erp, S., Heck, D. W., Cesario, J., Jonas, K. J., & Wagenmakers, E. J. (2017). A Bayesian model-averaged meta-analysis of the power pose effect with informed and default priors: The case of felt power. Comprehensive Results in Social Psychology, 2, 123–138. https://doi.org/10.1080/23743603.2017.1326760
<p>Hechler, S., Neyer, F. J., & Kessler, T. (2016). The infamous among us: Enhanced reputational memory for uncooperative ingroup members. Cognition, 157, 1–13. https://doi.org/10.1016/j.cognition.2016.08.001
<p>Heck, D. W., Arnold, N. R., & Arnold, D. (2018). TreeBUGS: An R package for hierarchical multinomial-processing-tree modeling. Behavior Research Methods, 50, 264–284.
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 55
<p>https://doi.org/ 10.3758/s13428-017-0869-7
<p>Heck, D. W., Gronau, F. Q., & Wagenmakers &, E.-J. (2019). metaBMA: Bayesian Model
<p>Averaging for Random and Fixed Effects Meta-Analysis. https://CRAN.R-
<p>project.org/package=metaBMA.
<p>Henkel, L. A., Johnson, M. K., & De Leonardis, D. M. (1998). Aging and source monitoring:
<p>Cognitive processes and neuropsychological correlates. Journal of Experimental
<p>Psychology: General, 127, 251–268. https://doi.org/10.1037/0096-3445.127.3.251 Hicks, J. L., & Cockman, D. W. (2003). The effect of general knowledge on source memory
<p>and decision processes. Journal of Memory and Language, 48, 489–501.
<p>https://doi.org/10.1016/S0749-596X(02)00537-5
<p>Johnson, M. K., Hashtroudi, S., & Lindsay, D. S. (1993). Source monitoring. Psychological
<p>Bulletin, 114, 3–28. https://doi.org/10.1037/0033-2909.114.1.3
<p>Johnson, M. K., Kounios, J., & Reeder, J. A. (1994). Time-course studies of reality
<p>monitoring and recognition. Journal of Experimental Psychology: Learning, Memory,
<p>and Cognition, 20, 1409–1419. https://doi.org/10.1037/0278-7393.20.6.1409
<p>Kelemen, W. L. (2000). Metamemory cues and monitoring accuracy: Judging what you know
<p>and what you will know. Journal of Educational Psychology, 92, 800–810.
<p>https://doi.org/10.1037/0022-0663.92.4.800
<p>Kelemen, W. L., & Weaver, C. A. III (1997). Enhanced memory at delays: Why do judgments
<p>of learning improve over time? Journal of Experimental Psychology: Learning, Memory,
<p>and Cognition, 23(6), 1394–1409. https://doi.org/10.1037/0278-7393.23.6.1394 Kelley, C. M., & Jacoby, L. L. (1996). Adult egocentrism: Subjective experience versus
<p>analytic bases for judgment. Journal of Memory and Language, 35, 157–175.
<p>https://doi.org/10.1006/jmla.1996.0009
<p>Kenny, D. A., Korchmaros, J. D., & Bolger, N. (2003). Lower level mediation in multilevel
<p>models. Psychological Methods, 8, 115–128. https://doi.org/10.1037/1082-989X.8.2.115

<p>
DELAYED JUDGMENTS IN SOURCE MONITORING 56
<p>Kimball, D. R., & Metcalfe, J. (2003). Delaying judgments of learning affects memory, not metamemory. Memory & Cognition, 31, 918–929. https://doi.org/10.3758/BF03196445
<p>Kimball, D. R., Smith, T. A., & Muntean, W. J. (2012). Does delaying judgments of learning really improve the efficacy of study decisions? Not so much. Journal of Experimental Psychology: Learning, Memory, and Cognition, 38, 923–954. https://doi.org/10.1037/a0026936
<p>King, J. F., Zechmeister, E. B., & Shaughnessy, J. J. (1980). Judgments of knowing: The influence of retrieval practice. The American Journal of Psychology, 329–343. https://doi.org/10.2307/1422236
<p>Klauer, K. C. (2010). Hierarchical multinomial processing tree models: A latent-trait approach. Psychometrika, 75, 70–98. doi: 10.1007/S11336-009-9141-0
<p>Konopka, A. E., & Benjamin, A. S. (2009). Schematic knowledge changes what judgments of learning predict in a source memory task. Memory & Cognition, 37, 42–51. https://doi.org/10.3758/MC.37.1.42
<p>Koriat, A. (1997). Monitoring one’s own knowledge during study: A cue-utilization approach to judgments of learning. Journal of Experimental Psychology: General, 126, 349–370. https://doi.org/10.1037/0096-3445.126.4.349
<p>Koriat, A., & Bjork, R. A. (2006a). Illusions of competence during study can be remedied by manipulations that enhance learners’ sensitivity to retrieval conditions at test. Memory & Cognition, 34, 959–972. https://doi.org/10.3758/BF03193244
<p>Koriat, A., & Bjork, R. A. (2006b). Mending metacognitive illusions: A comparison of mnemonic-based and theory-based procedures. Journal of Experimental Psychology: Learning, Memory, and Cognition, 32, 1133–1145. https://doi.org/10.1037/0278- 7393.32.5.1133
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 57
<p>Koriat, A., & Ma’ayan, H. (2005). The effects of encoding fluency and retrieval fluency on judgments of learning. Journal of memory and Language, 52, 478–492. https://doi.org/10.1016/j.jml.2005.01.001
<p>Kornell, N., & Bjork, R. A. (2008). Optimising self-regulated study: The benefits—and costs—of dropping flashcards. Memory, 16, 125–136. https://doi.org/10.1080/09658210701763899
<p>Kranz, D., Nadarevic, L., & Erdfelder, E. (2019). Bald and bad? Experimental evidence for a dual-process account of baldness stereotyping. Experimental Psychology, 66, 331– 345. https://doi.org/10.1027/1618-3169/a000457
<p>Kroneisen, M., & Bell, R. (2013). Sex, cheating, and disgust: Enhanced source memory for trait information that violates gender stereotypes. Memory, 21, 167–181. https://doi.org/10.1080/09658211.2012.713971
<p>Kroneisen, M., Woehe, L., & Rausch, L. S. (2015). Expectancy effects in source memory: How moving to a bad neighborhood can change your memory. Psychonomic Bulletin & Review, 22, 179–189. https://doi.org/10.3758/s13423-014-0655-9
<p>Krull, J. L., & Mackinnon, D. P. (2001). Multilevel modeling of individual and group level mediated effects. Multivariate Behavioral Research, 36, 249–277. https://doi.org/10.1207/S15327906MBR3602
<p>Kuhlmann, B. G., & Bayen, U. J. (2016). Metacognitive aspects of source monitoring. In J. Dunlosky & S. U. Tauber (Eds.), The Oxford Handbook of Metamemory (pp. 149–168). New York, NY: Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199336746.013.8
<p>Kuhlmann, B. G., & Touron, D. R. (2011). Older adults’ use of metacognitive knowledge in source monitoring: Spared monitoring but impaired control. Psychology and Aging, 26, 143–149. https://doi.org/ 10.1037/a0021055
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 58
<p>Kuhlmann, B. G., Vaterrodt, B., & Bayen, U. J. (2012). Schema bias in source monitoring varies with encoding conditions: Support for a probability-matching account. Journal of Experimental Psychology: Learning, Memory, and Cognition, 38, 1365–1376. https://doi.org/10.1037/a0028147
<p>Küppers, V., & Bayen, U. J. (2014). Inconsistency effects in source memory and compensatory schema-consistent guessing. The Quarterly Journal of Experimental Psychology, 67, 2042–2059. https://doi.org/10.1080/17470218.2014.904914
<p>Kuznetsova, A., Brockhoff, P. B., & Christensen, R. H. B. (2014). lmerTest: Tests for random and fixed effects for linear mixed effect models (lmer objects of lme4 package) (R package version 2.0-6) [Software]. Retrieved from http://cran.r- project.org/package=lmerTest
<p>Loftus, G. R., & Mackworth, N. H. (1978). Cognitive determinants of fixation location during picture viewing. Journal of Experimental Psychology: Human Perception and Performance, 4, 565–572. https://doi.org/10.1037/0096-1523.4.4.565
<p>Loftus, G. R., & Masson, M. E. J. (1994). Using confidence intervals in within-subject designs. Psychonomic Bulletin & Review, 1, 476–490. https://doi.org/10.3758/BF03210951
<p>Luna, K., Martín-Luengo, B., & Albuquerque, P. B. (2018). Do delayed judgements of learning reduce metamemory illusions? A meta-analysis. Quarterly Journal of Experimental Psychology, 71(7), 1626-1636. https://doi.org/10.1080/17470218.2017.1343362
<p>Marsh, R., Cook, G., & Hicks, J. L. (2006). Gender and orientation stereotypes bias source- monitoring attributions. Memory, 14, 148–160. https://doi.org/10.1080/09658210544000015
<p>Mather, M., Johnson, M. K., & De Leonardis, D. M. (1999). Stereotype reliance in source monitoring: Age differences and neuropsychological test correlates. Cognitive
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 59
<p>Neuropsychology, 16, 437–458. https://doi.org/10.1080/026432999380870
<p>Meeter, M., & Nelson, T. O. (2003). Multiple study trials and judgments of learning. Acta
<p>Psychologica, 113, 123–132. https://doi.org/10.1016/S0001-6918(03)00023-4 Meiser, T., & Hewstone, M. (2001). Crossed categorization effects on the formation of
<p>illusory correlations. European Journal of Social Psychology, 31, 443–466.
<p>https://doi.org/10.1002/ejsp.55
<p>Meiser, T., Sattler, C., & Von Hecker, U. (2007). Metacognitive inferences in source memory
<p>judgements: The role of perceived differences in item recognition. Quarterly Journal of
<p>Experimental Psychology, 60, 1015–1040. https://doi.org/10.1080/17470210600875215 Metcalfe, J. (2009). Metacognitive judgments and control of study. Current Directions in
<p>Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x Metcalfe, J., & Finn, B. (2008). Evidence that judgments of learning are causally related to
<p>study choice. Psychonomic Bulletin & Review, 15, 174–179.
<p>https://doi.org/10.3758/PBR.15.1.174
<p>Mieth, L., Bell, R., & Buchner, A. (2016). Facial likability and smiling enhance cooperation,
<p>but have no direct effect on moralistic punishment. Experimental Psychology, 63, 263–
<p>277. http://dx.doi.org/10.1027/1618-3169/a000338
<p>Mieth, L., Schaper, M. L., Kuhlmann, B. G., & Bell, R. (2020). Memory and metamemory for
<p>social interactions: Evidence for a metamemory expectancy illusion. Memory &
<p>Cognition, 49, 14–31. https://doi.org/10.3758/s13421-020-01071-z
<p>Misirlisoy, M., Tanyas, H., & Atalay, N. B. (2019). Does survival context enhance memory
<p>for source? A within-subjects comparison. Memory, 27, 780–791.
<p>https://doi.org/10.1080/09658211.2019.1566928
<p>Mitchum, A. L., Kelley, C. M., & Fox, M. C. (2016). When asking the question changes the
<p>ultimate answer: Metamemory judgments change memory. Journal of Experimental Psychology: General, 145, 200–219. http://doi.org/10.1037/a0039923
<p>
<p>Mueller, M. L., & Dunlosky, J. (2017). How beliefs can impact judgments of learning: Evaluating analytic processing theory with beliefs about fluency. Journal of Memory and Language, 93, 245–258. https://doi.org/10.1016/j.jml.2016.10.008
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 60
<p>Mueller, M. L., Dunlosky, J., & Tauber, S. K. (2016). The effect of identical word pairs on people’s metamemory judgments: What are the contributions of processing fluency and beliefs about memory? The Quarterly Journal of Experimental Psychology, 69, 781–799. https://doi.org/10.1080/17470218.2015.1058404
<p>Mueller, M. L., Dunlosky, J., Tauber, S. K., & Rhodes, M. G. (2014). The font-size effect on judgments of learning: Does it exemplify fluency effects or reflect people’s beliefs about memory? Journal of Memory and Language, 70, 1–12. https://doi.org/10.1016/j.jml.2013.09.007
<p>Mueller, M. L., Tauber, S. K., & Dunlosky, J. (2013). Contributions of beliefs and processing fluency to the effect of relatedness on judgments of learning. Psychonomic Bulletin & Review, 20, 378–384. https://doi.org/10.3758/s13423-012-0343-6
<p>Murnane, K., & Bayen, U. J. (1996). An evaluation of empirical measures of source identification. Memory and Cognition, 24, 417–428. https://doi.org/10.3758/BF03200931
<p>Murnane, K., & Bayen, U. J. (1998). Measuring memory for source: Some theoretical assumptions and technical limitations. Memory & Cognition, 26, 674–677. https://doi.org/10.3758/BF03211387
<p>Nelson, T. O., & Dunlosky, J. (1991). When people's judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: The “delayed-JOL effect”. Psychological Science, 2, 267–271. https://doi.org/10.1111/j.1467-9280.1991.tb00147.x
<p>Nelson, T. O., Dunlosky, J., Graf, A., & Narens, L. (1994). Utilization of metacognitive judgments in the allocation of study during multitrial learning. Psychological Science, 5, 207–213. https://doi.org/10.1111/j.1467-9280.1994.tb00502.x
<p>Nelson, T. O., & Narens, L. (1990). Metamemory: A theoretical framework and new findings.
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 61
<p>In G. H. Bower (Ed.), The Psychology of Learning and Motivation (Vol. 26, pp. 125–
<p>141). San Diego, CA: Academic Press. https://doi.org/10.1016/S0079-7421(08)60053-5 Nelson, T. O., & Narens, L. (1994). Why investigate metacognition. In J. Metcalfe & A. P.
<p>Shimamura (Eds.), Metacognition: Knowing about Knowing (pp. 1-25). Cambridge, MA:
<p>MIT Press.
<p>Nelson, T. O., Narens, L., & Dunlosky, J. (2004). A revised methodology for research on
<p>metamemory: Pre-judgment recall and monitoring (PRAM). Psychological methods, 9,
<p>53–69. https://doi.org/10.1037/1082-989X.9.1.53
<p>Nieznański, M. (2014a). Context reinstatement and memory for intrinsic versus extrinsic
<p>context: The role of item generation at encoding or retrieval. Scandinavian Journal of
<p>Psychology, 55, 409–419. https://doi.org/10.1111/sjop.12153
<p>Nieznański, M. (2014b). The role of reinstating generation operations in recognition memory
<p>and reality monitoring. Polish Psychological Bulletin, 45, 363–371. https://doi.org/10.2478/ppb-2014-0044
<p> Pyc, M. A., Rawson, K. A., & Aschenbrenner, A. J. (2014). Metacognitive monitoring during criterion learning: When and why are judgments accurate? Memory & Cognition, 42(6), 886–897. https://doi.org/10.3758/s13421-014-0403-4
<p>Raftery, A. E. (1995). Bayesian model selection in social research. Sociological Methodology, 25, 111–163. https://doi.org/10.2307/271063
<p>R Core Team (2020). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.
<p>Rhodes, M. G. (2016). Judgments of learning: Methods, data, and theory. In J. Dunlosky & S. U. Tauber (Eds.), The Oxford Handbook of Metamemory (pp. 65–80). New York, NY: Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199336746.013.4
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 62
<p>Rhodes, M. G., & Tauber, S. K. (2011). The influence of delaying judgments of learning on metacognitive accuracy: A meta-analytic review. Psychological Bulletin, 137(1), 131– 148. https://doi.org/10.1037/a0021705
<p>Robey, A. M., Dougherty, M. R., & Buttaccio, D. R. (2017). Making retrospective confidence judgments improves learners’ ability to decide what not to study. Psychological Science, 28, 1683–1893. https://doi.org/10.1177/0956797617718800
<p>Schaper, M. L., & Bayen, U. J. (2021). The metamemory expectancy illusion in source monitoring affects metamemory control and memory. Cognition, 206, 104468. https://doi.org/10.1016/j.cognition.2020.104468
<p>Schaper, M. L., Kuhlmann, B. G., & Bayen, U. J. (2019a). Metamemory expectancy illusion and schema-consistent guessing in source monitoring. Journal of Experimental Psychology: Learning, Memory, and Cognition. 45, 470-496. https://doi.org/10.1037/xlm0000602
<p>Schaper, M. L., Kuhlmann, B. G., & Bayen, U. J. (2019b). Metacognitive expectancy effects in source monitoring: Beliefs, in-the-moment experiences, or both? Journal of Memory and Language, 107, 95-110. https://doi.org/10.1016/j.jml.2019.03.009
<p>Serra, M. J., & Ariel, R. (2014). People use the memory for past-test heuristic as an explicit cue for judgments of learning. Memory & Cognition, 42, 1260–1272. https://doi.org/10.3758/s13421-014-0431-0
<p>Sherman, J. W., & Bessenoff, G. R. (1999). Stereotypes as source-monitoring cues: On the interaction between episodic and semantic memory. Psychological Science, 10, 106–110. https://doi.org/10.1111/1467-9280.00116
<p>Sherman, J. W., Lee, A. Y., Bessenoff, G. R., & Frost, L. A. (1998). Stereotype efficiency reconsidered: Encoding flexibility under cognitive load. Journal of Personality and Social Psychology, 75, 589–606. https://doi.org/0.1037/0022-3514.75.3.589
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 63
<p>Shi, L.-Z., Tang, W.-H., & Liu, X.-P. (2012). Age-related schema reliance of judgments of learning in predicting source memory. Aging, Neuropsychology, and Cognition, 19, 301– 318. https://doi.org/10.1080/13825585.2011.632616
<p>Smith, J. B., & Batchelder, W. H. (2010). Beta-MPT: Multinomial processing tree models for addressing individual differences. Journal of Mathematical Psychology, 54, 167–183. https://doi.org/10.1016/j.jmp.2009.06.007
<p>Soderstrom, N. C., Clark, C. T., Halamish, V., & Bjork, E. L. (2015). Judgments of learning as memory modifiers. Journal of Experimental Psychology: Learning, Memory, and Cognition, 41, 553–558. https://doi.org/10.1037/a0038388
<p>Spaniol, J., & Bayen, U. J. (2002). When is schematic knowledge used in source monitoring? Journal of Experimental Psychology: Learning, Memory, and Cognition, 28, 631–651. https://doi.org/10.1037/0278-7393.28.4.631
<p>Starns, J. J., & Hicks, J. L. (2013). Internal reinstatement hides cuing effects in source memory tasks. Memory & Cognition, 41, 953–966. https://doi.org/10.3758/s13421-013- 0325-6
<p>Susser, J. A., Mulligan, N. W., & Besken, M. (2013). The effects of list composition and perceptual fluency on judgments of learning (JOLs). Memory & Cognition, 41, 1000– 1011. https://doi.org/10.3758/s13421-013-0323-8
<p>Tauber, S. K., & Rhodes, M. G. (2012). Multiple bases for young and older adults' judgments of learning in multitrial learning. Psychology and Aging, 27, 474–-483. https://doi.org/10.1037/a0025246
<p>Thiede, K. W., Anderson, M., & Therriault, D. (2003). Accuracy of metacognitive monitoring affects learning of texts. Journal of Educational Psychology, 95, 66–73. https://doi.org/10.1037/0022-0663.95.1.66
<p>Tullis, J. G., & Benjamin, A. S. (2011). On the effectiveness of self-paced learning. Journal of Memory and Language, 64, 109–118. https://doi.org/10.1016/j.jml.2010.11.002
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 64
<p>Tullis, J. G., Finley, J. R., & Benjamin, A. S. (2013). Metacognition of the testing effect: Guiding learners to predict the benefits of retrieval. Memory & Cognition, 41, 429–442. https://doi.org/10.3758/s13421-012-0274-5
<p>Undorf, M., & Erdfelder, E. (2011). Judgments of learning reflect encoding fluency: Conclusive evidence for the ease-of-processing hypothesis. Journal of Experimental Psychology: Learning, Memory, and Cognition, 37, 1264–1269. https://doi.org/10.1037/a0023719
<p>Undorf, M., & Erdfelder, E. (2013). Separation of encoding fluency and item difficulty effects on judgements of learning. Quarterly Journal of Experimental Psychology, 66, 2060– 2072. https://doi.org/10.1080/17470218.2013.777751
<p>Undorf, M., & Erdfelder, E. (2015). The relatedness effect on judgments of learning: A closer look at the contribution of processing fluency. Memory & Cognition, 43, 647–658. https://doi.org/10.3758/s13421-014-0479-x
<p>Van Overschelde, J. P., & Nelson, T. O. (2006). Delayed judgments of learning cause both a decrease in absolute accuracy (calibration) and an increase in relative accuracy (resolution). Memory & cognition, 34, 1527–1538. https://doi.org/10.3758/BF03195916
<p>Vesonder, G. T., & Voss, J. F. (1985). On the ability to predict one's own responses while learning. Journal of Memory and Language, 24, 363–376. https://doi.org/10.1016/0749- 596X(85)90034-8
<p>Weaver, C. A. III, & Kelemen, W. L. (1997). Judgments of learning at delays: Shifts in response patterns or increased metamemory accuracy? Psychological Science, 8, 318– 321. https://doi.org/10.1111/j.1467-9280.1997.tb00445.x
<p>Wulff, L., & Kuhlmann, B. G. (2020). Is knowledge reliance in source guessing a cognitive trait? Examining stability across time and domain. Memory & Cognition, 48, 256–276. https://doi.org/10.3758/s13421-019-01008-1
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 65
<p>Yan, V. X., Bjork, E. L., & Bjork, R. A. (2016). On the difficulty of mending metacognitive illusions: A priori theories, fluency effects, and misattributions of the interleaving benefit. Journal of Experimental Psychology: General, 145, 918–933. https://doi.org/10.1037/xge0000177
<p>Yang, C., Potts, R., & Shanks, D. R. (2017). Metacognitive unawareness of the errorful generation benefit and its effects on self-regulated learning. Journal of Experimental Psychology: Learning, Memory, and Cognition, 43, 1073–1092. https://doi.org/10.1037/xlm0000363
<p>Zechmeister, E. B., & Shaughnessy, J. J. (1980). When you know that you know and when you think that you know but you don’t. Bulletin of the Psychonomic Society, 15, 41–44. https://doi.org/10.3758/BF03329756
<p>Zhang, Y., Pan, Z., Li, K., & Guo, Y. (2018). Self-serving bias in memories: Selectively forgetting the connection between negative information and the self. Experimental Psychology, 65, 236–244. http://dx.doi.org/10.1027/1618-3169/a000409

