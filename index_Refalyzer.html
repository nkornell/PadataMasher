<!-- 
To do: 

- When it gets a non-doi reference, maybe have it look at the first 2 or 3 that are returned, and see if they have a matching year, author, etc? 

- when it gts a reference json (for any reference), have it return notes about what it got wrong or is missing
-   Like, if there are no authors, year, or title, flag it. Regardless of format. 
-   And if it's a known format (journal article), if there are no page numbers, for example, in the JSON. 
-   This means figuring out the elements (e.g., date) for both the json and the input. 
- 
-   And maybe even fix the errors?? like if eds are missing, use the user input to insert them?
-   do this by having it return an object, and have the object include, like, .apa (so the user could type something like, returnthing(x).apa)

- look at strings more
-       by the way, at some point worry about line numbers. like, find them and remove them.
-       I could try to characterize the typical last character of rows. Like, is it usually a number? usually a period? and then if something deviates, 
-           maybe it's not the last character? 

- this returns a crazy reference that's way too long. It returns fragment but it should probably return wrong. So maybe part of the right/wrong score should be
- based on total length? (Is it already?)
- Learning and Motivation: Advances in Research and Theory, vol. 54, ed. BH Ross, pp. 103–40. San Diego, CA: Elsevier

- this returns wrong. what it means is, the user was wrong. in other words, the user had stuff that needed to be deleted. 
-   that's different than thinking the answer it's giving is wrong. 
- make the program differentiate between 'my answer is wrong' and 'your input was wrong'
	Besken, M. (2016). Picture-perfect is not perfect for metamemory: Testing the perceptual fluency hypothesis with degraded images. Journal of Experimental Psychology: Learning, Memory, and Cognition, 42, 1417–1433. go to the store and buy a carpet, buy a floor https://doi.org/10.1037/xlm0000246

- Add google analytics tags so i can see if it gets used. 

- It would speed things up to not wait for all of the lines to come in before trying to combine. Maybe if an obj is correct it should try to combine right away?


- With two non-user-doi rows, it's possible that neither doi it finds is right. In this case, maybe it could find the right doi if they were combined and then sent
- to the server, but as of now the program doesn't check the database for the combo. 

- Just looking at the output, it seems like maybe some of the ones marked wrong are actually right. Should they be marked probable instead? 

-->


<!-- author stuff-->
<!--
Find second-order authors
- if possible, maybe find all co-authors by checking the database. (i.e.,, is there a way to ask for coauthors using crossref? or maybe orcid or something? 
- this tells you the papers cited by this paper. Looking at them would make it easy to get second-order citation information although that would be a lot of doi calls 
    this could be useful in two ways. first, to figure out co-authors if 2 fails. Second, to figure out who's getting cited in this area of research. 


Author table
- Look for cases where it's the same author but the name is different (e.g., Bjork, E. L. and Bjork, 
Elizabeth Ligon). Combine them. Also, check if they're the same when ignoring case

-->


<!-- stuff to test-->
<!--
This makes it decide the other doi will be better, and therefore return, during decide to combine

metacognitive judgments. Journal of 
Experimental Psychology: Learning, frank
Memory, and Cognition, 43, 680–693. 


-->

<!-- 
Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning 

(JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL 

effect”. Memory, 26, 771–783. 

https://doi.org/10.3758/s13421-013-0307-8

Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL 
 -->
 
<!-- 
Hicks, J. L., & Cockman, D. W. (2003). The effect of general knowledge on source memory

and decision processes. Journal of Memory and Language, 48, 489–501.

https://doi.org/10.1016/S0749-596X(02)00537-5

Johnson, M. K., Hashtroudi, S., & Lindsay, D. S. (1993). Source monitoring. Psychological

Bulletin, 114, 3–28. https://doi.org/10.1037/0033-2909.114.1.3


Dunlosky, J., & Nelson, T. O. (1997). Similarity between the cue for judgments of 

learning (JOL) and the cue for test is not the primary determinant of JOL 

accuracy. Journal of Memory and Language, 36, 34–49. 
 -->


<!-- 
Heck, D. W., Gronau, F. Q., & Wagenmakers &, E.-J. (2019). metaBMA: Bayesian Model

Averaging for Random and Fixed Effects Meta-Analysis. https://CRAN.R-project.org/package=metaBMA.

Henkel, L. A., Johnson, M. K., & De Leonardis, D. M. (1998). Aging and source monitoring:

Cognitive processes and neuropsychological correlates. Journal of Experimental

Psychology: General, 127, 251–268. https://doi.org/10.1037/0096-3445.127.3.251 Hicks, J. L., & Cockman, D. W. (2003). The effect of general knowledge on source memory

and decision processes. Journal of Memory and Language, 48, 489–501.

https://doi.org/10.1016/S0749-596X(02)00537-5
 -->

<!--
~~
this causes ABCABC to get messed up. I think basically, if there's only dois plus duplicates, it's a problem. 

Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL effect”. Memory, 26, 771–783. https://doi.org/10.1080/09658211.2017.1406523

DELAYED JUDGMENTS IN SOURCE MONITORING 53


DELAYED JUDGMENTS IN SOURCE MONITORING 54
~~~

When you do this one of the lines ('remembered?...') gets deleted from user input
Besken, M., & Mulligan, N. W. (2013). Easily perceived, easily 
remembered? Perceptual interference produces a double dissociation 
between metamemory and memory performance. Memory & Cognition, 41, 
897–903. 

~~~

test this and see if it still causes an error. having the same reference appear twice (with or without doi) causes a breakdown where some references aren't found at all

Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect.

Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x 

Meiser, T., Sattler, C., & Von Hecker, U. (2007). Metacognitive inferences in source memory

judgements: The role of perceived differences in item recognition. Quarterly Journal of

Experimental Psychology, 60, 1015–1040. https://doi.org/10.1080/17470210600875215 Metcalfe, J. (2009). Metacognitive judgments and control of study. Current Directions in

Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x 

~~~
if there are duplicate lines but they're good, it gets rid of both. maybe it should keep one. to do this, I could
have it run the duplicate line array through the database and see if anything good comes out

aDunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20(4), 374–380.
aklsdkjf
bDunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20(4), 374–380.
~~~

 -->

<!--
Basic procedure:
// Step 1: take care of all of the user-input DOIs. Then try to combine.
// Step 2: search crossref for DOIs. Once they're all returned, try to combine.
-->

<!DOCTYPE html>
<html lang="en">

<head>
	<title>Citation Fixer</title>
	<meta charset="utf-8" />
	<meta name="description" content="format citations">
	<meta name="keywords" content="program">
	<meta name="author" content="Nate Kornell">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="stylesheet" type="text/css" href="mystyle.css">

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/citation-js"></script>
	
	<script src="functions_stats.js"></script>
    <script src="functions_tables.js"></script>
    <script src="functions_stringdiff.js"></script> <!-- this is to use a script that I copied into my folder, for highlighting differences between strings -->



<script>
	var author_obj = [];
	var reference_obj = [];
	var text_obj = []
	var duplicate_input_text = [];
	var articleTableText = "";
	var startTime = 0;
	var started_notFoundYet = false;
	var doi_pattern = /10.\d{4,9}\/[-._;()/:A-Z0-9<>]+/gi; // doi_pattern is used to find a DOI within the input string. note: I added in the g, which makes it return all of the DOIs instead of just 1
    const cc = [];
    cc['fragment'] = 'blue';
    cc['wrong'] = 'red';
    var good_match_threshold = 80;
    var current_mode = '';
    let dmp = new diff_match_patch();
	let Cite = require('citation-js');
	
	
    function extract_url(input) {
        // return an array consisting of each valid url in the string. 
        // if none are found it returns null
        
        try {
            var urlRegex = /(https?:\/\/[^\s]+)/g; // finds urls
            var urlArray = input.match(urlRegex)
            if (urlArray == null) {
                return '';
            } else {
                var url_to_use = urlArray[0] // just use the first url and ignore the others (if there's more than one)
                if (isValidHttpUrl(url_to_use) == false) {
                    return '';
                } else {
                    return url_to_use;
                }
            }
        } catch(err) {
            console.log( 'error in extract url ' + err)
            return ''
        }
    }

    function isValidHttpUrl(string) {
        // this tells you whether the url is well formed
        // it doesn't check whether it actually points to something 
        let url;
        try {
            url = new URL(string);
        } catch (_) {
            return false;
        }
        return url.protocol === "http:" || url.protocol === "https:";
    }
    
	function first_letters(input_string) {
		var foof = "";
		
		for (i = 0; i < input_string.length; i++) {
			foof += input_string[i].slice(0,1)+". "; 
		}
		return foof.trim();
	}

	function str_count(search, text) {
		// return the number of occurrences of search in text
		return text.split(search).length - 1
	}

	function fix_author_string(input) {
	
		var i = 0;
		
		// A list of strings to get rid of. \b = break between words (so the bs make it only replace whole words).
		var pattern = []
		pattern.push ( new RegExp(/\bcreated by\b/i) )
		pattern.push ( new RegExp(/\bwritten by\b/i) )
		pattern.push ( new RegExp(/\bwords by\b/i) )
		pattern.push ( new RegExp(/\bby\b/i) )
		pattern.push ( new RegExp(/\byour name\b/i) )
		
		// Remove the strings
		var output = input;
// 		console.log( output)
		for (i = 0; i < pattern.length; i++) {
			output = output.replace(pattern[i],'')
		}
		
		const pattern_non_letters = new RegExp(/[+_=!@#$%^&*()\{}\[\]\/|:;'"><~`.,?0-9]/g); // most of the non-letters
// 		console.log( output)
// 		console.log( output.match(pattern_non_letters))
		if (output.match(pattern_non_letters) != null) {
		    console.warn("Author name contains weird characters: " + output)
		}
		
		output = output.trim()
		if (output != input) {
			console.log('fix author string, output changed to: ' + output)		
		}
		
		return output;
	}

    function author_in_apa_format(input) {
    	// fixes funky characters (namely ( and ,) 
    	// rearranges them so it's first, last
    	// turns stuff into initials

    	// find unexpected characters
    	if (str_count('(', input) > 0 && str_count(')', input) > 0) {
			input = input.replace(/ *\([^)]*\) */g, ""); // remove anything inside parentheses
    	}

        if (str_count(',', input) == 1) {
            var temp = input.split(',')
            input = temp[1].trim() + ' ' + temp[0].trim()
        }
        
        if (input.length == 0 || str_count(" ", input) == 0) {
            // if there are no spaces, or it's blank, return it
            return input;
        }
        
        var names = input.split(" ")
        var lastname = names.pop();
        var firstname = input.substring(0, input.lastIndexOf(" "));
        firstname = firstname.replaceAll('. ',' ').replaceAll('.',' ').trim();
        var firstName_array = firstname.replaceAll('. ',' ').replaceAll('.',' ').trim().split(" "); //array of first names with the periods replaced by spaces (which is only necessary for things like "T.O." as a first name)
        return lastname + ", " + first_letters(firstName_array);
    }
	
	function get_apa_from_json_URL(input_json) {
		// apa rules    from https://www.scribbr.com/apa-examples/website/#:~:text=APA%20website%20citations%20usually%20include,time%2C%20add%20a%20retrieval%20date.
		// if there is an author
		// Last name, Initials. (Year, Month Day). Article title. Publication Name. URL
		// if there is no author but there is an organization
		// Organization Name. (Year, Month Day). Page title. Site Name. URL
		// if there is no author or organization
		// Page title. (Year, Month Day). Site Name. URL
		var author = ''
		var apa_date = ''
		var title = ''
		var publisher = ''
		var fishy_publisher = ''
		var fishy_title = ''
		var out = '';
		var total_metadata_found = 0;
		const month_array = ["January","February","March","April","May","June","July","August","September","October","November","December"];

// 		console.groupCollapsed(input_json.title)
//         console.log(input_json)

		if (input_json.author !== undefined && input_json.author !== null) {
			input_json.author = fix_author_string(input_json.author)
			author = author_in_apa_format(input_json.author);
		}
		if (author != '') {
			total_metadata_found++
		}

		if (input_json.date !== undefined && input_json.date !== null) {
			var pub_date = new Date(input_json.date);
			const how_long_ago = Math.floor((Date.now() - pub_date)/1000); // seconds since the publication date
			if (how_long_ago < 600000) { // dfd should be 60
				// if the publication date is less than 60 seconds ago, then it's probably not a real publication date. 
				apa_date = " (n.d.). "
				console.log('date difference = ' + how_long_ago + ' seconds. Using n.d.')
			} else {
				var month = month_array[pub_date.getMonth()];
				var year = pub_date.getFullYear();
				apa_date = " (" + year + ", " + month + " " + pub_date.getDate() + "). ";
			}
		} else {
			apa_date = " (n.d.). "
		}
		if (apa_date != " (n.d.). ") {
			total_metadata_found++		
		}
		
		title = input_json.title.trim()
        // if it doesn't end with a period or question mark, end it
        if (title.charAt(title.length-1) != '.' && title.charAt(title.length-1) != '?') {
            title = title + '.';
        }
        title = title + " ";
		// fishy title
		// this is the title that microlink would supply if the publisher actually isn't specified.
		fishy_title = input_json.url.split("/").pop()+'. '
		if (title != fishy_title) {
			total_metadata_found++		
		}		
		
		if (input_json.publisher !== undefined && input_json.publisher !== null) {
			publisher = input_json.publisher
			if (publisher.charAt(publisher.length-1) != '.' && publisher.charAt(publisher.length-1) != '?') {
				publisher = publisher + '.';
			}
        	publisher = publisher + " ";
		}
		// fishy publisher this is the publisher that microlink would supply if the publisher actually isn't specified.
		var hostname = new URL(input_json.url).hostname;
		var url_parts = hostname.split(".");
		if (url_parts.length > 2) {
			fishy_publisher = url_parts[url_parts.length - 2] + '.' + url_parts[url_parts.length-1] + '. ' // the publisher it supplies is just the last two parts of the domain (e.g., google.com)()
		}
		if (publisher != fishy_publisher) {
			total_metadata_found++		
		}		

        // put it all together
		if (author != '' && publisher != '') {
			out += author;
			out += apa_date;
			out += title
			out += '<i>' + publisher + '</i>'
			out += input_json.url
		} else if (author != '') {
			out += publisher
			out += apa_date;
			out += '<i>' + title + '</i>'
			out += input_json.url
		} else {
			if (apa_date == " (n.d.). " && title == fishy_title && publisher == fishy_publisher) {
				// if the date, title, and publisher don't seem real, just return the url
				out = input_json.url
			} else {
				out += '<i>' + title + '</i>'
				out += apa_date;
				out += publisher
				out += input_json.url
			}
		}
		console.groupEnd();
		return out;
	}

	function has_404_etc(input) {
		var i = 0

		if (input.data == null) {
    		var jstring = JSON.stringify(input).toLowerCase()
		} else {
            var jstring = JSON.stringify(input.data).toLowerCase()
        }

        // if the string "404" is found, surrounded by characters that are spaces, non-letters, and/or non-numbers, return true
		const pattern_404_surrounded_by_nonletters = new RegExp(/[+_=!@#$%^&*()\{}\[\]\/|:;'"><~`.,? ]+404+[+_=!@#$%^&*()\{}\[\]\/|:;'"><~`.,? ]/g); // 404 surrounded by characters that aren't letters or numbers
		if (jstring.match(pattern_404_surrounded_by_nonletters) != null) {
            return true;
        }
        // dfdd: make it look for other 400-style errors? 
		
// 		if (input.headers != null && input.headers.date == null) { // dfdd maybe I should do more (or less) with this?
// 		    return true;
// 		}
		
		const arr = ["page that doesn’t exist", '404 not found', "url was not found"];
		for (i = 0; i < arr.length; i++) {
			if (jstring.includes(arr[i])) {
				return true;
			}
		}

		return false;
	}


// 	var doi_pattern = \b(10[.][0-9]{4,}(?:[.][0-9]+)*/(?:(?!["&\'<>])\S)+)\b; // original from somewhere, I had to change it to make it work, see: https://www.regexpal.com/
// 	var doi_pattern = /\b(10[.][0-9]{4,}(?:[.][0-9]+)*\/(?:(?!["&\'<>])\S)+)\b/i; // works
// 	var doi_pattern = /^10.\d{4,9}/[-._;()/:A-Z0-9]+$/i; // from crossref

    

	function Text_object(input_userInput, input_doi, input_doi_or_url_type, input_url, input_ord) { 
		this.user_input = input_userInput;
        this.doi = input_doi.toLowerCase();
        this.doi_or_url_type = input_doi_or_url_type;
        this.url = input_url;
        this.url_found = ''; // the url that was returned by a web search
        this.url_status = "none"
        this.input_order = input_ord;
        this.search_status = "not started";
        this.match_status = "unknown";
        this.combine_status = "not done";
		this.notes = "";
		this.output = "";
		this.differences = '';
		this.removed = false;
		this.score = 0;
		this.letter_match = 0;
		this.letter_match_percentage = 0;
		this.percent_unchanged = 0;
		this.use_Cite = false;
		this.weird_first_letters = false;
		
// 		if (this.url != '') {
// 			this.url_status = "good";
// 		}

        this.switch_output = function(input_from_selector) {
            // output is the reference that should be output to the clipboard (or whatever)
            // in other words, it's the version of the reference that the user chose. 
            // this switches output, meaning that it changes output to be whatever the user
            // selected, and also updates the table to reflect the change
            
            // set the value of output
			switch(input_from_selector) {
				case "fixed":
					this.output = reference_obj[this.doi].apa;
					break;
				case "input":
					this.output = this.user_input;
					break;
				case "difs":
					this.output = this.differences;
					break;
				default:
					this.output = reference_obj[this.doi].apa;
					break;
			}

            // adjust what's shown in the simple table, right column
            document.getElementById(this.user_input+'_simple_text').innerHTML = this.output;
        }

        this.table_row_number = function() {
            return document.getElementById(this.user_input).rowIndex;
        }
        
		this.update_input = function(input_search_status) {
			var temp_ref_to_show = '';
		    // possible search status values:
            //    not started, searching, incorrect doi or url entered; searching again, done 
		    // possible match status values
		    //    unknown, wrong, fragment, correct
		    
            if (this.removed) {
                console.warn( 'updateinput called for .removed object (returned instead): '+this.user_input);
                return;
            }

		    if (input_search_status != '') {
    		    this.search_status = input_search_status;
    		}
		    
		    // if the user-entered doi was incorrect, change doi type
            if (input_search_status == 'incorrect doi or url entered; searching again') {
                this.doi_or_url_type = 'not_found_yet';
            }
            
//             if (input_search_status == "done") {
//                 console.log( 'update input to "done" for '+this.user_input)
//             }
            
            // if the start of a row doesn't have uppercase letters, or has weird characters, mark it as weird
            // const regex pattern("^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[-+_!@#$%^&*.,?]).+$");
            this.weird_first_letters = false;
            var flim = this.user_input.slice(0,3) // first three letters of the string (this will be bad for people with two-letter names )
            // if there are no uppercase letters in the string and it's not http
            const pattern_uppercase = new RegExp("^(?=.*[A-Z]).+$"); // uppercase letters
            if (pattern_uppercase.test(flim) == false) {
                if (flim.toLowerCase() != 'htt') {
                    this.weird_first_letters = true;
                }
            }
			// if there are non-letters in the string
            // dfd maybe move this to parse user input and have it combine when it finds (some?) of these?
            const pattern_non_letters = new RegExp("^(?=.*[-+_!@ #$%^&*.,?]).+$"); // non-letters (including space character)
            if (pattern_non_letters.test(flim)) {
                this.weird_first_letters = true;
            }

            try {
                if (typeof reference_obj[this.doi] != 'undefined') { 
                    // compute scores and statuses
                    const temp_apa_no_html = reference_obj[this.doi].apa_no_html;
                    temp_ref_to_show = reference_obj[this.doi].apa;
                    temp_ref_to_show = temp_ref_to_show.replaceAll('&amp;', "&").replaceAll('&#38;', "&").trim(); // otherwise it shows &amp; or &#38; in place of the & character

					// d is the object that represents the difference between the two strings. 
					var d = dmp.diff_main(this.user_input, temp_ref_to_show, false); // note, after the two strings, there are two optional parameters. Just use one and set it to false.  
					this.percent_unchanged = dmp.diff_percentage_unchanged(d);

                    this.score = compute_score(temp_apa_no_html, this.user_input); // order has to be database version, user version 
                    this.letter_match = compute_letter_match(temp_apa_no_html, this.user_input);
                    this.letter_match_percentage = compute_letter_match_percentage(this.user_input, temp_apa_no_html); // order has to be user, database
                    if (this.score > good_match_threshold) {
                        this.good_match = true;
                        this.match_status = 'correct';
                    } else {
                        if (this.letter_match_percentage > good_match_threshold) {
                            this.good_match = true;
                            this.match_status = 'fragment';
                        } else {
                            this.good_match = false;
                            this.match_status = 'wrong';
                        }
                    }

                    // set stuff up to show (this.notes)
                    const c  = ['tomato','black'];                
                    var temp_stringToShow = "";
//                     if (this.match_status != 'correct') {
                    temp_stringToShow += '<div style="color:' + cc[this.match_status]  + ';">' + this.match_status+'</div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.score/60)] + ';">' + this.score+'=score </div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.letter_match/60)] + ';">' + this.letter_match+'=letter_match </div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.letter_match_percentage/60)] + ';">' + this.letter_match_percentage+"=letter_match_percentage</div>"; 
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.percent_unchanged/60)] + ';">' + this.percent_unchanged+"=percent_unchanged</div>"; 
                    if (this.weird_first_letters) {
                        temp_stringToShow += '<div>weird first letters</div>'
                    }
//                     }
                    this.notes = temp_stringToShow;
//                     console.group( 'temp_stringToShow for '+this.user_input)
//                     console.log( temp_stringToShow)
//                     console.groupEnd()
                } else {
                    // it wasn't found
                    this.match_status = 'unknown';
                    temp_ref_to_show = '';
                    if (this.search_status == 'done') {
                        this.combine_status = 'cannot be combined';
                        if (window.navigator.onLine) {
                            this.notes = "not found";
                        } else {
                            this.notes = "not found<br>(no internet connection)";
                        }
                    }
                }
                
            
                if (this.match_status == 'unknown' || this.match_status == 'correct') {
                    var temp_match_status_to_show = '';
                } else {
                    var temp_match_status_to_show = '<div style="color:' + cc[this.match_status]  + ';">' + this.match_status + '</div>';
                }
                if (this.search_status == 'done') {
                    var temp_search_status_to_show = '';
                } else {
                    var temp_search_status_to_show = this.search_status;
                }
            
                if (this.notes == '') {
                    this.notes = temp_search_status_to_show + temp_match_status_to_show; 
                }
                
                if (this.match_status == 'correct' || this.match_status == 'fragment') {
                	this.output = reference_obj[this.doi].apa;
                } else {
                	this.output = this.user_input;
                }
            } catch (err) {
                console.log('**error in update input part 1 for '+this.user_input)
                console.log( err)
            }
            	
            try { 
                // update html]
                if (this.search_status == 'done' && typeof d != "undefined") {
                	this.differences = dmp.diff_prettyHtml(d, true, true);
					document.getElementById('leftColumn_'+this.user_input).innerHTML = dmp.diff_prettyHtml(d, true, false); 
					document.getElementById('rightColumn_'+this.user_input).innerHTML = dmp.diff_prettyHtml(d, false, true);
					document.getElementById('notes_'+this.user_input).innerHTML = this.notes; 
					document.getElementById('output_'+this.user_input).innerHTML = this.output; 
				} else {
					// this is the old way where it doesn't show the insertions and deletions
					document.getElementById('leftColumn_'+this.user_input).innerHTML = '<searching>' + this.user_input + '</searching>'; 
					document.getElementById('rightColumn_'+this.user_input).innerHTML = temp_ref_to_show;
					document.getElementById('notes_'+this.user_input).innerHTML = this.notes;  
					document.getElementById('output_'+this.user_input).innerHTML = '<searching>' + this.user_input + '</searching>';  
				}
            } catch(err) {
                console.log( '<---------')
    		    console.log('*error in update input, for: ');
    		    console.log( this.user_input);
    		    console.log( temp_ref_to_show);
    		    console.log( err);
                console.log( '--------->')
            }
    		update_progress(); // if this comes before the update html above, it causes errors (at least in the console). I failed to figure out why. 
		}
	}
	
	function Reference_object(input_userInput, input_json, input_apa) {	    
        try {
            this.user_input = input_userInput;
            this.json = input_json;
            this.doi = this.json.DOI;
        
            // maybe check here if it's a chapter, and if it is see if it can find the book by cutting off the last 1-2 numbers of the doi and checking crossref?
            // then it would have to check whether the title seems right, and if it does, it could find the editors and amend the reference object? 
            // this sounds risky because what if something (the title, the editors) seems right but it's wrong?

            if (input_apa == '') {
                // figure out the reference by myself
                if (input_json.type == 'web-page') {
                	if (text_obj[input_userInput].url_status == "bad") {
                		this.apa = input_userInput;
                	} else {
	                    this.apa = get_apa_from_json_URL(input_json);
	                }
                } else {
                    this.apa = get_apa_from_json(input_json);
                }
            } else {
                // using cite
                this.apa = input_apa.toString().replace(/(<div([^>]+)>)/gi,'').replace(/(<\/div>)/gi, '').trim(); // remove all div tags
            }
			this.apa_no_html = this.apa.replace(/(<([^>]+)>)/gi, ""); // dfd this should be moved into get apa from json, once it's returning an object

    	} catch(err) {
    	    console.error ('error in new reference obj')
    	    console.log(err);
    	}
 	} 
 	
// Examples of why returning accurately formatted references won't work.
// However, Mendeley gets both of these wrong as well, so...
// 
// DOI: "10.1093/oxfordhb/9780199336746.013.4"
// URL: "http://dx.doi.org/10.1093/oxfordhb/9780199336746.013.4"
// This is a chapter but the doi says it's a book. 
// The doi doesn't know the correct title of the book it's in.
// 
// DOI: "10.1037/0000157-002"
// URL: "http://dx.doi.org/10.1037/0000157-002"
// This is a chapter but it doesn't know who the editors are. 
// It should be...
// Zeleke, W. A., Hughes, T. L., & Drozda, N. (2020). Home–school collaboration to promote mind–
// body health. In C. Maykel & M. A. Bray (Eds.), Promoting mind–body health in schools:
// Interventions for mental health professionals (pp. 11–26). American Psychological Association.
// https://doi.org/10.1037/0000157-002

 	function get_apa_from_json(input_json) {
 		// Use json to create a properly formatted reference. 
 		
        // https://apastyle.apa.org/instructional-aids/reference-examples.pdf
        var firstname = '';
	    var all_author = '';
	    var name_apa = '';
        var a = 0;
        var title = '';
        var out = '';
        
//         console.log(input_json)
        
        try {
            // figure out authors
            if (input_json.author !== undefined && input_json.author !== null) {
                for (a = 0; a < input_json.author.length; a++) {
                    if (input_json.author[a].family !== undefined && input_json.author[a].family !== null) {
                        firstname = input_json.author[a].given.replaceAll('. ',' ').replaceAll('.',' ').trim();
                        firstName_array = firstname.replaceAll('. ',' ').replaceAll('.',' ').trim().split(" "); //array of first names with the periods replaced by spaces (which is only necessary for things like "T.O." as a first name)

                        name_apa = input_json.author[a].family + ", " + first_letters(firstName_array);
                        if (a == 0) {
                            all_author = name_apa;
                        } else if (a == input_json.author.length - 1) {
                            all_author += ', & ' + name_apa;
                        } else {
                            all_author += ', ' + name_apa;
                        }

                        var woof = author_in_apa_format(input_json.author[a].given + ' ' + input_json.author[a].family)
                        if (name_apa != woof) {
                            console.warning(arf + ' ≠ ' + woof)
                        }
                    }
                }
            } else {
                console.log( 'no author found')
            }
        
            // figure out editors
            // dfd I haven't worked on this because I can't find a doi with editors!! note to self: try a book
            if (typeof input_json.editor != "undefined") {
                console.log( 'EDITOR FOUND *$*# '+all_author)
                for (a = 0; a < input_json.editor.length; a++) {
                    console.log(input_json.editor[a].family)
                }
            } else {
//                 console.log('editors not found for '+all_author)
            }
            
            // figure out title
            if (input_json.title !== undefined && input_json.title !== null) {
                title = input_json.title.toString().trim();
            }
                        
            // if there's a subtitle
            if (input_json.subtitle != undefined && input_json.subtitle != null && input_json.subtitle != '') {
                // remove period and colon at the end of the title
                if (title.charAt(title.length-1) == '.' || title.charAt(title.length-1) == ':') {
                    title = title.slice(0, -1).trim();
                }
//                 console.log( '---subtitle found for '+ title)
                // add together title, colon, then subtitle
                title = title + ': ' + input_json.subtitle.toString().trim();
            }
            // if it doesn't end with a period or question mark, end it
            if (title.charAt(title.length-1) != '.' && title.charAt(title.length-1) != '?') {
                title = title + '.';
            }

            // put it all together
            if (input_json.type == 'journal-article') {
                out += all_author 
                out += ' (' + input_json.issued["date-parts"][0][0] + '). ';
                out += title;
                out += ' <i>' + input_json['container-title'] + ', ';
                out += input_json.volume + '</i>';
                if (typeof input_json.issue != "undefined") {
                    out += '(' + input_json.issue + ')';
                }
                if (typeof input_json.page != "undefined") {
                    out += ', ' + input_json.page;
                }
                out += '. https://doi.org/' + input_json.DOI;
                if (out.indexOf('undefined') > -1) {
                    console.log( 'Undefined found in output for '+out)
                }
            } else if (input_json.type == 'chapter' || input_json.type == 'book-chapter') {
                out += all_author 
                out += ' (' + input_json.issued["date-parts"][0][0] + '). ';
                out += title;  
                out += '. https://doi.org/' + input_json.DOI;   
            }
            
            return out;
            // dfd have it return an object that has: 
            // val.apa
            // val.apa_no_html
            // val.notes
            
        } catch (err) {
    	    console.log ('**error in get apa from json')
    	    console.log(err);
        
        }
 	}
 


// 	Author plan
//	If you want to be able to see secondary authors (i.e., authors cited by the articles that are in the list pasted by the user)...
// 	for each reference, you can find the dois that it cites in its json.
// 	go through everything it cites (by getting its json locally or from the server) and extract authors from each of htem. 
// 	add those authors with a secondary tag. 
// 	some articles might be cited multiple times (e.g., it was pasted in and then also cited twice by other articles that were pasted in). 
// 	maybe don't allow an article to be counted more than once. 
//	But of course, an author could be counted multiple times. Each author would probably have two counters, one for primary citations
//	and one for secondary citations.


	function Author_object(input_familyname, input_firstname) {
		// this creates instances of an author object, which is how I keep track of authors. 
		this.name = input_familyname + ", " + input_firstname;
		this.citation_count = 1;
		this.coauthors = [];
		this.checked = false;
		
		var firstName_array = input_firstname.replaceAll('. ',' ').replaceAll('.',' ').trim().split(" "); //array of first names with the periods replaced by spaces (which is only necessary for things like "T.O." as a first name)
		this.name_apa = input_familyname + ", " + first_letters(firstName_array);

		this.all_coauthors_string = function() {
			var i = 0;
			var temp = "";
			for (i = 0; i < this.coauthors.length; i++) {
				temp += this.coauthors[i].name + "; ";
			}
			return temp.substring(0, temp.length-2); // removes the final ";"
		};
	}


	async function getAllUrls(doi_or_url_type_to_handle) {
		// this gets called twice. First, for rows that have a doi. Then, when they're done, for rows that don't. 
        
		if (current_mode == 'completely done') {
            return;
        }

        var row_queue = [];
        var i = 0;

		for (let key in text_obj) { // this loops through all of text_obj
		    // if it's the right kind of doi, and has the right search status, add it to the row queue. 
            if (text_obj[key].doi_or_url_type === doi_or_url_type_to_handle) {
                if (text_obj[key].search_status === 'not started' || text_obj[key].search_status === 'incorrect doi or url entered; searching again') {
                    row_queue.push(text_obj[key].user_input);
                    if (text_obj[key].removed) {
                        console.log('**error: getting url for removed row: ' + text_obj[key].user_input)
                    }
                }
            }
		}

		console.groupCollapsed('-A- getting [' + row_queue.length + '] rows ('+doi_or_url_type_to_handle+')')
		console.log(row_queue)
		console.groupEnd()
        if (row_queue.length > 0) {
		    current_mode = "searching for dois"
            for (i = 0; i < row_queue.length; i++) {
                getOneURL(row_queue[i]);
            }
		}
	}	


	async function getOneURL(input_string) {	
    // If this input string is stored locally, this doesn't have to go to make an api call/go to a server
    //      It returns a doi and JSON (and sometimes an apa reference, which is called bibliography) 
    // If this line has a doi in it, this queries the Crossref database. 
    //      It returns a doi and JSON
    // If this line does not have a doi, this queries Crossref. 
    //      It returns a doi and JSON.
    // Once it has the doi and JSON, it calls create reference

	// This is wasteful because when it calls Cite it means going to a server to find JSON that's already 
	// been found, but I need the JSON in the format Cite uses, which is called Citation 
	// Style Language (CSL). And I couldn't figure out any other way. 

    // Be careful here! This calls everything async, which means that some of this code might 
    // execute for item 12 before it gets to item 8, etc. This is why the program does all the  
    // rows that have dois before starting on the ones that don't. 


//         console.log( '-- called get one url for: ' + input_string)
        
        var temp_ignore_doi_and_url = false;
        var bibliography = '', stringToSend = '', temp_search_string = '';
		let myJSON, myJSONobj;
		const inputDOI = text_obj[input_string].doi;
        const inputURL = extract_url(input_string)

        // get the JSON that I've stored locally on the browser (bc the user has searched it before)
        if (inputDOI === "" || temp_ignore_doi_and_url == true) {
            local_JSON = localStorage.getItem(input_string); // if there isn't a good doi, look for the whole search string
        } else {
            local_JSON = localStorage.getItem(inputDOI); // if there is a good doi, look for the doi
        }

        if (text_obj[input_string].search_status == "not started") {
       		text_obj[input_string].update_input('searching');
        } else if (text_obj[input_string].search_status == 'incorrect doi or url entered; searching again') {
       		text_obj[input_string].update_input('searching');
            temp_ignore_doi_and_url = true;
        }

		try {
            if (local_JSON != null && local_JSON != '' && text_obj[input_string].use_Cite == false) {
                // if the JSON is in local storage, retrieve it (and the stored bibliography if possible) without having to talk to the server
                myJSONobj = JSON.parse(local_JSON);
                if (myJSONobj.url_status != null) {
                    text_obj[input_string].url_status = myJSONobj.url_status
                }
                bibliography = localStorage.getItem(input_string+'\t'+'cite_bib') // get the bibliography created by cite (if there is one)
                if (bibliography == null) { // if there wasn't one, change the value to a blank string
                    bibliography = '';
                }
            } else if (window.navigator.onLine == false) {
                console.log('offline')
                text_obj[input_string].update_input('done');
                return
            } else if (text_obj[input_string].use_Cite) {
                console.log('called cite')
                // if we're using Cite because this function already called create reference, but it couldn't handle the json so it called this again
                myJSON = await Cite.async(inputDOI);
                bibliography = myJSON.format ('bibliography', {
                    format: 'html'
                });
                myJSONobj = myJSON.data[0];
                localStorage.setItem(input_string, JSON.stringify(myJSONobj)); // if using cite, encode in local storage using the search string as the key
                localStorage.setItem(input_string+'\t'+'cite_bib', bibliography); // and also store the bibliography
            } else if (inputURL != '' && temp_ignore_doi_and_url == false && inputDOI === '') {
                // if the string contains a url but no doi
                // use an api get the json of the webpage it links to. this is for news articles and stuff. 
                // unfortunately it only allows you to do 50(?) calls a day. 
                stringToSend = 'https://api.microlink.io/?url='+inputURL 
                myJSON = await $.getJSON(stringToSend);
                text_obj[input_string].url_status = url_status_checker(myJSON, inputURL)

				if (text_obj[input_string].url_status == "bad") {
					if (text_obj[input_string].search_status == 'searching') {
						text_obj[input_string].update_input('incorrect doi or url entered; searching again');
						return;
					} else {
					    console.warn("i don't think this should huv happened")
					}
				}

                myJSONobj = myJSON.data
                myJSONobj.url_status = text_obj[input_string].url_status
                console.log( 'myJSONobj.url_status='+myJSONobj.url_status)
                localStorage.setItem(input_string, JSON.stringify(myJSONobj)); // if there's a url, add it to local storage
 
            } else if (inputDOI === "" || temp_ignore_doi_and_url == true) {
                // search Crossref without a doi (either there isn't one or it's bad)
                if (temp_ignore_doi_and_url) {
                    temp_search_string = remove_doi_or_url_from_string(input_string, inputDOI);
                    temp_search_string = remove_doi_or_url_from_string(input_string, inputURL);
                } else {
                    temp_search_string = input_string;
                }
                console.log('temp_search_string=' + temp_search_string)
                temp_search_string = temp_search_string.replace(/&/g, '%26'); // encode ampersand for the url 

                stringToSend = 'https://api.crossref.org/works?mailto=nkornell@gmail.com&rows=1&query.bibliographic=' + temp_search_string.replaceAll(' ', '+');
                myJSON = await $.getJSON(encodeURI(stringToSend));
                myJSONobj = myJSON.message.items[0];
                myJSONobj.url_status = text_obj[input_string].url_status;
                localStorage.setItem(input_string, JSON.stringify(myJSONobj));
                if (inputDOI != '') {
                    // Is this possible??
                    localStorage.setItem(inputDOI, JSON.stringify(myJSONobj)); // store the incorrect doi with the correct information. this way if they enter it again it'll get found                            
                }
            } else {
                // search using a doi
                stringToSend = 'https://api.crossref.org/works/'+inputDOI+'?mailto=nkornell@gmail.com';
                myJSON = await $.getJSON(encodeURI(stringToSend)); // if there's no doi in the user input, encode in local storage using the search string as the key
                myJSONobj = myJSON.message;
                localStorage.setItem(inputDOI, JSON.stringify(myJSONobj)); // if there's a doi, encode in local storage using the doi as the key
            }
            // here's a random note on how to find a book  
            // stringToSend = 'https://api.crossref.org/works?mailto=nkornell@gmail.com&rows=1&filter=type:book&query.bibliographic=' + temp_search_string.replaceAll(' ', '+');

            if (typeof myJSONobj === 'undefined') { // if it's not in the database
                if (duplicate_input_text.indexOf(input_string) < 0) { // if it's not a duplicate
                    // this happens when a doi is bad	
                    text_obj[input_string].update_input('done');
                    console.log( "found a bad doi, trying again");
                } else {
                    console.log( "** error 823 i didn't think this was POSSIBLE");
                }
                return;
            }

            create_reference(input_string, myJSONobj, bibliography)
            
		}
		catch(err) {
			if (err.responseText == 'Resource not found.' || err == "Error: Server responded with status code 404") {
			    //if it tried a doi that is incorrect, search again without the doi
				console.log( "could not find DOI " + inputDOI + " [searching again with doi removed]") // this is fine. it's supposed to happen when a doi is incorrect.
				if (text_obj[input_string].search_status == 'searching') {
            		text_obj[input_string].update_input('incorrect doi or url entered; searching again');
	    		} 
			} else if (err == 'Error: This format is not supported or recognized') { 
			    // if it found a doi that is correct, but the citation can't be found by Cite, give up.
                text_obj[input_string].update_input('done');
            } else if (err == 'Network request failed') {
			    console.error('Network request failed: '+input_string);
                text_obj[input_string].update_input('done');            
			} else {
			    console.error('in get one url, '+input_string+' returned: ');
				console.error(err);
                text_obj[input_string].update_input('done');            
			}
		}
	}


    function create_reference(input_string, input_JSON, input_bibliography) {
        // If it's already got a bibliography entry, or if it's a type I've planned for and my code parses it, create a reference obj.
        // If it's an unfamiliar type, this (recursively-ish) calls get one URL, and has it querry Cite. 
        
        
        if (input_JSON.DOI == null) {
            input_JSON.DOI = input_string; // dfdd is this right? when there's more to the text than the url will it be bad?
            input_JSON.type = 'web-page'
//             console.log( 'url found(?) = ' + )
        }
        
        text_obj[input_string].doi = input_JSON.DOI;
        text_obj[input_string].url_found = input_JSON.url;

        try {
            if (input_bibliography != '' || input_JSON.type == "journal-article" || input_JSON.type == "chapter" || input_JSON.type == "book-chapter" || input_JSON.type == "web-page") {
                // if it has a bibliography (because it just got one from cite or one was stored locally) or is a type that my code will deal with (including web-page, which is for when it found a url)
                if (typeof reference_obj[text_obj[input_string].doi] === 'undefined') { 
                    reference_obj[text_obj[input_string].doi] = new Reference_object(input_string, input_JSON, input_bibliography); 
                } else {
                    // this isn't an error. It happens when
                    //    1) It tried to combine two rows and decided not to because best combo was better without one of them
                    //    2) Crossref returned the same doi for both. In other words, crossref say the best match for b is x, but this thinks a matches x better without b. 
                    console.log( 'u37')
                }
                text_obj[input_string].doi = reference_obj[input_JSON.DOI].doi; // this is helpful because sometimes an incorrect doi will be corrected when the json is returned (eg // turns into /)
                text_obj[input_string].update_input('done');
            } else {
                // since I can't handle it, get the URL again (using Cite this time) 
                text_obj[input_string].use_Cite = true;
                getOneURL(input_string);
    //       		weirdthing(input_string);
                return;
            }
        } catch (err) {
            console.log('Error in create reference: ' + input_string)
            console.log( err)
        }
    }

// 	async function weirdthing(input_url) {
//         // This gets a reference in apa format from Crossref. (I think it's from Crossref?) 
//         // So it kinda does what Cite does. They seem to be about the same speed. 
//         // But this doesn't return formatted text (e.g., italics), which I confirmed in email
//         // with Crossref, so I'm sticking with Cite. 
//         var xy = await $.ajax({
//             headers: { 
//         //         Accept : "application/vnd.citationstyles.csl+json" // this returns json
//                 Accept : "text/bibliography; style=apa"
//             },
//             type: "GET",
//             mailto: 'nkornell@gmail.com',
//             url: input_url, // e.g., https://doi.org/10.1093/oxfordhb/9780199336746.013.8
//         })
//         console.log( input_url)
//         console.log(xy)
//     }

	function url_status_checker(myJSON, inputURL) {
		if (has_404_etc(myJSON)) { 
			return "bad"
		}

		if (myJSON.data.url != inputURL) {
			// mismatched urls
			return "bad" // dfd maybe add this to the json instead?
		}

		if (get_apa_from_json_URL(myJSON.data) == myJSON.data.url) {
			// if get_apa_from_json_URL doesn't find metadata it returns the url, so if this returns true, it means no metadata were found
			return "bad"
		}

		return "good"
	}

	async function get_author(input_string) {
    	// dfd this function isn't done. but the idea was to get authors from the database. 
    	// I don't think I'd actually use this. Unless if there was a thing that would let a user dig deeper on a specific person. 

	    var i = 0, j = 0;
	    var temp_name = '';
	    var temp_name_array = [];
	    
	    console.log( 'starting author search')
        var stringToSend = 'https://api.crossref.org/works?mailto=nkornell@gmail.com&query.author='+input_string.replaceAll(' ', '+');
        console.log( stringToSend)
        var myJSON = await $.getJSON(encodeURI(stringToSend));

        console.log( 'author='+input_string)
        
        for (i = 0; i < 20; i++) {
            temp_obj = myJSON.message.items[i];
//             console.log( temp_obj)
            temp_name_array.push('[' + temp_obj.type + '] ' + temp_obj.title[0])
            for (j = 0; j < temp_obj.author.length; j++) {
//                 console.log(temp_obj.author[j]);
                temp_name = temp_obj.author[j].given + ' ' + temp_obj.author[j].family;
                temp_name_array.push(temp_name)
    	    // once you have the author json, use parse json for authors to turn the json into a string
            }
        }
        console.log(temp_name_array)
    }

	
	function remove_duplicate_references() {
        // could this whole function be merged with remove duplicate rows?
        var i = 0;
        var foof = 0;
        var temp_doi = '';
        var temp_doi_array = [];
	
	    current_mode = "remove duplicate references";

        for (i = 1; i <= document.getElementById('article_table').rows.length - 1; i++) { // start at 1 to skip header row
			try {
				temp_row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
			} catch(err) {
			    console.error( "error 1244")
			    continue;
			}
			try {
				temp_doi = text_obj[temp_row_text].doi;
                if (temp_doi == '') {
                    // this just means this item doesn't have a doi yet
                	continue;
                }
			} catch(err) {
			    console.error( "error 1947")
			    continue;
			}
			
// 		    console.log( 'tempdoi='+temp_doi)
			if (temp_doi_array.includes(temp_doi)) {
			    // if this doi is already in another row...
                const r1 = temp_doi_array.indexOf(temp_doi) + 1;
                const r2 = i;
			    const r1_text = document.getElementById("article_table").rows[r1].cells[0].textContent
			    const r2_text = document.getElementById("article_table").rows[r2].cells[0].textContent
// 			    console.log( 'found a duplicate doi ['+temp_doi+'] in rows '+r1+', '+r2+': ' + r1_text)
                if (decide_whether_to_combine_rows(r1_text, r2 - r1) == true) {
                	foof++; 
                }
			} else {
			    temp_doi_array.push(temp_doi);
			}			
        }
        if (foof > 0) {
            console.log( '-E-removed ['+foof+'] duplicate references--');
        }
	}

	function remove_duplicate_rows() {
	    // this is called once, after user dois have been processed
        // it's a 2-step process
        // 1. for each item, first it checks if it's on the remove list, then it checks whether it matches any other row
        // 2. after finding all the removable rows, it removes them all. 
	
		var i = 0;
		var target = 0;
		var target_string = '';
		var tempScore = 0;
		var target_has_been_found = false;
		var foof = 0;
		var local_list = [];
		var temp_row_text = '';
		       
        // go through the table and create an array that needs to be checked for whether it contains duplicates. 
		for (i = 1; i <= document.getElementById('article_table').rows.length - 1; i++) { // start at 1 to skip header row
			try {
				temp_row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
			} catch(err) {
			    console.log( "error 99833")
			}
           if (text_obj[temp_row_text].search_status === 'not started' || text_obj[temp_row_text].search_status === 'incorrect doi or url entered; searching again') {
                local_list.push(text_obj[temp_row_text].user_input);
                if (text_obj[temp_row_text].removed) {
                    console.log('**error: in remove duplicate rows, found removed row: ' + text_obj[temp_row_text].user_input)
                }
            }		
		}
		
		// find duplicate rows
        for (target = 0; target < local_list.length; target++) {
            target_has_been_found = false;
            target_string = local_list[target];
            for (i = 0; i < duplicate_input_text.length-1; i++) {
                tempScore = compute_letter_match(target_string, duplicate_input_text[i]);
                if (tempScore > 90) { // if it's the same as a previous row
                    if (duplicate_input_text.includes(target_string) == false) {
                        duplicate_input_text.push(target_string);
                    }
                    target_has_been_found = true;
                    break; // exit this loop
                }
            }
            if (target_has_been_found) {
                continue; // skip the rest of this loop and start with the next value (i.e., target+1). Because this target is already labelled a duplicate.
            } else {           
                for (i = target + 1; i < local_list.length; i++) {
                    tempScore = compute_letter_match(target_string, local_list[i]);
                    if (tempScore > 90) { // if it's the same as a previous row
                        if (duplicate_input_text.includes(local_list[i]) == false) {
                          duplicate_input_text.push(local_list[i]);
                        }

                        if (text_obj[target_string].match_status !== 'correct') {
                            if (duplicate_input_text.includes(target_string) == false) {
                                duplicate_input_text.push(target_string);
                            }
                        }
                    }   
                }
            }
        }
        
        // remove duplicate rows
        for (i = local_list.length - 1; i >= 0; i--) {
            if (duplicate_input_text.includes(local_list[i])) {
                if (text_obj[local_list[i]].doi_or_url_type != 'from_user') { // don't remove if it has a doi
                    remove_row(local_list[i]);                
                    foof++;
                }
            }
        }
        if (foof > 0) {
            console.log('-C-removed ['+foof+'] duplicate rows--');
        }
	}
	
	
	function pagelog(instring) {
        document.getElementById("buffer_for_copying").innerHTML += '<p>' +instring;
	}
	
	function remove_row(input_string) {
		// remove a row that is no longer needed
		
        if (text_obj[input_string].removed) {
            // if it's already removed, don't remove it. 
            return;
        } else {
            try {
                if (text_obj[input_string].match_status == "correct") {
                    console.log('removing a "correct" row: '+input_string);
                }
                
                var row_to_remove = document.getElementById(input_string).rowIndex;
                document.getElementById("article_table").deleteRow(row_to_remove);
                
//                 console.log( 'removing row: '+input_string)

				text_obj[input_string].search_status = 'done';				
                text_obj[input_string].removed = true; // I think I did this rather than deleting it because get URL might be looking for it later. 
        
            }
            catch(err) {
                console.log( '*error in remove_row. input_string='+ input_string + " [error next line]");
                console.log( err);
            }
	        update_progress();
        }
	}

	function check_table_for_combinations() {
		var i = 0;
        var run_me_again = false;
        
	    current_mode = "checking combos"

		for (i = 1; i <= document.getElementById('article_table').rows.length - 1; i++) { // start at 1 to skip header row
			try {
				temp_row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
			} catch(err) {
				console.log( '*error setting temprowtext (i='+i+'): '+err);
				continue;
			}
			
			try {
                if (typeof text_obj[temp_row_text] == "undefined" || text_obj[temp_row_text] == null) {
                	// if the text obj can't be found, go to the next one (continue goes back up to the for loop)
					console.log( 'text_obj not found for '+temp_row_text);
                	continue;
                }
                
				temp_DOI = text_obj[temp_row_text].doi;
                if (temp_DOI == '') {
                    // this just means this item doesn't have a doi yet
                	continue;
                } 
                if (typeof reference_obj[temp_DOI] == "undefined" || reference_obj[temp_DOI] == null) {
                    // this will happen when there's one where the doi is correct but it's not in the database (it should be rare. but it's fine.)
                	continue;
                }
// 				console.log( 'deciding about: '+temp_DOI)
				if (decide_whether_to_combine_rows(temp_row_text,-1) == true) {
					run_me_again = true;
                    break; // exit this loop

				}
				if (decide_whether_to_combine_rows(temp_row_text, 1) == true) {
					run_me_again = true;
                    break; // exit this loop
				}
				if (run_me_again == false) {
                    text_obj[temp_row_text].combine_status = 'done';
//                     console.log( 'set cs to done: '+text_obj[temp_row_text].doi)
                }
			} catch(err) {
 				console.error( '*error could not run decide whether...: ')
 				console.log( ' *'+temp_row_text)
 				console.log( ' *'+err)
			}
		}
		if (run_me_again) {
// 			console.log( ';again;')
			check_table_for_combinations();
		} else {
// 			console.log( '-D-checked for combinations--')
		    current_mode = "done combining"
		    update_progress();
		}
	}

	function decide_whether_to_combine_rows(input_string, shift) {
        // make sure we're looking at two legitimate rows
        // this returns true if it makes any changes (i.e., removes a row or changes user input)
		if (document.getElementById(input_string) == null) { // this can happen when the user_input has changed but the reference obj hasn't)
			console.log( '**error: in decide whether to combine... null found for '+input_string)
			return false;
		}

         if (text_obj[input_string].removed) {
            console.log( '*tried to combine with a removed reference obj: '+input_string); 
            return false;
        }
        
        var row_index = text_obj[input_string].table_row_number();
		var other_row_index = text_obj[input_string].table_row_number() + shift;

        // don't try it if it would go outside the table
    	if (other_row_index < 1) { // it's 1 because row 0 is the table header
    	    return false;
    	} else if (other_row_index >= document.getElementById("article_table").rows.length) {
    	    return false;
    	}
        
        try {
	        var otherRow_input_string = document.getElementById("article_table").rows[other_row_index].cells[0].textContent;
	    } catch(err) {
	    	console.error( "**error: in decide whether... can't find this row: " + other_row_index)
	    	return false;
	    }
	    
	    if (text_obj[otherRow_input_string].removed) {
	        console.log( 'returning because otherRow has been removed: '+ otherRow_input_string)
	        return false;
	    }
// 	    console.log( 'breadcrumb^^^^^ '+this_row_doi)
	    
	    // see if the other row has a doi
	    var this_row_doi = text_obj[input_string].doi;
	    var otherRow_doi = text_obj[otherRow_input_string].doi;

	    // decide what to do
	    
        var shouldCombine = false;
        var shouldChangeUserInput = false;

		if (text_obj[input_string].match_status == "wrong") {
		    if (current_mode == 'remove duplicate references') {
		        // when the mode is removing duplicate references, it's not going to check both input strings. so just go ahead and combine it (i.e., don't return)
		    } else {
                // return here, and then wait for the other input string to be called. 
                // dfd: if both are wrong, then they won't get combined given the way this is set up now. 
    		    // this is where it would be smart to check whether the other one is also wrong, and if it is, join the strings and send that to the database. 
                return false; 
            }
		}
        
        try {
            if (otherRow_doi == this_row_doi) {
                // if they have the same doi
                shouldCombine = true;
            } else if (text_obj[otherRow_input_string].search_status == "searching") {
                // if it's still searching for the other row, return. it'll try again with that row later. 
                return false; 
            } else if (text_obj[otherRow_input_string].match_status == "correct") {
                // if the other one is correct (and we already know the dois are different), return. when the other one gets its chance, it'll combine with this one (if appropriate)
                return false;
            }
        } catch(err) {
            console.log( "*error palm frond for "+otherRow_input_string)
            console.log( err);
        }

        try {
            var bestcombo = best_combination(otherRow_input_string, input_string, reference_obj[this_row_doi].apa_no_html);
 
//             console.log( 'input string: '+input_string)
//             console.log( 'otherRow input_string: '+otherRow_input_string)
//             console.log( 'best combo  : '+bestcombo)
            // if the best match is the combo, combine them. 
            if (input_string !== bestcombo) {
                shouldCombine = true;
                shouldChangeUserInput = true;
            }
            
            if (shouldCombine) {
				if (otherRow_doi != '') {
					if (typeof reference_obj[otherRow_doi] != "undefined" && reference_obj[otherRow_doi] != null) {
						if (otherRow_doi != this_row_doi) {
							var bestcombo_other = best_combination(input_string, otherRow_input_string, reference_obj[otherRow_doi].apa_no_html);
							var s1 = compute_letter_match(bestcombo, reference_obj[this_row_doi].apa_no_html);
							var s2 = compute_letter_match(bestcombo_other, reference_obj[otherRow_doi].apa_no_html);
							if (s2 > s1) {
								console.log( 'using the other doi will be better!!! [returning]')
								console.log( '-score [' + s1 + '] ' + bestcombo)
								console.log( '-score [' + s2 + '] ' + bestcombo_other)
								return false; 
							}
						}
					}
				}
			}

            // if appropriate, remove the row
            if (shouldCombine == true) {
                remove_row(otherRow_input_string);
                if (shouldChangeUserInput == true) {
                    if (current_mode == "completely done") {
                        console.log( '...when completely done')
                        return true; // true because a row was removed above
                    }
                    change_user_input(input_string, bestcombo); 
                } else {
                    if (input_string == bestcombo) {
//                         console.log( "[didn't change user input] they're the same")
//                         console.log( 'input_string='+input_string)
//                         console.log( 'otherRow_input_string='+otherRow_input_string)
//                         console.log( 'bestcombo='+bestcombo)
                    } else {
                        console.log( "[didn't change user input] "+input_string + " != "+bestcombo)
                    }
                }
                console.log('bestcombo='+bestcombo)
                return true;
            } else {
                return false;
            }
        }
        catch(err) {
            console.error('*error in combine rows, otherRow_input_string:')
            console.log( otherRow_input_string);
            console.log( err)
        }
	}
	
	function change_user_input(from_string, to_string) { 
	    // this changes the user input in: the table, the reference obj, and...
	    // it also deletes the text obj and creates a new one in its place.
	
        try {
			if (text_obj[from_string].removed == true) {
				console.log( '**error: trying to change user input for a removed thing;)')
			}
			if (typeof text_obj[to_string] !== 'undefined' && text_obj[to_string] !== null) {
			    console.log( '**error 8484: tried to change user input to something that already existed [returning]')
			    return;
			}
        
            change_elementIDs(from_string, to_string);
        
            // create a new version of the input obj (with a new array index), but then copy the old one into it. I think I did this because get url is going to be expecting to return info to this thingy
            text_obj[to_string] = new Text_object(to_string, "","","",-1); // not giving it a doi means it won't add 1 to numRows withDOIsTotal
            text_obj[to_string] = Object.assign({}, text_obj[from_string]);
            text_obj[to_string].user_input = to_string;
            // update reference obj (i.e., from obj)
            reference_obj[text_obj[to_string].doi].user_input = to_string;
            text_obj[to_string].update_input('');

            update_progress();
        }
        catch(err) {
            console.log( '*error in change user input, from = '+from_string+' to = '+to_string+' error:')
            console.log( err)
        }
	}
	
	
	function best_combination(user_input_addition, user_input_target, goal) {
	    // tries the first two input parameters alone and in combination, to see which one matches the 3rd parameter best.
	    // the order of the first two parameters only matters because it checks its percentage at the start
		var out = "";
    	var verbose = false;

		// if the new piece by itself is not a good percentage match for the target, don't combine
		var addition_Score_percent = compute_letter_match_percentage(user_input_addition, goal);
        if (addition_Score_percent < good_match_threshold) {
            if (text_obj[user_input_addition].doi != text_obj[user_input_target].doi) { 
                // If they have the same doi, go ahead and let them get combined. Why? Because it's going to remove one of them if you don't (if two rows have the same doi, one gets removed).
                // But if they don't have the same doi, go ahead and return the target (i.e., don't combine). 
                return user_input_target;
            }
		}

		// figure out the input, and put it in the order of the table (so that only forward combos will be accepted)
        if (document.getElementById(user_input_addition).rowIndex > document.getElementById(user_input_target).rowIndex) {
            aText = user_input_target;
            bText = user_input_addition;
		} else {
            aText = user_input_addition;
            bText = user_input_target;
		}
		comboText = aText + " " + bText;
		reverse_comboText = bText + " " + aText;
				
        try {
            aScore = compute_letter_match(aText, goal);
            bScore = compute_letter_match(bText, goal);
            comboScore = compute_letter_match(comboText, goal);
            reverse_comboScore = compute_letter_match(reverse_comboText, goal);
            
            // maybe to really be smart, it should look at where the fragment is (in the goal string). If it's the end, don't add 
            // something after it; if it's the start, don't add something before it. 
            
            if (verbose == true) {
                console.log( '--running best combination--');
                console.log('a = ['+text_obj[aText].search_status+', '+text_obj[aText].match_status+'] ' + aText)
                console.log('b = ['+text_obj[bText].search_status+', '+text_obj[bText].match_status+'] ' + bText)
                console.log( 'goal = '+goal)
                console.log( aScore, bScore, comboScore, reverse_comboScore)
                console.log( compute_letter_match_percentage(aText, goal),compute_letter_match_percentage(bText, goal),compute_letter_match_percentage(comboText, goal),compute_letter_match_percentage(reverse_comboText, goal))
            }
        }
        catch(err) {
            console.log('*error in best combination:')
            console.log('aText was='+aText);
            console.log('bText was='+bText);
        }
           
        reverse_comboScore = 0; // doing this makes it so reverse can't win. 
		maxScore = Math.max(aScore,bScore,comboScore,reverse_comboScore);
		if (maxScore == comboScore) {
		    if (verbose == true) {console.log( 'winner=comboText');}
			return comboText;
		} else if (maxScore == reverse_comboScore) {
		    if (verbose == true) {console.log( 'winner=reverse comboText');}
			return reverse_comboText;
		} else if (maxScore == aScore) {
		    if (verbose == true) {console.log( 'winner=returning earlier table entry');}
			return aText;
		} else if (maxScore == bScore) {
		    if (verbose == true) {console.log( 'winner=returning later table entry');}
			return bText;
		}
	}
	
	function compute_score(databaseString, userString) {
		// figure out whether a DOI was found in the user input
		var userDOI = userString.match(doi_pattern); 
		var databaseDOI = databaseString.match(doi_pattern); 
		var userURL = text_obj[userString].url;
		var databaseURL = text_obj[userString].url_found;
		
		// dfdd make scoring work for urls
		console.groupCollapsed( 'computing score')
		console.log( userString)
        console.log('database string 1')
		console.log( databaseString)
		console.log( 'text_obj[userString].url_status='+text_obj[userString].url_status)
		
        try {		
            // return a score
            if (typeof userDOI !== 'undefined' && userDOI !== null && userDOI.length > 0) {	// with typeof, put undefined in quotes
                if (userDOI[0].toLowerCase() == databaseDOI[0].toLowerCase()) { 
                    // if a doi was found, it returns percentage. why? basically, if it's part of a reference with the right doi, this 
                    // will be high. but if it's the wrong reference, it'll be low. 
                    return compute_letter_match_percentage(userString,databaseString);
                } else {
                    // if the user doi wasn't the same as the database one (is this possible?!) return the match strength without removing the doi
                    // this happens when there's a bad doi, it searches without the doi, and finds a good doi to replace the bad one
                    return compute_letter_match(databaseString,userString);
                }
            } else if (userURL !='' && text_obj[userString].url_status == "good") {
                // if there's a good url
                return 83; // dfd this is totally wrong but good for testing            
            } else {
                // if there is not a valid doi or url in the user input, remove the doi or url from the database string for the sake of comparison. 
                // this does not use percentage because without a doi, I can't assume either side is good 
                databaseString = remove_doi_or_url_from_string(databaseString, databaseDOI);
                databaseString = remove_doi_or_url_from_string(databaseString, databaseURL);
                console.log('database string 2')
                console.log( databaseString)
                console.groupEnd();
                return compute_letter_match(databaseString,userString);
            }
		} catch(err) {
		    console.warn("Warning in compute score. (Note; this error can happen if the database string doesn't contain a doi.)")
		    console.log(err)
		}
	}
	
	function compute_letter_match(a, b) {
		return Math.ceil(100*similarity(a,b));
	}
	
	function compute_letter_match_percentage(a, b) {
        // This returns how good a match it is in terms of doing the best it could. 
        // In other words, the amount of letter match divided by the total possible amount of letter match. 
        
		var tempMatch = compute_letter_match(a, b);
		var maxPossible = a.length / b.length;
		
       // This would make it so that the order of the input parameters would not matter. However, the second parameter (b) is the target string, so here it does matter.
// 		if (maxPossible > 1) {
// 			maxPossible = 1/maxPossible;
// 		}
		maxPossible = 100*maxPossible;
        
        var return_value = Math.ceil(100*tempMatch/maxPossible);
        if (return_value > 100) {
            return_value = 100
        }
        
		return return_value;
	}

	function change_elementIDs(from, to) {
	    try {
            document.getElementById(from).id = to;
            document.getElementById('rightColumn_'+from).id = 'rightColumn_'+to;
            document.getElementById('leftColumn_'+from).id = 'leftColumn_'+to;
            document.getElementById('notes_'+from).id = 'notes_'+to;			
            document.getElementById('output_'+from).id = 'output_'+to;			
        } catch(err) {
            console.log( '*error in change element IDs')
            console.log( 'from = '+from)
            console.log( 'to = '+to)
            console.log( err)
        }
	}
	
	function remove_doi_or_url_from_string(input_string, input_doi_or_url) {
	    var foof = '';
	    
        foof = input_string.replace("https://doi.org/"+input_doi_or_url,""); // assuming what seems like the standard format from the database
        foof = foof.replace("https://dx.doi.org/"+input_doi_or_url,""); // I'm not even sure this can happen or is necessary, but it doesn't seem to hurt. 
        foof = foof.replace(input_doi_or_url,""); // in case that wasn't found, remove just the doi. and this will also remove a url when appropriate. 
        
        return foof;
	}
	
	function parse_JSON_for_authors(input_json) { // give this a second parameter, type of article (primary or secondary), if you're looking at secondary authors
		var temp_firstname = '';
		var tempAuthor_full = "";
		var temp_list_of_co_authors_from_this_article = [];
				
		// figure out author stuff (for author table)
		try {
			if (input_json.author == null || typeof input_json.author === 'undefined') { // if crossref didn't find it, ignore it 
// 				console.log('no authors found ' + input_json.DOI);
			} else {
				for (a = 0; a < input_json.author.length; a++) {
					if (input_json.author[a].family !== undefined && input_json.author[a].family !== null) {
						temp_firstname = input_json.author[a].given.replaceAll('. ',' ').replaceAll('.',' ').trim();
						tempAuthor_full = input_json.author[a].family + ", " + temp_firstname;
					
						// keep track of how many times this author has appeared for the table of authors
						if (author_obj[tempAuthor_full] === undefined) {
							author_obj[tempAuthor_full] = new Author_object(input_json.author[a].family, temp_firstname);
						} else {
							author_obj[tempAuthor_full].citation_count++;
						}
						temp_list_of_co_authors_from_this_article.push(tempAuthor_full);
					}
				}

				connect_coauthors(temp_list_of_co_authors_from_this_article);
			}
		} catch(err) {
			console.log( '*error in parse_JSON_for_authors');
		}
	}
	
// not tested
// 	function author_full(author_input_obj) {
//         var temp_firstname = author_input_obj.given.replaceAll('. ',' ').replaceAll('.',' ').trim();
//         return author_input_obj.family + ", " + temp_firstname;  
// 	}

	function connect_coauthors(list_of_coauthors) {
		var i = 0;
		var j = 0;
		
		// if it's a single-author paper, don't do anything
		if (list_of_coauthors.length == 1) {
			return;
		}
		
// 		go through each pair of authors in the author list and connect each to the other (i.e., add them to each other's list of coauthors)
		for (i = 0; i < list_of_coauthors.length + 1; i++) {			
			for (j = i + 1; j < list_of_coauthors.length; j++) {
				if (author_obj[list_of_coauthors[i]].coauthors.includes(author_obj[list_of_coauthors[j]]) === false) { // if they aren't already connected
					author_obj[list_of_coauthors[i]].coauthors.push(author_obj[list_of_coauthors[j]]);
					author_obj[list_of_coauthors[j]].coauthors.push(author_obj[list_of_coauthors[i]]);
				}
			}
		}
	}
	
	function parse_user_input() {
		var inputText = document.getElementById("myText").value;
		localStorage.setItem('nates_previous_input',inputText)
		inputText = inputText.replace(/[\\#$~%'"*{}]/g, ''); // remove illegal characters. I took out the question mark (it used to be /[&\\#$~%'"*?{}]/g) but that seems to work just fine.
		inputText = inputText.replaceAll("- ","-"); 
		
		var tempDOIArray = [];
		var tempDOItype = "";
        var tempDOI = '';
        var tempDOIsFoundSoFar = [];
        var tempURL = '';
        
        inputText = inputText.replace(/\t+/g, ' '); // turn tabs into single spaces
        inputText = inputText.replace(/  +/g, ' '); // turn multiple space strings into single spaces
        
        // split the input into an array and clean it up
		var urlSuffix = inputText.split(/\r\n|\r|\n/g);
		for (i = urlSuffix.length - 1; i >= 0; i--) {
			urlSuffix[i] = urlSuffix[i].trim();
			if (urlSuffix[i].length < 1) {
			    // if it's a blank row, get rid of it
                urlSuffix.splice(i, 1);
            }
        }
        
        // compute median string length
//         const strLenArray = urlSuffix.map(myFunction);
//         function myFunction(input_string) {
// //             const x = input_string.trim();
//             return input_string.length;
//             return Math.floor(input_string.length/10)*10;
//         }
//         strLenArray.sort(function(a, b){return a - b});
//         console.log( strLenArray)
//         const string_length_median = Median(strLenArray)
//         const string_length_upper = Quartile(strLenArray, .80)
//         const string_length_lower = Quartile(strLenArray, .20)
//         console.log('Median='+string_length_median)
//         console.log('Upper='+string_length_upper)
//         console.log('Lower='+string_length_lower)
//         console.log('Upper gap: '+Math.abs(string_length_upper - string_length_median));
//         console.log('Lower gap: '+Math.abs(string_length_lower - string_length_median));
        
		// combine rows if 
		// - they're too short and don't contiain a doi, combine with above
		// - end with '-', combine with below

// 		const min_length = Math.min(40, string_length_median/2); // dfd could use this, but it just doesn't seem necessary because references can't really be shorter than 40 

        // combine rows if they're short or have a -
		const min_length = 40; // This seems good. If you go to 50, it makes a mistake on Dweck's book.  
		for (i = urlSuffix.length - 1; i >= 0; i--) {
			if (urlSuffix[i].length < min_length && urlSuffix[i].match(doi_pattern) == null && extract_url(urlSuffix[i]) == '') {
        		// if a row has too few characters, combine it with the previous row. (But not if it has a URL or a doi in it.)
			    if (i > 0) { // if it's not the first row (bc there's no previous row)
                    urlSuffix[i-1] = urlSuffix[i-1] + urlSuffix[i];
                    urlSuffix.splice(i, 1);
                    console.log('combined short thing: ' + urlSuffix[i-1])
                }
			} else if (urlSuffix[i].charAt(urlSuffix[i].length-1) == '-') {
        		// if it ends with - combine it with the following row (if there is one).
        		if (typeof urlSuffix[i+1] != undefined && urlSuffix[i+1] != null) {
					urlSuffix[i+1] = urlSuffix[i] + urlSuffix[i+1];
					urlSuffix.splice(i, 1);
                    console.log('combined thing that ended in -: ' + urlSuffix[i+1])
				}
			}
		}
			
		for (i = 0; i < urlSuffix.length; i++) {
            tempDOIArray = [];
            tempDOIArray = urlSuffix[i].match(doi_pattern); // match returns an array, so this is just to get that array and help convert it to a string. 
            tempURL = extract_url(urlSuffix[i]);
            if (typeof tempDOIArray !== 'undefined' && tempDOIArray !== null && tempDOIArray.length > 0) { // if it found a doi
                var tempArraySplit = urlSuffix[i].split(tempDOIArray[0]);
                var a = tempArraySplit[0]+tempDOIArray[0];
                var b = tempArraySplit[1].trim();
                // if the string after the delimiter has something in it, split that stuff (everything after the 1st doi) into a different string
                if (b.length > 0) {
                    urlSuffix[i] = a; // change suffix to be equal to the first part
                    urlSuffix.splice(i+1, 0, b); // add an item to the suffix array that's got the second part in it. 
                }
                tempDOItype = "from_user";
                tempDOI = tempDOIArray[0];
                if (tempDOI.indexOf("//", 7) >= 0) {
                    // get rid of //, which is legal in a URL but only once (at least with respect to submitting a doi to crossref)
//                     console.log( 'found double hockey sticks')
                    tempDOI = tempDOI.slice(0,7) + tempDOI.slice(8).replace('//','/');
                }
            } else if (tempURL != '') {
                // if it has a url
                tempDOItype = "from_user"
            } else {
                tempDOItype = "not_found_yet";
                tempDOI = '';
            }
            
            if (tempDOIsFoundSoFar.includes(tempDOI)) { // if the doi has already been found in the user input
                console.log( 'duplicate doi found in user input. not added: ' + tempDOI);
            } else {
                if (typeof text_obj[urlSuffix[i]] != 'undefined' ) {
                    console.error( "**error: textobj already exists [skipping it]: "+urlSuffix[i])
					duplicate_input_text.push(urlSuffix[i]);
                    continue;
                    // dfd here's a known issue: If two rows are identical (and don't have a doi), there's a problem. 
                    // you can't make two text_obj because they'll have the same index and therefore be indistinuishable. 
                    // so only one gets added to the html table. basically, the second one (and beyond) kinda disappears. 
                    // And you won't see a problem in the output, necessarily, because the disappeared line doesn't get processed. 
                    // And btw, here's why I don't want to just disappear: it's possible that the same line appearing twice is correct. (by contrast, disappearing a duplicate doi is fine.) 
                }
                text_obj[urlSuffix[i]] = new Text_object(urlSuffix[i], tempDOI, tempDOItype, tempURL, i); // if there's no doi, or the doi is new, use it. 
                if (tempDOI.length > 0) {
                    tempDOIsFoundSoFar.push(tempDOI);
                }
            }
        }
		build_article_table();
	}
	
	function build_article_table() {
		// Build article table
		var s = '';
		
		articleTableText = "<table id='article_table'>";
		// this would make columns 3, 4, and 5 invisible
		// <colgroup><col span="2"><col span="3" style="visibility: collapse"></colgroup>
		
//     	articleTableText += '<colgroup><col span="2" style="visibility: collapse"><col span="2"></colgroup>'; // hide the first two columns
    	articleTableText += "<tr>";
		articleTableText += "<th onclick='sortTable(0, "+'"articleTable","letters"'+")' title='Click to Sort'>Input text</th>";
    	articleTableText += "<th onclick='sortTable(1, "+'"articleTable","letters"'+")' title='Click to Sort'>Article found</th>";
    	articleTableText += "<th onclick='sortTable(2, "+'"articleTable","letters"'+")' title='Click to Sort'>Notes</th>";
    	articleTableText += "<th onclick='sortTable(3, "+'"articleTable","letters"'+")' title='Click to Sort'>Output</th>";
    	articleTableText += "</tr>";
		for (let key in text_obj) { // this loops through all of text_obj
            s = text_obj[key].user_input;
            articleTableText += "<tr id='"+s+"'>";
            articleTableText += "<td id='leftColumn_"+ s +"'>"+ s +"</td>";
            articleTableText += "<td id='rightColumn_" + s + "'></td>";
            articleTableText += "<td id='notes_" + s + "'></td>";
			articleTableText += "<td id='output_"+ s +"'></td>";
            articleTableText += "</tr>";
		}

		articleTableText += "</table>";
		
		document.getElementById('articleTable').innerHTML = articleTableText;

	}

	function authorCheckBoxPress(whichOne) {
		// this is called when a checkbox is pressed
		var i = 0;
		const nameString = whichOne.id;
		author_obj[nameString].checked = whichOne.checked; // set this author's status (i.e., checked or not) to the status of the checkbox
		
		// for this author and their coauthors, compute their status 
		computeStatus(nameString);
		for (i = 0; i < author_obj[nameString].coauthors.length; i++) {
			computeStatus(author_obj[nameString].coauthors[i].name);
		}
	}
	
	function computeStatus(nameString) {
		// this figures out whether an author should be highlighted (i.e., whether they or their coauthors are checked)
		var i = 0;
				
		if (author_obj[nameString].checked == true) {
			// if this author is checked, turn them red
			document.getElementById('name_' + nameString).style.color = 'red';
		} else {
			// if this author has a co-author that is checked, turn them red and return
			for (i = 0; i < author_obj[nameString].coauthors.length; i++) {
				if (author_obj[nameString].coauthors[i].checked) {
					document.getElementById('name_' + nameString).style.color = 'red';
					return;
				}
			}
			// otherwise, turn them black		
			document.getElementById('name_' + nameString).style.color = 'black';
		}
	}

	
    function build_author_table() {
		// Figure out the authors and build a table with all of them in it. This happens after all the articles are parsed.
// 		console.log( 'calling build author table')

		var i = 0;
		author_obj = [];

        // parse authors
        var rows_total = document.getElementById('article_table').rows.length - 1;
		for (i = 1; i <= rows_total; i++) { // start at 1 to skip header row
			try {
				temp_row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
				temp_DOI = text_obj[temp_row_text].doi;
				parse_JSON_for_authors(reference_obj[temp_DOI].json)
			} catch(err) {
// 				console.log( 'could not parse author: ' + temp_row_text)
			}
		}

		// build table
        var authorTableText = "";
        // create the html table 
        authorTableText = "<table><tr>";
        authorTableText += "<th onclick='sortTable(0, "+'"authorTable","checkboxes"'+")' title='Click to Sort'>Highlight <br>co-authors</th>";
        authorTableText += "<th onclick='sortTable(1, "+'"authorTable","letters"'+")' title='Click to Sort'>Author</th>";
        authorTableText += "<th onclick='sortTable(2, "+'"authorTable","numbers"'+")' title='Click to Sort'>Citations</th>";
        authorTableText += "<th onclick='sortTable(3, "+'"authorTable","letters"'+")' title='Click to Sort'>Co-Authors</th>";
        authorTableText += "</tr>";

        for (var key in author_obj) {
            authorTableText += "<tr>";
            authorTableText += '<td><input type="checkbox" id="'+key+'" onclick="authorCheckBoxPress(this)"></td>';
            authorTableText += "<td><div id='name_" + author_obj[key].name + "'>" + author_obj[key].name + "</td>";
            authorTableText += "<td>" + author_obj[key].citation_count + "</td>";
            authorTableText +=  "<td>" + author_obj[key].all_coauthors_string();
            authorTableText += "</td></tr>";
        }

        authorTableText += "</table>"
        document.getElementById('authorTable').innerHTML = authorTableText;		
        sortTable(1, "authorTable", "letters");
    }
    
    function show_previous_user_input() {
        document.getElementById("myText").value = localStorage.getItem('nates_previous_input')
		document.getElementById('myText').style.height = (innerHeight-300)+'px';
    }
        
    function reset_user_input() {
        console.log('reseting;')
        
        var foof = "https://doi.org/10.1037/0000157-002" + "\r\n\r\n"
        foof += "https://doi.org/10.1093/oxfordhb/9780199336746.013.4" + "\r\n\r\n"
        foof += "https://doi.org/10.1037/xlm0000246" + "\r\n\r\n"
        document.getElementById("myText").value = foof;
    }

	function start() {
		reference_obj = [];
		text_obj = [];
		duplicate_input_text = [];
		started_notFoundYet = false;
		current_mode = "searching for dois"
		startTime = Date.now();

		document.getElementById("fix_button").disabled = true;
		
		console.log( '')
		console.log( '---------start----------')

        document.getElementById("simpleOutputTable").style.display = "flex;"
        document.getElementById("progressAndSummaryBox").style.display = "flex"
		document.getElementById('myBar').style.display = "flex"

        
        show_or_hide_everything('hide'); 
        		
        if (document.getElementById('progressText').innerHTML != "Working...&nbsp;") {
            document.getElementById('progressText').innerHTML = "Working...&nbsp;";
		}

		parse_user_input();
		getAllUrls('from_user');
		update_progress();
	}

	function update_progress() {	
	    if (current_mode == "completely done") {
// 	        console.log( ' called up when completely done [returning]')
	        return; 
	    }
	    
	    var row_text = '';
	    var rows_searched = 0;
	    var rows_combined = 0;
	    var rows_with_user_dois_total = 0;
	    
        var rows_total = document.getElementById('article_table').rows.length - 1;
        try {
            for (i = 1; i <= rows_total; i++) { // start at 1 to skip header row
                row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
                if (typeof text_obj[row_text] == undefined || text_obj[row_text] == null) {
                    console.log("*error Can't find text_obj[row_text]. The text in the table probably got altered. See next error.")
                }
                if (text_obj[row_text].search_status == "done") {
                    rows_searched++;
                }
                if (text_obj[row_text].doi_or_url_type == "from_user") {
                    rows_with_user_dois_total++;
                }
                if (text_obj[row_text].combine_status == "done" || text_obj[row_text].combine_status == 'cannot be combined') {
                    rows_combined++;
                }
            }
        } catch (err) {
            console.log('*error in update progress: ')
            console.log( row_text);
            console.log( err);
        }
        
        show_simple_output()  // it calls this (which redraws the simple table) a bunch of times
        
		if (rows_combined >= rows_total && current_mode == "done combining") {
		    // it's already attempted to combine all rows
		    remove_duplicate_references();
			finish();
		} else if (rows_searched >= rows_total && current_mode == "searching for dois") {
		    // if done searching for all dois
// 			console.log( '-B- searched all--')
			check_table_for_combinations(); 
		} else if (rows_searched == rows_with_user_dois_total && started_notFoundYet == false  && current_mode == "searching for dois") {
		    // if it's done searching for user-entered dois
// 			console.log( '-B- searched dois--')
		    started_notFoundYet = true;
			remove_duplicate_rows();
			check_table_for_combinations();
            getAllUrls('not_found_yet');
        }
//         console.log( 'upd_prog: searched,combined,total= '+ rows_searched+', '+rows_combined+', '+rows_total)
        
        // update progress bar
        document.getElementById("myBar").style.width = 100*rows_searched/rows_total + "%";
	}
	
	function finish() {
        if (current_mode == 'completely done') {
            console.log( '*error called finish() when already completely done [returning]')
            return;
        }
        
        current_mode = 'completely done'
        
        var c = 0;
        var m = 0;
        var w = 0;
        var rows_total = document.getElementById('article_table').rows.length - 1;
        for (i = 1; i <= rows_total; i++) { // start at 1 to skip header row
        	temp_match_status = text_obj[document.getElementById("article_table").rows[i].cells[0].textContent].match_status
			if (temp_match_status == 'correct') {
			    c++;
			} else if (temp_match_status == 'wrong') {
			    w++;
			} else {
			    m++;
			}
		}
        
		document.getElementById('progressText').innerHTML = 'Done. ' + rows_total + " references <span style='font-weight: bold; color: green'>" + c + " ✔</span>, <span style='font-weight: bold; color: red'>" + w + " ✘</span> , <span style='font-weight: bold; color: orange'>" + m + " maybe</span> in " +  Math.floor((Date.now() - startTime)/1000) + ' seconds';
		document.getElementById("myBar").style = "display: none;"

		
		build_author_table();
		document.getElementById("refalyzerAuthorsBox").style = "display: block;"	
		
		show_simple_output();
		show_or_hide_everything('hide');
		
		
		document.getElementById("authors_button").style.display = "inline-block";
		document.getElementById("copy_button").style.display = "inline-block";
		document.getElementById("clear_storage_button").style.display = "none";
		
		console.log( '---------finish----------')
		console.log( '')
	}
	
	function show_simple_output() {
		// this puts the output in a user-friendly table (this is instead of using article_table)

		var i, showingUnknown = 0;
		var t = ''; // for the table 
        let initial_scroll_top = 0;
		
        // figure out the scroll position of the table so it can stay there instead of snapping to top on every re-draw (this only applies until the searching is done btw)
		if (typeof(document.getElementById('simple_table')) != 'undefined' && document.getElementById('simple_table') != null) {
		    initial_scroll_top = document.getElementById('simple_table').scrollTop;
		} else {
			// this should only happen once, before the simple table has been created. this creates it and formats it. 
			document.getElementById("simpleOutputTable").style.display = "flex";
			document.getElementById('simple_table_div').innerHTML = '<table id="simple_table"></table>';
			document.getElementById('simple_table').style = "display: flex; overflow-y: scroll;"
			document.getElementById('simple_table').style.height = (innerHeight-300)+'px';
		}

		if (current_mode == 'completely done') {
			t = '<tr>'
			t +=  "<th style='line-height: 2' onclick='sortTable(0, "+'"simple_table","letters"'+")' title='Click to Sort'>Sort By Status ▾</th>";
			t +=  "<th style='line-height: 2' onclick='sortTable(1, "+'"simple_table","letters"'+")' title='Click to Sort'>Sort Alphabetical ▾</th>";
			t += '</tr>'
		}
		
		// loop through all of the items twice, first doing unknown ones and then doing known ones
		for (showingUnknown = 0; showingUnknown <= 1; showingUnknown++) {
			for (let key in text_obj) { // this loops through all of text_obj
				var t_o = text_obj[key];
				if (t_o.removed || t_o.combine_status != 'done') {
					// if this item has been removed, or it's combine status doesn't equal done, then skip it
				    continue;
				}

				if ((showingUnknown == 0) == (t_o.match_status != 'unknown')) {
					// Doing this means it shows all of the unknown stuff at the top of the table when it's being added to the table. 
					// How it works: showingUnknown = 0 means we are showing the unknown ones. if it's true and 
					// match_status doesn't equal "unknown", or vice versa, then continue. Continue means skip the rest of the loop and advance to i + 1
					continue;
				}
				
				t += '<tr>'
				t += '<td style="vertical-align: top; text-align: center; min-width: 18ex">' //' -webkit-user-select: none; -ms-user-select: none; user-select: none; ">'

				// left column
				if (t_o.match_status == 'unknown') { // unknown
					t += '<div style="border-right:5px solid; border-right-color: white; color: greywolf">searching...</div>'
				}
				else if (t_o.match_status == 'correct') { // correct
					t += '<div style="border-right:5px solid; border-right-color: lawngreen; font-size: 3em; color: lawngreen;">'
					t += '✔'
					t += '</div>'
				} else if (t_o.match_status == 'wrong') { // wrong
					t += '<div style="border-right:5px solid; border-right-color: red; font-size: 3em; color: red;">'
					t += '✘'
					t += '</div>'
				} else { // maybe
					t += '<div style="border-right:5px solid; border-right-color: orange;">'
					var button_value = 'show user input'
					if (t_o.output == t_o.user_input) {
						button_value = 'show search result'
					}
					t += '<div style="color: orange"><p>'+t_o.score+'% match </p>'
					t += '</div>'
                	t += '\
							<select style="border-color: orange" onchange="text_obj[\''+t_o.user_input+'\'].switch_output(this.value);">\
							  <option value="fixed">show search result</option>\
							  <option value="input">show user input</option>\
							  <option value="difs">show differences</option>\
							</select>'
					t += '<br><br>'
					t += '</div>'
				}
				t += '</div></td>'
		
				// right column
				if (t_o.match_status == 'unknown') {
					t += '<td></td>';
				} else {
// 					temp_json = reference_obj[t_o.doi].json
// 					console.log( temp_json)
					t += '<td style="vertical-align: top"><p id = "'+t_o.user_input+'_simple_text" style="margin-left: 5ex; text-indent:-5ex; line-height: 2; margin-bottom: 0; margin-top: 0">'+t_o.output+'</p></td>'; // note: this formatting works well with the clipboard (to paste into word, etc.). It doesn't work if you use a div for some reason.
				}
				t += '</tr>'
			}
		}
		
		document.getElementById('simple_table').innerHTML = t;

        document.getElementById('simple_table').scrollTop = initial_scroll_top;
	}
	
	
	function show_or_hide_burgerBox() {
	    var s = "none"
	    if (document.getElementById("burgerBox").style.display == "none") {
	    	s = "inline-block"
	    }
		document.getElementById("burgerBox").style.display = s
	}

	function show_or_hide_everything(input) {
	    var d = ''
	    
	    if (document.getElementById("refalyzerArticleListBox").style.display == "none" && input != "hide") {
	        d = "block"
	    } else {
            d = "none"	    
	    }
        document.getElementById("buffer_for_copying").style.display = d
        document.getElementById("refalyzerArticleListBox").style.display = d
        document.getElementById("authorTable").style.display = d
        document.getElementById("inputTextBox").style.display = d
        document.getElementById("extra_references").style.display = d
        
                document.getElementById("refalyzerArticleListBox").style.display = "block" // dfdd this is temporary, for debugging purposes
	}
	
	function show_or_hide_authors() {
		if (document.getElementById("authorTable").style.display === "none") {
			document.getElementById("authorTable").style.display = "block";
			document.getElementById("authors_button").innerHTML = "hide author analysis ▴"
			document.getElementById("author_table_instructions").style.display = "inline-block";
		} else {
			document.getElementById("authorTable").style.display = "none";
			document.getElementById("authors_button").innerHTML = "show author analysis ▾"
			document.getElementById("author_table_instructions").style.display = "none";
		}
	}

	  
	function copy_to_clipboard() {
		// This copies text to the clipboard. It stores two versions in the clipboard, plain text and html. 
		
	    var out = ''
        var i = 0;
        
        for (i = 1; i <= document.getElementById('simple_table').rows.length - 1; i++) {
		    out += document.getElementById("simple_table").rows[i].cells[1].innerHTML;
        }
        
        document.getElementById('buffer_for_copying').style = "display:block" // the copy thing doesn't work if this isn't made visible
        document.getElementById('buffer_for_copying').innerHTML = out;

		// below comes (partially) from https://www.nikouusitalo.com/blog/why-isnt-clipboard-write-copying-my-richtext-html/
		const richTextDiv = document.getElementById("buffer_for_copying");

		const clipboardItem = new ClipboardItem({
			"text/plain": new Blob(
				[richTextDiv.innerText],
				{ type: "text/plain" }
			),
			"text/html": new Blob(
				[richTextDiv.outerHTML],
				{ type: "text/html" }
			),
		});

		navigator.clipboard.write([clipboardItem]);

        document.getElementById('buffer_for_copying').style = "display:none"
    }
	
</script>

</head>

<!-- 
Finley, J. R., Tullis, J. G., Benjamin, A. S. (2010). Metacognitive control of learning and remembering. In M. S. Knine I. M. Saleh (Eds.), New Science of Learning (pp. 109– 131). New York, NY: Springer. https://doi.org/10.1007/978-1-4419-5716-0_6	

Fixed-Effects and Random-Effects in Meta-Analysis. (2013). In Applied Meta-Analysis with R (pp. 63–89). Chapman and Hall/CRC. https://doi.org/10.1201/b14872-8

Kuhlmann, B. G., Bayen, U. J. (2016). Metacognitive aspects of source monitoring. In J. Dunlosky S. U. Tauber (Eds.), The Oxford Handbook of Metamemory (pp. 149–168). New York, NY: Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199336746.013.8	

Kuznetsova, A., Brockhoff, P. B., Christensen, R. H. B. (2014). lmerTest: Tests for random and fixed effects for linear mixed effect models (lmer objects of lme4 package) (R package version 2.0-6) [Software]. Retrieved from http://cran.r-project.org/package=lmerTest	

Nelson, T. O., & Narens, L. (1990). Metamemory: A theoretical framework and new findings.

In G. H. Bower (Ed.), The Psychology of Learning and Motivation (Vol. 26, pp. 125–

141). San Diego, CA: Academic Press. https://doi.org/10.1016/S0079-7421(08)60053-5 Nelson, T. O., & Narens, L. (1994). Why investigate metacognition. In J. Metcalfe & A. P.

Shimamura (Eds.), Metacognition: Knowing about Knowing (pp. 1-25). Cambridge, MA:

MIT Press.

Nelson, T. O., Narens, L., & Dunlosky, J. (2004). A revised methodology for research on

metamemory: Pre-judgment recall and monitoring (PRAM). Psychological methods, 9,

53–69. https://doi.org/10.1037/1082-989X.9.1.53

Rhodes, M. G. (2016). Judgments of learning: Methods, data, and theory. In J. Dunlosky S. U. Tauber (Eds.), The Oxford Handbook of Metamemory (pp. 65–80). New York, NY: Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199336746.013.4	

Heck, D. W., Gronau, F. Q., & Wagenmakers &, E.-J. (2019). metaBMA: Bayesian Model

Averaging for Random and Fixed Effects Meta-Analysis. https://CRAN.R-

project.org/package=metaBMA.
 -->

<body onload='show_previous_user_input()'>


<!-- input -->
<div class='wideBoxWithMargin'>
	Cool thing
	<span onclick="show_or_hide_burgerBox()" style="cursor: pointer">
		☰&nbsp 
	</span>
</div>

<!-- just a place to stick information and buttons etc -->

<div class='wideBoxWithMargin' id='burgerBox' style = "display: none">
	<button onclick="show_or_hide_everything()" id="show_everything_button" >show/hide everything</button>
	<button onclick="localStorage.clear()" id="clear_storage_button">clear local storage</button> 
</div>

<div class='wideBoxWithMargin' id = 'inputTextBox'>
	<textarea id="myText" name="inputTextArea" style='width: 100%; '>
	</textarea>
</div>

<!-- simple output -->
<div class='wideBoxWithMargin' id='simpleOutputTable' style="display: none; border: 1px solid grey;" > 
	<div id="simple_table_div">
	</div>
</div>

<!-- progress and summary -->
<div id='progressAndSummaryBox' class='wideBoxWithMargin'>
	<div id='progressText'>
		Paste in the list of references you'd like to fix. 
	</div>
	<div id="myBar" style="display: none;">
	</div>
</div>


<!-- buttons -->
<div class='wideBoxWithMargin' id='buttonBox' "> 
	<button onclick="start()" id="fix_button" class="bigButton">fix</button> 
	<button onclick="copy_to_clipboard()" id="copy_button" class="bigButton" style="display: none">copy</button>
	<p>
</div>

<!-- 	Author table 	-->
<div class='wideBoxWithMargin' id='refalyzerAuthorsBox' style="display: none"> 
	<p>
	<button onclick="show_or_hide_authors()" id="authors_button" style="display: none">show author analysis ▾</button>
	<div id="author_table_instructions" style="display: none">Select an author to highlight their co-authors.</div>
	<p>
	<div id='authorTable' class='dataTable'></div>
</div>

<!-- empty space at the bottom of the screen -->
<div id='empty' class='wideBoxWithMargin' style="height: 10em;"> 
</div>


<!-- div where output is displayed so that it can be copied (and then it's hidden again) -->
<div id="buffer_for_copying">
</div>

<!-- 	Article table 	-->
<div class='boxAroundTable' id='refalyzerArticleListBox' style="display: none">
	<div id='articleTable' class='dataTable'></div>
</div>


<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- -->


<div id="extra_references" style="display: none">
    <p>Lamb, K. N., Jolly, J. L., & Lakin, J. M. (2022). Asset-based decision making to address inequity in gifted education services. Gifted Child Quarterly, 66(2), 113–115. https://doi-org.ezproxy2.williams.edu/10.1177/00169862211042910
    <p>Besken, M. (2016). Picture-perfect is not perfect for metamemory: Testing the perceptual fluency hypothesis with degraded images. Journal of Experimental Psychology: Learning, Memory, and Cognition, 42, 1417–1433. https://doi.org/10.1037/xlm0000246
    <p>Besken, M., & Mulligan, N. W. (2013). Easily perceived, easily remembered? Perceptual interference produces a double dissociation between metamemory and memory performance. Memory & Cognition, 41, 897–903. https://doi.org/10.3758/s13421-013-0307-8
    <p>Besken, M., & Mulligan, N. W. (2014). Perceptual fluency, auditory generation, and
    metamemory: Analyzing the perceptual fluency hypothesis in the auditory modality. Journal of Experimental Psychology: Learning, Memory, and Cognition, 40, 429–440. https://doi.org/10.1037/a0034407

    <p>Bröder, A., & Meiser, T. (2007). Measuring source memory. Zeitschrift für Psychologie/Journal of Psychology, 215, 52–60. https://doi.org/10.1027/0044- 3409.215.1.52
    <p>Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL effect”. Memory, 26, 771–783. https://doi.org/10.1080/09658211.2017.1406523
    <p>Carroll, M., Mazzoni, G., Andrews, S., & Pocock, P. (1999). Monitoring the future: Object and source memory for real and imagined events. Applied Cognitive Psychology, 13, 373–390. https://doi.org/10.1002/(SICI)1099-0720(199908)13:4<373::AID- ACP605>3.0.CO;2-F
    <p>Dodson, C. S., Darragh, J., & Williams, A. (2008). Stereotypes and retrieval-provoked illusory source recollections. Journal of Experimental Psychology: Learning, Memory, and Cognition, 34, 460–477. https://doi.org/10.1037/0278-7393.34.3.460
    <p>Dougherty, M. R., Scheck, P., Nelson, T. O., & Narens, L. (2005). Using the past to predict the future. Memory & Cognition, 33, 1096–1115. https://doi.org/10.3758/BF03193216
    <p>Dunlosky, J., & Hertzog, C. (2000). Updating knowledge about encoding strategies: A componential analysis of learning about strategy effectiveness from task experience. Psychology and Aging, 15, 462–474. https://doi.org/10.1037//0882-7974.15.3.462
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 53
    <p>Dunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20, 374–380. https://doi.org/10.3758/BF03210921
    <p>Dunlosky, J., & Nelson, T. O. (1994). Does the sensitivity of judgements of learning (JOLs) to the effects of various study activities depend on when the JOLs occur? Journal of Memory and Language, 33, 545–565. https://doi.org/10.1006/jmla.1994.1026
    <p>Dunlosky, J., & Nelson, T. O. (1997). Similarity between the cue for judgments of learning (JOL) and the cue for test is not the primary determinant of JOL accuracy. Journal of Memory and Language, 36, 34–49. https://doi.org/10.1006/jmla.1996.2476
    <p>Ehrenberg, K., & Klauer, K. C. (2005). Flexible use of source information: Processing components of the inconsistency effect in person memory. Journal of Experimental Social Psychology, 41, 369–387. https://doi.org/10.1016/j.jesp.2004.08.001
    <p>England, B. D., & Serra, M. J. (2012). The contributions of anchoring and past-test performance to the underconfidence-with-practice effect. Psychonomic Bulletin & Review, 19, 715–722. https://doi.org/10.3758/s13423-012-0237-7
    <p>Erdfelder, E., Auer, T.-S., Hilbig, B. E., Aßfalg, A., Moshagen, M., & Nadarevic, L. (2009). Multinomial processing tree models: A review of the literature. Zeitschrift für Psychologie/Journal of Psychology, 217, 108–124. https://doi.org/10.1027/0044- 3409.217.3.108
    <p>Erdfelder, E., & Bredenkamp, J. (1998). Recognition of script-typical versus script-atypical information: Effects of cognitive elaboration. Memory & Cognition, 26, 922–938. https://doi.org/10.3758/BF03201173
    <p>Finley, J. R., Tullis, J. G., & Benjamin, A. S. (2010). Metacognitive control of learning and remembering. In M. S. Knine & I. M. Saleh (Eds.), New Science of Learning (pp. 109– 131). New York, NY: Springer. https://doi.org/10.1007/978-1-4419-5716-0_6
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 54
    <p>Finn, B., & Metcalfe, J. (2007). The role of memory for past test in the underconfidence with practice effect. Journal of Experimental Psychology: Learning, Memory, and Cognition, 33, 238–244. https://doi.org/10.1037/0278-7393.33.1.238
    <p>Finn, B., & Metcalfe, J. (2008). Judgments of learning are influenced by memory for past test. Journal of Memory and Language, 58, 19–34. https://doi.org/10.1016/j.jml.2007.03.006
    <p>Frank, D. J., & Kuhlmann, B. G. (2017). More than just beliefs: Experience and beliefs jointly contribute to volume effects on metacognitive judgments. Journal of Experimental Psychology: Learning, Memory, and Cognition, 43, 680–693. https://doi.org/10.1037/xlm0000332
    <p>Friedman, A. (1979). Framing pictures: The role of knowledge in automatized encoding and memory for gist. Journal of Experimental Psychology: General, 108, 316–355. https://doi.org/10.1037/0096-3445.108.3.316
    <p>Gelman, A., & Rubin, D. B. (1992). Inference from iterative simulation using multiple sequences. Statistical Science, 7, 457–472. http://dx.doi.org/10.1214/ss/1177011136
    <p>Gronau, Q. F., Heck, D. W., Berkhout, S. W., Haaf, J. M., & Wagenmakers, E. (2020, April 24). A Primer on Bayesian Model-Averaged Meta-Analysis. https://doi.org/10.31234/osf.io/97qup
    <p>Gronau, Q. F., Van Erp, S., Heck, D. W., Cesario, J., Jonas, K. J., & Wagenmakers, E. J. (2017). A Bayesian model-averaged meta-analysis of the power pose effect with informed and default priors: The case of felt power. Comprehensive Results in Social Psychology, 2, 123–138. https://doi.org/10.1080/23743603.2017.1326760
    <p>Hechler, S., Neyer, F. J., & Kessler, T. (2016). The infamous among us: Enhanced reputational memory for uncooperative ingroup members. Cognition, 157, 1–13. https://doi.org/10.1016/j.cognition.2016.08.001
    <p>Heck, D. W., Arnold, N. R., & Arnold, D. (2018). TreeBUGS: An R package for hierarchical multinomial-processing-tree modeling. Behavior Research Methods, 50, 264–284.
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 55
    <p>https://doi.org/ 10.3758/s13428-017-0869-7
    <p>Heck, D. W., Gronau, F. Q., & Wagenmakers &, E.-J. (2019). metaBMA: Bayesian Model
    <p>Averaging for Random and Fixed Effects Meta-Analysis. https://CRAN.R-
    <p>project.org/package=metaBMA.
    <p>Henkel, L. A., Johnson, M. K., & De Leonardis, D. M. (1998). Aging and source monitoring:
    <p>Cognitive processes and neuropsychological correlates. Journal of Experimental
    <p>Psychology: General, 127, 251–268. https://doi.org/10.1037/0096-3445.127.3.251 Hicks, J. L., & Cockman, D. W. (2003). The effect of general knowledge on source memory
    <p>and decision processes. Journal of Memory and Language, 48, 489–501.
    <p>https://doi.org/10.1016/S0749-596X(02)00537-5
    <p>Johnson, M. K., Hashtroudi, S., & Lindsay, D. S. (1993). Source monitoring. Psychological
    <p>Bulletin, 114, 3–28. https://doi.org/10.1037/0033-2909.114.1.3
    <p>Johnson, M. K., Kounios, J., & Reeder, J. A. (1994). Time-course studies of reality
    <p>monitoring and recognition. Journal of Experimental Psychology: Learning, Memory,
    <p>and Cognition, 20, 1409–1419. https://doi.org/10.1037/0278-7393.20.6.1409
    <p>Kelemen, W. L. (2000). Metamemory cues and monitoring accuracy: Judging what you know
    <p>and what you will know. Journal of Educational Psychology, 92, 800–810.
    <p>https://doi.org/10.1037/0022-0663.92.4.800
    <p>Kelemen, W. L., & Weaver, C. A. III (1997). Enhanced memory at delays: Why do judgments
    <p>of learning improve over time? Journal of Experimental Psychology: Learning, Memory,
    <p>and Cognition, 23(6), 1394–1409. https://doi.org/10.1037/0278-7393.23.6.1394 Kelley, C. M., & Jacoby, L. L. (1996). Adult egocentrism: Subjective experience versus
    <p>analytic bases for judgment. Journal of Memory and Language, 35, 157–175.
    <p>https://doi.org/10.1006/jmla.1996.0009
    <p>Kenny, D. A., Korchmaros, J. D., & Bolger, N. (2003). Lower level mediation in multilevel
    <p>models. Psychological Methods, 8, 115–128. https://doi.org/10.1037/1082-989X.8.2.115

    <p>
    DELAYED JUDGMENTS IN SOURCE MONITORING 56
    <p>Kimball, D. R., & Metcalfe, J. (2003). Delaying judgments of learning affects memory, not metamemory. Memory & Cognition, 31, 918–929. https://doi.org/10.3758/BF03196445
    <p>Kimball, D. R., Smith, T. A., & Muntean, W. J. (2012). Does delaying judgments of learning really improve the efficacy of study decisions? Not so much. Journal of Experimental Psychology: Learning, Memory, and Cognition, 38, 923–954. https://doi.org/10.1037/a0026936
    <p>King, J. F., Zechmeister, E. B., & Shaughnessy, J. J. (1980). Judgments of knowing: The influence of retrieval practice. The American Journal of Psychology, 329–343. https://doi.org/10.2307/1422236
    <p>Klauer, K. C. (2010). Hierarchical multinomial processing tree models: A latent-trait approach. Psychometrika, 75, 70–98. doi: 10.1007/S11336-009-9141-0
    <p>Konopka, A. E., & Benjamin, A. S. (2009). Schematic knowledge changes what judgments of learning predict in a source memory task. Memory & Cognition, 37, 42–51. https://doi.org/10.3758/MC.37.1.42
    <p>Koriat, A. (1997). Monitoring one’s own knowledge during study: A cue-utilization approach to judgments of learning. Journal of Experimental Psychology: General, 126, 349–370. https://doi.org/10.1037/0096-3445.126.4.349
    <p>Koriat, A., & Bjork, R. A. (2006a). Illusions of competence during study can be remedied by manipulations that enhance learners’ sensitivity to retrieval conditions at test. Memory & Cognition, 34, 959–972. https://doi.org/10.3758/BF03193244
    <p>Koriat, A., & Bjork, R. A. (2006b). Mending metacognitive illusions: A comparison of mnemonic-based and theory-based procedures. Journal of Experimental Psychology: Learning, Memory, and Cognition, 32, 1133–1145. https://doi.org/10.1037/0278- 7393.32.5.1133
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 57
    <p>Koriat, A., & Ma’ayan, H. (2005). The effects of encoding fluency and retrieval fluency on judgments of learning. Journal of memory and Language, 52, 478–492. https://doi.org/10.1016/j.jml.2005.01.001
    <p>Kornell, N., & Bjork, R. A. (2008). Optimising self-regulated study: The benefits—and costs—of dropping flashcards. Memory, 16, 125–136. https://doi.org/10.1080/09658210701763899
    <p>Kranz, D., Nadarevic, L., & Erdfelder, E. (2019). Bald and bad? Experimental evidence for a dual-process account of baldness stereotyping. Experimental Psychology, 66, 331– 345. https://doi.org/10.1027/1618-3169/a000457
    <p>Kroneisen, M., & Bell, R. (2013). Sex, cheating, and disgust: Enhanced source memory for trait information that violates gender stereotypes. Memory, 21, 167–181. https://doi.org/10.1080/09658211.2012.713971
    <p>Kroneisen, M., Woehe, L., & Rausch, L. S. (2015). Expectancy effects in source memory: How moving to a bad neighborhood can change your memory. Psychonomic Bulletin & Review, 22, 179–189. https://doi.org/10.3758/s13423-014-0655-9
    <p>Krull, J. L., & Mackinnon, D. P. (2001). Multilevel modeling of individual and group level mediated effects. Multivariate Behavioral Research, 36, 249–277. https://doi.org/10.1207/S15327906MBR3602
    <p>Kuhlmann, B. G., & Bayen, U. J. (2016). Metacognitive aspects of source monitoring. In J. Dunlosky & S. U. Tauber (Eds.), The Oxford Handbook of Metamemory (pp. 149–168). New York, NY: Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199336746.013.8
    <p>Kuhlmann, B. G., & Touron, D. R. (2011). Older adults’ use of metacognitive knowledge in source monitoring: Spared monitoring but impaired control. Psychology and Aging, 26, 143–149. https://doi.org/ 10.1037/a0021055
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 58
    <p>Kuhlmann, B. G., Vaterrodt, B., & Bayen, U. J. (2012). Schema bias in source monitoring varies with encoding conditions: Support for a probability-matching account. Journal of Experimental Psychology: Learning, Memory, and Cognition, 38, 1365–1376. https://doi.org/10.1037/a0028147
    <p>Küppers, V., & Bayen, U. J. (2014). Inconsistency effects in source memory and compensatory schema-consistent guessing. The Quarterly Journal of Experimental Psychology, 67, 2042–2059. https://doi.org/10.1080/17470218.2014.904914
    <p>Kuznetsova, A., Brockhoff, P. B., & Christensen, R. H. B. (2014). lmerTest: Tests for random and fixed effects for linear mixed effect models (lmer objects of lme4 package) (R package version 2.0-6) [Software]. Retrieved from http://cran.r- project.org/package=lmerTest
    <p>Loftus, G. R., & Mackworth, N. H. (1978). Cognitive determinants of fixation location during picture viewing. Journal of Experimental Psychology: Human Perception and Performance, 4, 565–572. https://doi.org/10.1037/0096-1523.4.4.565
    <p>Loftus, G. R., & Masson, M. E. J. (1994). Using confidence intervals in within-subject designs. Psychonomic Bulletin & Review, 1, 476–490. https://doi.org/10.3758/BF03210951
    <p>Luna, K., Martín-Luengo, B., & Albuquerque, P. B. (2018). Do delayed judgements of learning reduce metamemory illusions? A meta-analysis. Quarterly Journal of Experimental Psychology, 71(7), 1626-1636. https://doi.org/10.1080/17470218.2017.1343362
    <p>Marsh, R., Cook, G., & Hicks, J. L. (2006). Gender and orientation stereotypes bias source- monitoring attributions. Memory, 14, 148–160. https://doi.org/10.1080/09658210544000015
    <p>Mather, M., Johnson, M. K., & De Leonardis, D. M. (1999). Stereotype reliance in source monitoring: Age differences and neuropsychological test correlates. Cognitive
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 59
    <p>Neuropsychology, 16, 437–458. https://doi.org/10.1080/026432999380870
    <p>Meeter, M., & Nelson, T. O. (2003). Multiple study trials and judgments of learning. Acta
    <p>Psychologica, 113, 123–132. https://doi.org/10.1016/S0001-6918(03)00023-4 Meiser, T., & Hewstone, M. (2001). Crossed categorization effects on the formation of
    <p>illusory correlations. European Journal of Social Psychology, 31, 443–466.
    <p>https://doi.org/10.1002/ejsp.55
    <p>Meiser, T., Sattler, C., & Von Hecker, U. (2007). Metacognitive inferences in source memory
    <p>judgements: The role of perceived differences in item recognition. Quarterly Journal of
    <p>Experimental Psychology, 60, 1015–1040. https://doi.org/10.1080/17470210600875215 Metcalfe, J. (2009). Metacognitive judgments and control of study. Current Directions in
    <p>Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x Metcalfe, J., & Finn, B. (2008). Evidence that judgments of learning are causally related to
    <p>study choice. Psychonomic Bulletin & Review, 15, 174–179.
    <p>https://doi.org/10.3758/PBR.15.1.174
    <p>Mieth, L., Bell, R., & Buchner, A. (2016). Facial likability and smiling enhance cooperation,
    <p>but have no direct effect on moralistic punishment. Experimental Psychology, 63, 263–
    <p>277. http://dx.doi.org/10.1027/1618-3169/a000338
    <p>Mieth, L., Schaper, M. L., Kuhlmann, B. G., & Bell, R. (2020). Memory and metamemory for
    <p>social interactions: Evidence for a metamemory expectancy illusion. Memory &
    <p>Cognition, 49, 14–31. https://doi.org/10.3758/s13421-020-01071-z
    <p>Misirlisoy, M., Tanyas, H., & Atalay, N. B. (2019). Does survival context enhance memory
    <p>for source? A within-subjects comparison. Memory, 27, 780–791.
    <p>https://doi.org/10.1080/09658211.2019.1566928
    <p>Mitchum, A. L., Kelley, C. M., & Fox, M. C. (2016). When asking the question changes the
    <p>ultimate answer: Metamemory judgments change memory. Journal of Experimental Psychology: General, 145, 200–219. http://doi.org/10.1037/a0039923
    <p>
    <p>Mueller, M. L., & Dunlosky, J. (2017). How beliefs can impact judgments of learning: Evaluating analytic processing theory with beliefs about fluency. Journal of Memory and Language, 93, 245–258. https://doi.org/10.1016/j.jml.2016.10.008
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 60
    <p>Mueller, M. L., Dunlosky, J., & Tauber, S. K. (2016). The effect of identical word pairs on people’s metamemory judgments: What are the contributions of processing fluency and beliefs about memory? The Quarterly Journal of Experimental Psychology, 69, 781–799. https://doi.org/10.1080/17470218.2015.1058404
    <p>Mueller, M. L., Dunlosky, J., Tauber, S. K., & Rhodes, M. G. (2014). The font-size effect on judgments of learning: Does it exemplify fluency effects or reflect people’s beliefs about memory? Journal of Memory and Language, 70, 1–12. https://doi.org/10.1016/j.jml.2013.09.007
    <p>Mueller, M. L., Tauber, S. K., & Dunlosky, J. (2013). Contributions of beliefs and processing fluency to the effect of relatedness on judgments of learning. Psychonomic Bulletin & Review, 20, 378–384. https://doi.org/10.3758/s13423-012-0343-6
    <p>Murnane, K., & Bayen, U. J. (1996). An evaluation of empirical measures of source identification. Memory and Cognition, 24, 417–428. https://doi.org/10.3758/BF03200931
    <p>Murnane, K., & Bayen, U. J. (1998). Measuring memory for source: Some theoretical assumptions and technical limitations. Memory & Cognition, 26, 674–677. https://doi.org/10.3758/BF03211387
    <p>Nelson, T. O., & Dunlosky, J. (1991). When people's judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: The “delayed-JOL effect”. Psychological Science, 2, 267–271. https://doi.org/10.1111/j.1467-9280.1991.tb00147.x
    <p>Nelson, T. O., Dunlosky, J., Graf, A., & Narens, L. (1994). Utilization of metacognitive judgments in the allocation of study during multitrial learning. Psychological Science, 5, 207–213. https://doi.org/10.1111/j.1467-9280.1994.tb00502.x
    <p>Nelson, T. O., & Narens, L. (1990). Metamemory: A theoretical framework and new findings.
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 61
    <p>In G. H. Bower (Ed.), The Psychology of Learning and Motivation (Vol. 26, pp. 125–
    <p>141). San Diego, CA: Academic Press. https://doi.org/10.1016/S0079-7421(08)60053-5 Nelson, T. O., & Narens, L. (1994). Why investigate metacognition. In J. Metcalfe & A. P.
    <p>Shimamura (Eds.), Metacognition: Knowing about Knowing (pp. 1-25). Cambridge, MA:
    <p>MIT Press.
    <p>Nelson, T. O., Narens, L., & Dunlosky, J. (2004). A revised methodology for research on
    <p>metamemory: Pre-judgment recall and monitoring (PRAM). Psychological methods, 9,
    <p>53–69. https://doi.org/10.1037/1082-989X.9.1.53
    <p>Nieznański, M. (2014a). Context reinstatement and memory for intrinsic versus extrinsic
    <p>context: The role of item generation at encoding or retrieval. Scandinavian Journal of
    <p>Psychology, 55, 409–419. https://doi.org/10.1111/sjop.12153
    <p>Nieznański, M. (2014b). The role of reinstating generation operations in recognition memory
    <p>and reality monitoring. Polish Psychological Bulletin, 45, 363–371. https://doi.org/10.2478/ppb-2014-0044
    <p> Pyc, M. A., Rawson, K. A., & Aschenbrenner, A. J. (2014). Metacognitive monitoring during criterion learning: When and why are judgments accurate? Memory & Cognition, 42(6), 886–897. https://doi.org/10.3758/s13421-014-0403-4
    <p>Raftery, A. E. (1995). Bayesian model selection in social research. Sociological Methodology, 25, 111–163. https://doi.org/10.2307/271063
    <p>R Core Team (2020). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.
    <p>Rhodes, M. G. (2016). Judgments of learning: Methods, data, and theory. In J. Dunlosky & S. U. Tauber (Eds.), The Oxford Handbook of Metamemory (pp. 65–80). New York, NY: Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199336746.013.4
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 62
    <p>Rhodes, M. G., & Tauber, S. K. (2011). The influence of delaying judgments of learning on metacognitive accuracy: A meta-analytic review. Psychological Bulletin, 137(1), 131– 148. https://doi.org/10.1037/a0021705
    <p>Robey, A. M., Dougherty, M. R., & Buttaccio, D. R. (2017). Making retrospective confidence judgments improves learners’ ability to decide what not to study. Psychological Science, 28, 1683–1893. https://doi.org/10.1177/0956797617718800
    <p>Schaper, M. L., & Bayen, U. J. (2021). The metamemory expectancy illusion in source monitoring affects metamemory control and memory. Cognition, 206, 104468. https://doi.org/10.1016/j.cognition.2020.104468
    <p>Schaper, M. L., Kuhlmann, B. G., & Bayen, U. J. (2019a). Metamemory expectancy illusion and schema-consistent guessing in source monitoring. Journal of Experimental Psychology: Learning, Memory, and Cognition. 45, 470-496. https://doi.org/10.1037/xlm0000602
    <p>Schaper, M. L., Kuhlmann, B. G., & Bayen, U. J. (2019b). Metacognitive expectancy effects in source monitoring: Beliefs, in-the-moment experiences, or both? Journal of Memory and Language, 107, 95-110. https://doi.org/10.1016/j.jml.2019.03.009
    <p>Serra, M. J., & Ariel, R. (2014). People use the memory for past-test heuristic as an explicit cue for judgments of learning. Memory & Cognition, 42, 1260–1272. https://doi.org/10.3758/s13421-014-0431-0
    <p>Sherman, J. W., & Bessenoff, G. R. (1999). Stereotypes as source-monitoring cues: On the interaction between episodic and semantic memory. Psychological Science, 10, 106–110. https://doi.org/10.1111/1467-9280.00116
    <p>Sherman, J. W., Lee, A. Y., Bessenoff, G. R., & Frost, L. A. (1998). Stereotype efficiency reconsidered: Encoding flexibility under cognitive load. Journal of Personality and Social Psychology, 75, 589–606. https://doi.org/0.1037/0022-3514.75.3.589
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 63
    <p>Shi, L.-Z., Tang, W.-H., & Liu, X.-P. (2012). Age-related schema reliance of judgments of learning in predicting source memory. Aging, Neuropsychology, and Cognition, 19, 301– 318. https://doi.org/10.1080/13825585.2011.632616
    <p>Smith, J. B., & Batchelder, W. H. (2010). Beta-MPT: Multinomial processing tree models for addressing individual differences. Journal of Mathematical Psychology, 54, 167–183. https://doi.org/10.1016/j.jmp.2009.06.007
    <p>Soderstrom, N. C., Clark, C. T., Halamish, V., & Bjork, E. L. (2015). Judgments of learning as memory modifiers. Journal of Experimental Psychology: Learning, Memory, and Cognition, 41, 553–558. https://doi.org/10.1037/a0038388
    <p>Spaniol, J., & Bayen, U. J. (2002). When is schematic knowledge used in source monitoring? Journal of Experimental Psychology: Learning, Memory, and Cognition, 28, 631–651. https://doi.org/10.1037/0278-7393.28.4.631
    <p>Starns, J. J., & Hicks, J. L. (2013). Internal reinstatement hides cuing effects in source memory tasks. Memory & Cognition, 41, 953–966. https://doi.org/10.3758/s13421-013- 0325-6
    <p>Susser, J. A., Mulligan, N. W., & Besken, M. (2013). The effects of list composition and perceptual fluency on judgments of learning (JOLs). Memory & Cognition, 41, 1000– 1011. https://doi.org/10.3758/s13421-013-0323-8
    <p>Tauber, S. K., & Rhodes, M. G. (2012). Multiple bases for young and older adults' judgments of learning in multitrial learning. Psychology and Aging, 27, 474–-483. https://doi.org/10.1037/a0025246
    <p>Thiede, K. W., Anderson, M., & Therriault, D. (2003). Accuracy of metacognitive monitoring affects learning of texts. Journal of Educational Psychology, 95, 66–73. https://doi.org/10.1037/0022-0663.95.1.66
    <p>Tullis, J. G., & Benjamin, A. S. (2011). On the effectiveness of self-paced learning. Journal of Memory and Language, 64, 109–118. https://doi.org/10.1016/j.jml.2010.11.002
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 64
    <p>Tullis, J. G., Finley, J. R., & Benjamin, A. S. (2013). Metacognition of the testing effect: Guiding learners to predict the benefits of retrieval. Memory & Cognition, 41, 429–442. https://doi.org/10.3758/s13421-012-0274-5
    <p>Undorf, M., & Erdfelder, E. (2011). Judgments of learning reflect encoding fluency: Conclusive evidence for the ease-of-processing hypothesis. Journal of Experimental Psychology: Learning, Memory, and Cognition, 37, 1264–1269. https://doi.org/10.1037/a0023719
    <p>Undorf, M., & Erdfelder, E. (2013). Separation of encoding fluency and item difficulty effects on judgements of learning. Quarterly Journal of Experimental Psychology, 66, 2060– 2072. https://doi.org/10.1080/17470218.2013.777751
    <p>Undorf, M., & Erdfelder, E. (2015). The relatedness effect on judgments of learning: A closer look at the contribution of processing fluency. Memory & Cognition, 43, 647–658. https://doi.org/10.3758/s13421-014-0479-x
    <p>Van Overschelde, J. P., & Nelson, T. O. (2006). Delayed judgments of learning cause both a decrease in absolute accuracy (calibration) and an increase in relative accuracy (resolution). Memory & cognition, 34, 1527–1538. https://doi.org/10.3758/BF03195916
    <p>Vesonder, G. T., & Voss, J. F. (1985). On the ability to predict one's own responses while learning. Journal of Memory and Language, 24, 363–376. https://doi.org/10.1016/0749- 596X(85)90034-8
    <p>Weaver, C. A. III, & Kelemen, W. L. (1997). Judgments of learning at delays: Shifts in response patterns or increased metamemory accuracy? Psychological Science, 8, 318– 321. https://doi.org/10.1111/j.1467-9280.1997.tb00445.x
    <p>Wulff, L., & Kuhlmann, B. G. (2020). Is knowledge reliance in source guessing a cognitive trait? Examining stability across time and domain. Memory & Cognition, 48, 256–276. https://doi.org/10.3758/s13421-019-01008-1
    <p>
    <p>DELAYED JUDGMENTS IN SOURCE MONITORING 65
    <p>Yan, V. X., Bjork, E. L., & Bjork, R. A. (2016). On the difficulty of mending metacognitive illusions: A priori theories, fluency effects, and misattributions of the interleaving benefit. Journal of Experimental Psychology: General, 145, 918–933. https://doi.org/10.1037/xge0000177
    <p>Yang, C., Potts, R., & Shanks, D. R. (2017). Metacognitive unawareness of the errorful generation benefit and its effects on self-regulated learning. Journal of Experimental Psychology: Learning, Memory, and Cognition, 43, 1073–1092. https://doi.org/10.1037/xlm0000363
    <p>Zechmeister, E. B., & Shaughnessy, J. J. (1980). When you know that you know and when you think that you know but you don’t. Bulletin of the Psychonomic Society, 15, 41–44. https://doi.org/10.3758/BF03329756
    <p>Zhang, Y., Pan, Z., Li, K., & Guo, Y. (2018). Self-serving bias in memories: Selectively forgetting the connection between negative information and the self. Experimental Psychology, 65, 236–244. http://dx.doi.org/10.1027/1618-3169/a000409
</div>
</body>
</html>

<!-- from bjork dunlosky kornell -->
<!-- 
Benjamin AS, Bjork RA. 1996. Retrieval fluency as a metacognitive index. In Implicit Memory and Metacognition, ed. LM Reder, pp. 309–38. Mahwah, NJ: Erlbaum
Benjamin AS, Bjork RA, Schwartz BL. 1998. The mismeasure of memory: when retrieval fluency is misleading as a metamnemonic index. J. Exp. Psychol.: Gen. 127:55–68
Bjork EL, Bjork RA. 2011. Making things hard on yourself, but in a good way: creating desirable difficulties to enhance learning. In Psychology and the Real World: Essays Illustrating Fundamental Contributions to Society, ed. MA Gernsbacher, RW Pew, LM Hough, JR Pomerantz, pp. 56–64. New York: Worth
Bjork RA. 1975. Retrieval as a memory modifier. In Information Processing and Cognition: The Loyola Symposium, ed. R Solso, pp. 123–44. Hillsdale, NJ: Erlbaum
Bjork RA. 1994. Memory and metamemory considerations in the training of human beings. In Metacognition: Knowing About Knowing, ed. J Metcalfe, A Shimamura, pp. 185–205. Cambridge, MA: MIT Press
Bjork RA. 2011. On the symbiosis of remembering, forgetting and learning. In Successful Remembering and Successful Forgetting: A Festschrift in Honor of Robert A. Bjork, ed. AS Benjamin, pp. 1–22. London: Psychol. Press
Bjork RA, Bjork EL. 1992. A new theory of disuse and an old theory of stimulus fluctuation. In From Learning Processes to Cognitive Processes: Essays in Honor of William K. Estes, ed. A Healy, S Kosslyn, R Shiffrin, vol. 2, pp. 35–67. Hillsdale, NJ: Erlbaum
Butler AC, Fazio LK, Marsh EJ. 2011. The hypercorrection effect persists over a week, but high-confidence errors return. Psychon. Bull. Rev. 18:1238–44
Butterfield B, Metcalfe J. 2001. Errors committed with high confidence are hypercorrected. J. Exp. Psychol.: Learn. Mem. Cogn. 27:1491–94
Carpenter SK. 2011. Semantic information activated during retrieval contributes to later retention: support for the mediator effectiveness hypothesis of the testing effect. J. Exp. Psychol.: Learn. Mem. Cogn. 37:1547–52 Castel AD, McCabe DP, Roediger H. 2007. Illusions of competence and overestimation of associative memory
for identical items: evidence from judgments of learning. Psychon. Bull. Rev. 14:107–11
Cepeda NJ, Pashler H, Vul E, Wixted JT, Rohrer D. 2006. Distributed practice in verbal recall tasks: a review
and quantitative synthesis. Psychol. Bull. 132:354–80
Cohen MS, Halamish V, Bjork RA. 2011. Learners fail to appreciate benefits of longer spacings over shorter spacings
in repeated practice. Poster presented at Annu. Meet. Psychon. Soc., 52nd, Seattle, Wash.
Crede ́ M, Phillips L. 2011. A meta-analytic review of the motivated strategies for learning questionnaire.
Learn. Individ. Differ. 21:337–46
Dempster FN. 1996. Distributing and managing the conditions of encoding and practice. In Memory, ed. R
Bjork, E Bjork, pp. 317–44. San Diego, CA: Academic
Diemand-Yauman C, Oppenheimer DM, Vaughan EB. 2011. Fortune favors the bold (and the italicized):
effects of disfluency on educational outcomes. Cognition 118:114–18
Duffy GG, Miller S, Parsons S, Meloth M. 2009. Teachers as metacogntive professionals. In Handbook of
Metacognition in Education, ed. DJ Hacker, J Dunlosky, AC Graesser, pp. 240–56. New York: Taylor &
Francis
Dunlosky J, Ariel R. 2011a. Self-regulated learning and the allocation of study time. In The Psychology of
Learning and Motivation: Advances in Research and Theory, vol. 54, ed. BH Ross, pp. 103–40. San Diego,
CA: Elsevier
Dunlosky J, Ariel R. 2011b. The influence of agenda-based and habitual processes on item selection during
study. J. Exp. Psychol.: Learn. Mem. Cogn. 37:899–912
Dunlosky J, Lipko A. 2007. Metacomprehension: a brief history and how to improve its accuracy. Curr. Dir.
Psychol. Sci. 16:228–32
Dunlosky J, Nelson TO. 1992. Importance of the kind of cue for judgments of learning ( JOL) and the delayed
JOL effect. Mem. Cogn. 20:374–80
Dunlosky J, Nelson TO. 1994. Does the sensitivity of judgments of learning ( JOLs) to the effects of various
study activities depend on when the JOLs occur? J. Mem. Lang. 33:545–65
Dunlosky J, Rawson KA. 2012. Overconfidence produces underachievement: inaccurate self evaluations un-
dermine students’ learning and retention. Learn. Instr. 22:271–80
Dunlosky J, Rawson KA, Marsh EJ, Nathan MJ, Willingham DT. 2012. Improving students’ learning with effective learning techniques: promising directions from cognitive and educational psychology. Psychol. Sci. Public Interest. In press
Dunlosky J, Serra M, Baker JMC. 2007. Metamemory applied. In Handbook of Applied Cognition, ed. FT Durso, RS Nickerson, ST Dumais, S Lewandowsky, TJ Perfect, pp. 137–59. New York: Wiley. 2nd ed.
Dunlosky J, Thiede KW. 1998. What makes people study more? An evaluation of factors that affect people’s self-paced study and yield “labor-and-gain” effects. Acta Psychol. 98:37–56
Dweck CS. 2006. Mindset. New York: Random House
Finn B, Metcalfe J. 2007. The role of memory for past test in the underconfidence with practice effect. J. Exp.
Psychol.: Learn. Mem. Cogn. 33:238–44
Finn B, Metcalfe J. 2008. Judgments of learning are influenced by memory for past test. J. Mem. Lang. 58:19–34 Fischhoff B. 1975. Hindsight is not equal to foresight: the effects of outcome knowledge on judgment under
uncertainty. J. Exp. Psychol.: Hum. Percept. Perform. 1:288–99
Fritz CO, Morris PE, Bjork RA, Gelman R, Wickens TD. 2000. When further learning fails: stability and
change following repeated presentation of text. Br. J. Psychol. 91:493–511
Grimaldi PJ, Karpicke JD. 2012. When and why do retrieval attempts enhance subsequent encoding? Mem.
Cogn. 40:505–13
Gurung RAR, Weidert J, Jeske A. 2010. Focusing on how students study. J. Scholars. Teach. Learn. 10:28–35 Halamish V, Bjork RA. 2011. When does testing enhance retention? A distribution-based interpretation of
retrieval as a memory modifier. J. Exp. Psychol.: Learn. Mem. Cogn. 37:801–12
Hart JT. 1965. Memory and the feeling-of-knowing experience. J. Educ. Psychol. 56:208–16
Hartwig MK, Dunlosky J. 2012. Study strategies of college students: Are self-testing and scheduling related
to achievement? Psychon. Bull. Rev. 19:126–34
Hays M, Kornell N, Bjork RA. 2012. When and why a failed test potentiates the effectiveness of subsequent
study. J. Exp. Psychol: Learn. Mem. Cogn. In press
Hertzog C, Dunlosky J, Robinson AE, Kidder DP. 2003. Encoding fluency is a cue used for judgments about
learning. J. Exp. Psychol: Learn. Mem. Cogn. 29:22–34
Huelser BJ, Metcalfe J. 2012. Making related errors facilitates learning, but learners do not know it. Mem.
Cogn. 40:514–27
Jacoby LL. 1978. On interpreting the effects of repetition: solving a problem versus remembering a solution.
J. Verbal Learn. Verbal Behav. 17:649–67
Jacoby LL, Kelley CM. 1987. Unconscious influences of memory for a prior event. Pers. Soc. Psychol. Bull.
13:314–36
Jacoby LL, Kelley CM, Dywan J. 1989. Memory attributions. In Varieties of Memory and Consciousness: Essays
in Honour of Endel Tulving, ed. H Roediger, FM Craik, pp. 391–422. Hillsdale, NJ: Erlbaum
Kang SK, Pashler H. 2012. Learning painting styles: spacing is advantageous when it promotes discriminative
contrast. Appl. Cogn. Psychol. 26:97–103
Karpicke JD. 2009. Metacognitive control and strategy selection: deciding to practice retrieval during learning.
J. Exp. Psychol.: Gen. 138:469–86
Karpicke JD, Butler AC, Roediger H. 2009. Metacognitive strategies in student learning: Do students practise
retrieval when they study on their own? Memory 17:471–79
Kelley CM, Jacoby LL. 1996. Adult egocentrism: subjective experience versus analytic bases for judgment.
J. Mem. Lang. 35:157–75
Kelley CM, Lindsay DS. 1993. Remembering mistaken for knowing: ease of retrieval as a basis for confidence
in answers to general knowledge questions. J. Mem. Lang. 32:1–24
Kelley CM, Rhodes MG. 2002. Making sense and nonsense of experience: attributions in memory and judg-
ment. In The Psychology of Learning and Motivation: Advances in Research and Theory, vol. 41, ed. H Ross,
pp. 293–320. San Diego, CA: Academic
Kimball DR, Metcalfe J. 2003. Delaying judgments of learning affects memory, not metamemory. Mem. Cogn.
31:918–29
King JF, Zechmeister EB, Shaughnessy JJ. 1980. Judgments of knowing: the influence of retrieval practice.
Am. J. Psychol. 93:329–43
Knight JB, Hunter Ball B, Brewer GA, DeWitt MR, March RL. 2012. Testing unsuccessfully: a specification of the underlying mechanisms supporting its influence on retention. J. Mem. Lang. 66:731–46
Koriat A. 1993. How do we know that we know? The accessibility model of the feeling of knowing. Psychol. Rev. 100:609–39
Koriat A. 1997. Monitoring one’s own knowledge during study: a cue-utilization approach to judgments of learning. J. Exp. Psychol.: Gen. 126:349–70
Koriat A, Bjork RA. 2005. Illusions of competence in monitoring one’s knowledge during study. J. Exp. Psychol.: Learn. Mem. Cogn. 31:187–94
Koriat A, Bjork RA, Sheffer L, Bar SK. 2004. Predicting one’s own forgetting: the role of experience-based and theory-based processes. J. Exp. Psychol.: Gen. 133:643–56
Kornell N. 2009. Optimizing learning using flashcards: Spacing is more effective than cramming. Appl. Cogn. Psychol. 23:1297–317
Kornell N. 2011. Failing to predict future changes in memory: A stability bias yields long-term overconfidence. In Successful Remembering and Successful Forgetting: A Festschrift in Honor of Robert A. Bjork, ed. AS Benjamin, pp. 365–86. New York: Psychol. Press
Kornell N. 2012. A stability bias in human memory. In Encyclopedia of the Sciences of Learning, ed. N Seel, pp. 4–7. New York: Springer
Kornell N, Bjork RA. 2007. The promise and perils of self-regulated study. Psychon. Bull. Rev. 6:219–24 Kornell N, Bjork RA. 2008a. Learning concepts and categories: Is spacing the “enemy of induction”? Psychol.
Sci. 19:585–92
Kornell N, Bjork RA. 2008b. Optimising self-regulated study: the benefits—and costs—of dropping flashcards.
Memory 16:125–36
Kornell N, Bjork RA. 2009. A stability bias in human memory: overestimating remembering and underesti-
mating learning. J. Exp. Psychol.: Gen. 138:449–68
Kornell N, Bjork RA, Garcia MA. 2011a. Why tests appear to prevent forgetting: a distribution-based bifur-
cation model. J. Mem. Lang. 65:85–97
Kornell N, Castel AD, Eich TS, Bjork RA. 2010. Spacing as the friend of both memory and induction in
young and older adults. Psychol. Aging 25:498–503
Kornell N, Hays MJ, Bjork RA. 2009. Unsuccessful retrieval attempts enhance subsequent learning. J. Exp.
Psychol.: Learn. Mem. Cogn. 35:989–98
Kornell N, Metcalfe J. 2006. Study efficacy and the region of proximal learning framework. J. Exp. Psychol.:
Learn. Mem. Cogn. 32:609–22
Kornell N, Rhodes MG, Castel AD, Tauber SK. 2011b. The ease of processing heuristic and the stability bias:
dissociating memory, memory beliefs, and memory judgments. Psychol. Sci. 22:787–94
Kornell N, Son LK. 2009. Learners’ choices and beliefs about self-testing. Memory 17:493–501
Landauer TK, Bjork RA. 1978. Optimum rehearsal patterns and name learning. In Practical Aspects of Memory,
ed. MM Gruneberg, PE Morris, RN Sykes, pp. 625–32. London: Academic
Lee TD. 2012. Contextual interference: generalizability and limitations. In Skill Acquisition in Sport: Research,
Theory, and Practice II, ed. NJ Hodges, AM Williams, pp. 79–93. London: Routledge
Little JL, Bjork EL, Bjork RA, Angello G. 2012. Multiple-choice tests exonerated, at least of some charges:
fostering test-induced learning and avoiding test-induced forgetting. Psychol. Sci. In press
Lundeberg MA, Fox PW. 1991. Do laboratory findings on test expectancy generalize to classroom outcomes?
Rev. Educ. Res. 61:94–106
Matvey G, Dunlosky J, Guttentag R. 2001. Fluency of retrieval at study affects judgments of learning ( JOLs):
an analytic or nonanalytic basis for JOLs? Mem. Cogn. 29:222–33
McCabe DP, Soderstrom NC. 2011. Recollection-based prospective metamemory judgments are more accu-
rate than those based on confidence: judgments of remembering and knowing ( JORKs). J. Exp. Psychol.:
Gen. 140:605–21
McCabe JA. 2011. Metacognitive awareness of learning strategies in undergraduates. Mem. Cogn. 39:462–76 McNamara DS. 2010. Strategies to read and learn: overcoming learning by consumption. Med. Educ. 44:340–46 Metcalfe J. 2009. Metacognitive judgments and control of study. Curr. Dir. Psychol. Sci. 18:159–63
Metcalfe J, Finn B. 2008. Evidence that judgments of learning are causally related to study choice. Psychon.
Bull. Rev. 15:174–79
Metcalfe J, Finn B. 2011. People’s hypercorrection of high-confidence errors: Did they know it all along? J. Exp. Psychol.: Learn. Mem. Cogn. 37:437–48
Metcalfe J, Kornell N. 2005. A region of proximal learning model of study time allocation. J. Mem. Lang. 52:463–77
Miele DB, Finn B, Molden DC. 2011. Does easily learned mean easily remembered? It depends on your beliefs about intelligence. Psychol. Sci. 22:320–24
Morisano D, Hirsh JB, Peterson JB, Pihl RO, Shore BM. 2010. Setting, elaborating, and reflecting on personal goals improves academic performance. J. Appl. Psychol. 95:255–64
Nelson TO, Dunlosky J. 1991. When people’s judgments of learning ( JOLs) are extremely accurate at pre- dicting subsequent recall: the “delayed-JOL effect.” Psychol. Sci. 2:267–70
Nelson TO, Narens L. 1990. Metamemory: a theoretical framework and new findings. In The Psychology of Learning and Motivation, vol. 26, ed. GH Bower, pp. 125–73. New York: Academic
Oppenheimer DM. 2008. The secret life of fluency. Trends Cogn. Sci. 12:237–41
Pashler H, McDaniel M, Rohrer D, Bjork RA. 2009. Learning styles: concepts and evidence. Psychol. Sci. Public
Interest 3:105–19
Pintrich PR, Smith DAF, Garcia T, McKeachie WJ. 1993. Reliability and predictive validity of the motivated
strategies for learning questionnaire (MSLQ). Educ. Psychol. Meas. 53:801–3
Pyc MA, Dunlosky J. 2010. Toward an understanding of students’ allocation of study time: Why do they
decide to mass or space their practice? Mem. Cogn. 38:431–40
Pyc MA, Rawson KA. 2009. Testing the retrieval effort hypothesis: Does greater difficulty correctly recalling
information lead to higher levels of memory? J. Mem. Lang. 60:437–47
Pyc MA, Rawson KA. 2010. Why testing improves memory: mediator effectiveness hypothesis. Science 330:335 Pyc MA, Rawson KA. 2012. Why is test–restudy practice beneficial for memory? An evaluation of the mediator
shift hypothesis. J. Exp. Psychol.: Learn. Mem. Cogn. 38:737–46
Rawson KA, Dunlosky J. 2011. Optimizing schedules of retrieval practice for durable and efficient learning:
How much is enough? J. Exp. Psychol.: Gen. 140:283–302
Rawson KA, Dunlosky J, McDonald SL. 2002. Influences of metamemory on performance predictions for
text. Q. J. Exp. Psychol. 55A:505–24
Rawson KA, Kintsch W. 2005. Rereading effects depend on time of test. J. Educ. Psychol. 97:70–80
Reder LM. 1987. Strategy selection in question answering. Cogn. Psychol. 19:90–138
Reder LM. 1996. Different research programs on metacognition: Are the boundaries imaginary? Learn. Individ.
Differ. 8:383–90
Rhodes MG, Castel AD. 2008. Memory predictions are influenced by perceptual information: evidence for
metacognitive illusions. J. Exp. Psychol.: Gen. 137:615–25
Rhodes MG, Castel AD. 2009. Metacognitive illusions for auditory information: effects on monitoring and
control. Psychon. Bull. Rev. 16:550–54
Rhodes MG, Tauber SK. 2011. The influence of delaying judgments of learning on metacognitive accuracy:
a meta-analytic review. Psychol. Bull. 137:131–48
Richland LE, Kornell N, Kao LS. 2009. The pretesting effect: Do unsuccessful retrieval attempts enhance
learning? J. Exp. Psychol: Appl. 15:243–57
Roediger HL, Butler AC. 2011. The critical role of retrieval practice in long-term retention. Trends Cogn. Sci.
15:20–27
Roediger HL, Karpicke JD. 2006. The power of testing memory: basic research and implications for educa-
tional practice. Perspect. Psychol. Sci. 1:181–210
Rohrer D, Taylor K. 2006. The effects of overlearning and distributed practice on the retention of mathematics
knowledge. Appl. Cogn. Psychol. 20:1209–24
Rohrer D, Taylor K. 2007. The shuffling of mathematics problems improves learning. Instr. Sci. 35:481–98 Schacter DL, Gilbert DT, Wegner DM. 2011. Psychology. New York: Worth. 2nd ed.
Schwartz BL, Benjamin AS, Bjork RA. 1997. The inferential and experiential basis of metamemory. Curr. Dir.
Psychol. Sci. 6:132–37
Schwarz N. 2004. Metacognitive experiences in consumer judgment and decision making. J. Consumer Psychol.
14:332–48
Serra MJ, Dunlosky J. 2005. Does retrieval fluency contribute to the underconfidence-with-practice effect? J. Exp. Psychol.: Learn. Mem. Cogn. 31:1258–66
Shaw J. 1996. Increases in eyewitness confidence resulting from postevent questioning. J. Exp. Psychol.: Appl. 2:126–46
Simon DA, Bjork RA. 2001. Metacognition in motor learning. J. Exp. Psychol.: Learn. Mem. Cogn. 27:907–12 Smith SM, Glenberg AM, Bjork RA. 1978. Environmental context and human memory. Mem. Cogn. 6:342–53 Smith SM, Rothkopf EZ. 1984. Contextual enrichment and distribution of practice in the classroom. Cogn.
Instr. 1:341–58
Son LK. 2004. Spacing one’s study: evidence for a metacognitive control strategy. J. Exp. Psychol.: Learn. Mem.
Cogn. 30:601–4
Son LK. 2010. Metacognitive control and the spacing effect. J. Exp. Psychol.: Learn. Mem. Cogn. 36:255–62 Son LK, Kornell N. 2008. Research on the allocation of study time: key studies from 1890 to the present (and
beyond). In A Handbook of Memory and Metamemory, ed. J Dunlosky, RA Bjork, pp. 333–51. Hillsdale,
NJ: Psychol. Press
Son LK, Kornell N. 2009. Simultaneous decisions at study: time allocation, ordering, and spacing. Metacogn.
Learn. 4:237–48
Son LK, Metcalfe J. 2000. Metacognitive and control strategies in study-time allocation. J. Exp. Psychol.: Learn.
Mem. Cogn. 26:204–21
Spellman BA, Bjork RA. 1992. When predictions create reality: Judgments of learning may alter what they
are intended to assess. Psychol. Sci. 3:315–16
Taraban R, Maki WS, Rynearson K. 1999. Measuring study time distributions: implications for designing
computer-based courses. Behav. Res. Methods Instrum. Comput. 31:263–69
Tauber SK, Dunlosky J, Rawson KA, Wahlheim CN, Jacoby LJ. 2012. Self-regulated learning of a natural
category: Do people interleave or block exemplars during study? In press
Taylor K, Rohrer D. 2010. The effects of interleaved practice. Appl. Cogn. Psychol. 24:837–48
Thiede KW. 1999. The importance of accurate monitoring and effective self-regulation during multitrial
learning. Psychon. Bull. Rev. 6:662–67
Thiede KW, Dunlosky J. 1999. Toward a general model of self-regulated study: an analysis of selection of
items for study and self-paced study time. J. Exp. Psychol.: Learn. Mem. Cogn. 25:1024–37
Thiede KW, Griffin TD, Wiley J, Redford JS. 2009. Metacognitive monitoring during and after reading. In Handbook of Metacognition in Education, ed. DJ Hacker, J Dunlosky, AC Graesser, pp. 85–106. New York:
Taylor & Francis
Toppino TC, Cohen MS. 2010. Metacognitive control and spaced practice: clarifying what people do and
why. J. Exp. Psychol.: Learn. Mem. Cogn. 36:1480–91
Toppino TC, Cohen MS, Davis M, Moors AC. 2009. Metacognitive control over distribution of practice:
When is spacing preferred? J. Exp. Psychol.: Learn. Mem. Cogn. 35:1352–58
Vaughn KE, Rawson KA. 2011. Diagnosing criterion-level effects on memory: What aspects of memory are
enhanced by repeated retrieval? Psychol. Sci. 22:1127–31
Vaughn KE, Rawson KA. 2012. When is guessing incorrectly better than studying for enhancing memory?
Psychon. Bull. Rev. In press
Wahlheim CN, Dunlosky J, Jacoby LL. 2011. Spacing enhances the learning of natural concepts: an investi-
gation of mechanisms, metacognition, and aging. Mem. Cogn. 39:750–63
Wahlheim CN, Finn B, Jacoby LL. 2012. Metacognitive judgments of repetition and variability effects in
natural concept learning: evidence for variability neglect. Mem. Cogn. 40:703–16
Whitten WB, Bjork RA. 1977. Learning from tests: effects of spacing. J. Verbal Learn. Verbal Behav. 16:465–78 Wissman KT, Rawson KA, Pyc MA. 2012. How and when do students use flashcards? Memory. 6:568–79 Zaromb FM, Roediger H. 2010. The testing effect in free recall is associated with enhanced organizational
processes. Mem. Cogn. 38:995–1008
Zechmeister EB, Shaughnessy JJ. 1980. When you know that you know and when you think that you know
but you don’t. Bull. Psychon. Soc. 15:41–44
Zulkiply N, McLean J, Burt JS, Bath D. 2012. Spacing and induction: application to exemplars presented as
auditory and visual text. Learn. Instr. 22:215–21
 -->
