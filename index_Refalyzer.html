<!--
Basic procedure is, go through everything 2x. 
// Step 1: take care of all of the user-input DOIs. 
// Step 2: search crossref for DOIs and then take care of those. 
-->

<!-- 
dfd To do: 

Combining rows
- if the row above and below are done, then this row is done. 
- if something is done and perfect, don't mark it as "don't try to combine me with other crap." Or maybe such items are already being ignored when trying to combine? 
- when something is done and good but not perfect, check above it and below it and suck that stuff in if appropriate. 
- if it has the first half of the reference, maybe it shouldn't be trying to find something above itself? 
- With two non-user-doi rows, there are 4 possiblities, the first one is right, the 2nd is right, both are wrong but the combo is right, or nothing is right. 
- Just looking at the output, it seems like maybe some of the ones marked wrong are actually right. Should they be marked probable instead? 

Author table
- instead of re-building the table, have it update the table. to do this, it should check 
whether a row for the author exists. Then either add it, or change the citation count and co-authors
- Look for cases where it's the same author but the name is different (e.g., Bjork, E. L. and Bjork, 
Elizabeth Ligon). Combine them. Also, check if they're the same when ignoring case

-->

<!-- 
stuff to test
~~~
test this because it combines way too much and even brings the stuff from below the doi to above!?

Besken, M. (2016). Picture-perfect is not perfect for metamemory: 
Testing the perceptual fluency hypothesis with degraded images. 
Journal of Experimental Psychology: Learning, Memory, and Cognition, 
42, 1417–1433. 

https://doi.org/10.1037/0278-7393.34.3.460

Besken, M., & Mulligan, N. W. (2013). Easily perceived, easily 
remembered? Perceptual interference produces a double dissociation 
between metamemory and memory performance. Memory & Cognition, 41, 
897–903. 

~~~
test this because it's got a couple stinkers in it

Carroll, M., Mazzoni, G., Andrews, S., & Pocock, P. (1999). Monitoring the future: Object and source memory for real and imagined events. Applied Cognitive Psychology, 13, 373–390. https://doi.org/10.1002/(SICI)1099-0720(199908)13:4<373::AID- ACP605>3.0.CO;2-F

Dodson, C. S., Darragh, J., & Williams, A. (2008). Stereotypes and retrieval-provoked illusory source recollections. Journal of Experimental Psychology: Learning, Memory, and Cognition, 34, 460–477. https://doi.org/10.1037/0278-7393.34.3.460

Heck, D. W., Gronau, F. Q., & Wagenmakers &, E.-J. (2019). metaBMA: Bayesian Model

Averaging for Random and Fixed Effects Meta-Analysis. https://CRAN.R-

project.org/package=metaBMA.

Dougherty, M. R., Scheck, P., Nelson, T. O., & Narens, L. (2005). Using the past to predict the future. Memory & Cognition, 33, 1096–1115. https://doi.org/10.3758/BF03193216

~~~

test this and see if it still causes an error. having the same reference appear twice (with or without doi) causes a breakdown where some references aren't found at all

Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect.

Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x 

Meiser, T., Sattler, C., & Von Hecker, U. (2007). Metacognitive inferences in source memory

judgements: The role of perceived differences in item recognition. Quarterly Journal of

Experimental Psychology, 60, 1015–1040. https://doi.org/10.1080/17470210600875215 Metcalfe, J. (2009). Metacognitive judgments and control of study. Current Directions in

Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x 

-- also --
if there are duplicate lines but they're good, it gets rid of both. maybe it should keep one. to do this, I could
have it run the duplicate line array through the database and see if anything good comes out

aDunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20(4), 374–380.
aklsdkjf
bDunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20(4), 374–380.

-- decided not to do this-- 
 reference table
- don't have the table itself be important to the functioning of the program. because what if I change how the table looks?
- don't add stuff to the table that's not correct. only add stuff that's done. And only add reference_objs to the good table. add the bad stuff to a different table. 
- have each text_obj know what its initial row number was, so it's easy to try to combine it with above and below. (note, 
    if a row has been removed, the numbering will get messed up. instead of trying to update the other rows when one is
    removed, just write an above/below function that returns the next viable item)
 -->

 

<!DOCTYPE html>
<html lang="en">

<head>
	<title>Reference Analyzer</title>
	<meta charset="utf-8" />
	<meta name="description" content="looking at academic references">
	<meta name="keywords" content="program">
	<meta name="author" content="Nate Kornell">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" href="favicon.ico">
	<link rel="stylesheet" type="text/css" href="mystyle.css">
	
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/citation-js"></script> <!-- this is to use citation-js -->
<!-- 	<script src="https://cdn.jsdelivr.net/npm/string-similarity"></script> -->
<!-- 	<script src="https://cdn.jsdelivr.net/npm/string-algorithms"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/string-similarity@4/package.json"></script> -->

<script>
	var author_obj = [];
	var reference_obj = [];
	var text_obj = []
	var to_do_list_input_string = [];
	var duplicate_input_text = [];
	var articleTableText = "";
	var startTime = 0;
	var started_notFoundYet = false;
	var doi_pattern = /10.\d{4,9}\/[-._;()/:A-Z0-9<>]+/gi; // doi_pattern is used to find a DOI within the input string. note: I added in the g, which makes it return all of the DOIs instead of just 1
    const cc = [];
    cc['fragment'] = 'blue';
    cc['wrong'] = 'red';
    var good_match_threshold = 80;

// 	var doi_pattern = \b(10[.][0-9]{4,}(?:[.][0-9]+)*/(?:(?!["&\'<>])\S)+)\b; // original from somewhere, I had to change it to make it work, see: https://www.regexpal.com/
// 	var doi_pattern = /\b(10[.][0-9]{4,}(?:[.][0-9]+)*\/(?:(?!["&\'<>])\S)+)\b/i; // works
// 	var doi_pattern = /^10.\d{4,9}/[-._;()/:A-Z0-9]+$/i; // from crossref

	let Cite = require('citation-js');

	function Text_object(input_userInput, input_doi, input_doi_type, input_ord) { 
		this.user_input = input_userInput;
        this.doi = input_doi;
        this.doi_type = input_doi_type;
        this.input_order = input_ord;
        this.search_status = "not started";
        this.match_status = "unknown";
		this.notes = "";
		this.removed = false;
		this.score = 0;
		this.letter_match = 0;
		this.letter_match_percentage = 0;
        
        to_do_list_input_string.push(input_userInput);
        
		this.update_input = function(input_search_status) {
		    // possible search status values:
            //    not started, searching, incorrect doi entered; searching again, done 
		    // possible match status values
		    //    unknown, wrong, fragment, correct
		    
            if (this.removed) {
                console.log( 'update_input called for .removed object (returned instead): '+this.user_input);
                return;
            }

		    if (this.search_status != 'done' && input_search_status == 'done') {
				to_do_list_input_string.splice(to_do_list_input_string.indexOf(this.user_input),1); // remove it from to do list because it's done
// 				console.log( 'splicing : '+this.user_input)
		    }
		    
		    if (input_search_status != '') {
    		    this.search_status = input_search_status;
    		}
		    
		    // if the user-entered doi was incorrect, change doi type
            if (input_search_status == 'incorrect doi entered; searching again') {
                this.doi_type = 'not_found_yet';
//                 console.log( 'changed doi type to not found yet, for: ' + this.user_input)
            }
            
console.log( 'calling update, this.doi='+this.doi);
if (typeof reference_obj[this.doi] !== 'undefined') {
    const temp_apa_no_html = reference_obj[this.doi].apa_no_html;
    this.score = compute_score(temp_apa_no_html, this.user_input); // order has to be database version, user version 
    this.letter_match = compute_letter_match(temp_apa_no_html, this.user_input);
    this.letter_match_percentage = compute_letter_match_percentage(this.user_input, temp_apa_no_html); // order has to be user, database
    if (this.score > good_match_threshold) {
        this.good_match = true;
        this.match_status = 'correct';
    } else {
        if (this.letter_match_percentage > good_match_threshold) {
            this.good_match = true;
            this.match_status = 'fragment';
        } else {
            this.good_match = false;
            this.match_status = 'wrong';
        }
    }
//     this.search_status = 'done'; // dfd leave in?
} else {
    this.match_status = 'unknown';
}

            
		    if (this.match_status == 'unknown') {
		        var temp_match_status_to_show = '';
		    } else {
    		    var temp_match_status_to_show = '<div style="color:' + cc[this.match_status]  + ';">' + this.match_status + '</div>';
		    }
		    if (this.search_status == 'done') {
		        var temp_search_status_to_show = '';
		    } else {
		        var temp_search_status_to_show = this.search_status;

		    }
		    try {
    			document.getElementById('notes_'+this.user_input).innerHTML = temp_search_status_to_show + temp_match_status_to_show; 
    		} catch(err) {
    		    console.log( '*error, did not update notes because getElementById did not find: '+this.user_input);
    		}
    		
    		updateProgress();
    		
    		// plan: put scores and stuff in hte text object, give its update function just one parameter, search status. i'll figure out match status on its own. 
    		
            try { 
                // update the notes 
                if (typeof reference_obj[this.doi] === 'undefined') { // dfd if this is == versus === it makes a big difference
console.log( 'undefined doi ('+this.doi+'): '+this.user_input);
// 			        return;
			    } else {
console.log( 'good doi ('+this.doi+'): '+this.user_input);		    
			    }
                const c  = ['tomato','black'];                
                var temp_stringToShow = "";
				if (this.match_status != 'correct') {
					temp_stringToShow += '<div style="color:' + cc[this.match_status]  + ';">' + this.match_status+'</div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.score/60)] + ';">' + this.score+'=score </div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.letter_match/60)] + ';">' + this.letter_match+'=letter_match </div>';
                    temp_stringToShow += '<div style="color:' + c[Math.floor(this.letter_match_percentage/60)] + ';">' + this.letter_match_percentage+"=letter_match_percentage</div>"; 
	                this.notes = temp_stringToShow;
				} else {
					this.notes = '';
				}

                // update html
                document.getElementById('inputText_'+this.user_input).innerHTML = this.user_input; 
                document.getElementById('reference_'+this.user_input).innerHTML = this.apa; 
                document.getElementById('notes_'+this.user_input).innerHTML = this.notes; 
// console.log( 'update_input called (end): '+this.user_input);
            } catch(err) {
    		    console.log('*error in update ref, for: ');
    		    console.log( this.user_input);
    		    console.log( err);
            }

		}
	}
	
	function Reference_object(input_userInput, input_json, input_apa) {
		this.user_input = input_userInput;
		this.json = input_json;
		this.apa = input_apa; // maybe this should be figured out here, not passed as a parameter?
		this.apa_no_html = jQuery(input_apa).text().trim(); // apa without the html tags
		this.doi = this.json.DOI;
        		
        this.table_row_number = function() {
            return document.getElementById(this.user_input).rowIndex;
        }
 
//  		this.update_ref = function() {
// 			// update score and status
// 			if (text_obj[this.user_input].removed) {
//                 console.log( 'update_ref called for .removed object (returned instead): '+this.user_input);
// 			    return;
// 			}
// 			this.score = compute_score(this.apa_no_html, this.user_input); // order has to be database version, user version 
// 			this.letter_match = compute_letter_match(this.apa_no_html, this.user_input);
// 		    this.letter_match_percentage = compute_letter_match_percentage(this.user_input, this.apa_no_html); // order has to be user, database
//             if (this.score > good_match_threshold) {
//                 this.good_match = true;
// 		        text_obj[this.user_input].update_input('done','correct');
//             } else {
//                 if (this.letter_match_percentage > good_match_threshold) {
//                     this.good_match = true;
//                     text_obj[this.user_input].update_input('done','fragment');
//                 } else {
//                     this.good_match = false;
//                     text_obj[this.user_input].update_input('done','wrong');
//                 }
//             }
// 		};
	}

	function Author_object(input_familyname, input_firstname) {
		// this creates instances of an author object, which is how I keep track of authors. 
		this.name = input_familyname + ", " + input_firstname;
		this.citation_count = 1;
		this.coauthors = [];
		this.checked = false;
		
		var firstName_array = input_firstname.replaceAll('. ',' ').replaceAll('.',' ').trim().split(" "); //array of first names with the periods replaced by spaces (which is only necessary for things like "T.O." as a first name)
		this.name_apa = input_familyname + ", " + first_letters(firstName_array);

		this.all_coauthors_string = function() {
			var i = 0;
			var temp = "";
			for (i = 0; i < this.coauthors.length; i++) {
				temp += this.coauthors[i].name + "; ";
			}
			return temp.substring(0, temp.length-2); // removes the final ";"
		};
	}
	

 	async function getAllUrls(doi_type_to_handle) {
	    // this gets called twice. First, for rows that have a doi. Then, when they're done, for rows that don't. 
        
        var row_queue = [];
        var i = 0;

//  		for (i = to_do_list_input_string.length - 1; i >= 0; i--) { // this would from the bottom up
 		for (i = 0; i < to_do_list_input_string.length; i++) {
//  		    console.log( 'row que ++ loop: '+text_obj[to_do_list_input_string[i]].user_input+' status: '+text_obj[to_do_list_input_string[i]].search_status)
            if (text_obj[to_do_list_input_string[i]].doi_type === doi_type_to_handle) {
                if (text_obj[to_do_list_input_string[i]].search_status === 'not started' || text_obj[to_do_list_input_string[i]].search_status === 'incorrect doi entered; searching again') {
    			    row_queue.push(to_do_list_input_string[i]); 
    		    }
            }
		}
        
        console.log('--getting ' + row_queue.length + ' rows ('+doi_type_to_handle+')--')   
		for (i = 0; i < row_queue.length; i++) {
   			getOneURL(row_queue[i]); 
		}
	}

	
	async function getOneURL(input_string) {	
// 		Be careful here! This calls everything async, which means that some of this code might 
// 		execute for item 12 before it gets to item 8, etc. Things can get out of order. Which means, 
// 		for example, that by the time it arrives at item x (e.g., 2), item x + y (e.g., 5) might have 
// 		already decided that x shouldn't be shown. And stuff. This is why the program does all the  
//		rows that have dois before starting on the ones that don't. 
        
        var ignore_doi = false;
        
        if (text_obj[input_string].search_status == "not started") {
       		text_obj[input_string].update_input('searching');
        } else if (text_obj[input_string].search_status == 'incorrect doi entered; searching again') {
       		text_obj[input_string].update_input('searching');
            ignore_doi = true;
        }
        
		var stringToSend = '';
		var inputDOI = text_obj[input_string].doi;
		
		try {
			if (inputDOI === "" || ignore_doi == true) {
				// If this function finds a doi in crossref, it recursively calls itself and returns. 
				// This is wasteful because it means going to a server to find JSON that's already 
				// been found, but I need the JSON in the format Cite uses, which is called Citation 
				// Style Language (CSL). And I couldn't figure out any other way. 

                if (ignore_doi == true) {
                    var temp_search_string = remove_doi_from_string(input_string, inputDOI);
                    // maybe check if it's an empty string and if so, abandon ship?
                } else {
                    temp_search_string = input_string;
    			}

// 	       		pagelog( 'getOneURL  [no doi]: '+temp_search_string)
   				stringToSend = 'https://api.crossref.org/works?mailto=nkornell@gmail.com&rows=1&query.bibliographic=' + temp_search_string.replaceAll(' ', '+');
// 				document.getElementById('reference_' + input_string).innerHTML = "searching"; 
				let myJSON = await $.getJSON(encodeURI(stringToSend));
				if (typeof myJSON.message.items[0] === 'undefined') { // if it's not in the database
					if (duplicate_input_text.indexOf(input_string) < 0) { // if it's not a duplicate
					    // this happens when a doi is bad	
		                text_obj[input_string].update_input('done');
					} else {
					    console.log( "** 823 i didn't' think THIS HAPPENING WAS POSSIBLE");
					}
				} else {
					// if a doi was found, run this thing again but with the doi in the parameter, so Cite will work.
					text_obj[input_string].doi = myJSON.message.items[0].DOI;
// 					console.log('calling getoneurl recursively with doi=' + text_obj[input_string].doi)
					getOneURL(input_string);
					return;
				}
			} else { // if a doi was found
// 	       		pagelog( 'getOneURL [yes doi]: '+input_string)
				let myJSON = await Cite.async(inputDOI);
				let bibliography = myJSON.format ('bibliography', {
					format: 'html'
				});
				
				if (typeof reference_obj[myJSON.data[0].DOI] === 'undefined') { 
					// create new reference
					reference_obj[myJSON.data[0].DOI] = new Reference_object(input_string, myJSON.data[0], bibliography);
					text_obj[input_string].update_input('done');

					decide_whether_to_combine_rows(reference_obj[myJSON.data[0].DOI], -1);
					if (text_obj[reference_obj[myJSON.data[0].DOI].user_input].removed == false) {
    					decide_whether_to_combine_rows(reference_obj[myJSON.data[0].DOI], 1);
    				}
					if (to_do_list_input_string.indexOf(input_string) > -1) {
// 					    console.log( 'splicing '+to_do_list_input_string.indexOf(input_string))
						to_do_list_input_string.splice(to_do_list_input_string.indexOf(input_string),1); // remove it from to do list because it's done
					}
					parse_JSON_for_authors(myJSON.data[0]); // dfd this assumes the json is still correct. Does the whole author thing adjust for removed rows? maybe it should happen at the end?
				} else { 
					// if it finds a doi that's been found before.
					combine_rows(input_string, reference_obj[myJSON.data[0].DOI]); 
				}
			}

            build_author_table();
			updateProgress();
		}
		catch(err) {
			if (err == "Error: Server responded with status code 404") {
			    //if it tried a doi that isn't correct, search again without the doi this time
// 				console.log( "failed to find DOI " + inputDOI)
				if (text_obj[input_string].search_status == 'searching') {
            		text_obj[input_string].update_input('incorrect doi entered; searching again');
	    			getOneURL(input_string); // the second parameter being true means the search ignores the user's doi
	    		} // dfd get rid of second parameter above, and add third parameter to line 2 above?
	    		   			
			} else if (err == 'Error: This format is not supported or recognized') { 
			    // if it found a doi that is correct, but the citation can't be found by Cite, give up.
                console.log( 'time to give up')
                text_obj[input_string].update_input('done');
			} else {
			    console.log( '*error in get one url: '+input_string);
				console.log(err);
			}
		}
	}	

	function remove_duplicate_rows() {
	    // this is called once, after user dois have been processed
        // it's a 2-step process
        // 1. for each item, first it checks if it's on the remove list, then it checks whether it matches any other row
        // 2. after finding all the removable rows, it removes them all. 
	
		var i = 0;
		var target = 0;
		var target_string = '';
		var tempScore = 0;
		var target_has_been_found = false;
		var foof = 0;
		
		// find duplicate rows
        for (target = 0; target < to_do_list_input_string.length; target++) {
            target_has_been_found = false;
            target_string = to_do_list_input_string[target];
            for (i = 0; i < duplicate_input_text.length-1; i++) {
                tempScore = compute_letter_match(target_string, duplicate_input_text[i]);
                if (tempScore > 90) { // if it's the same as a previous row
                    if (duplicate_input_text.includes(target_string) == false) {
                        duplicate_input_text.push(target_string);
                    }
                    target_has_been_found = true;
                    break; // exit this loop
                }
            }
            if (target_has_been_found) {
                continue; // skip the rest of this loop and start with the next value (i.e., target+1). Because this target is already labelled a duplicate.
            } else {           
                for (i = target + 1; i < to_do_list_input_string.length; i++) {
                    tempScore = compute_letter_match(target_string, to_do_list_input_string[i]);
                    if (tempScore > 90) { // if it's the same as a previous row
                        if (duplicate_input_text.includes(to_do_list_input_string[i]) == false) {
                          duplicate_input_text.push(to_do_list_input_string[i]);
                        }

                        if (text_obj[target_string].match_status !== 'correct') {
                            if (duplicate_input_text.includes(target_string) == false) {
                                duplicate_input_text.push(target_string);
                            }
                        }
                    }   
                }
            }
        }
        
        // remove duplicate rows
        for (i = to_do_list_input_string.length - 1; i >= 0; i--) {
            if (duplicate_input_text.includes(to_do_list_input_string[i])) {
                if (text_obj[to_do_list_input_string[i]].doi_type != 'from_user') { // don't remove if it has a doi
//                     pagelog('[removing] ' + to_do_list_input_string[i]+' doi type='+text_obj[to_do_list_input_string[i]].doi_type)
                    remove_row(to_do_list_input_string[i]);                
                    foof++;
                }
            }
        }
        console.log('--removed '+foof+' duplicate rows--');
	}
	
	
	function pagelog(instring) {
        document.getElementById("outputText").innerHTML += '<p>' +instring;
	}
	
	function remove_row(input_string) {
		// remove a row that is no longer needed
		
        if (text_obj[input_string].removed) {
            // if it's already removed, don't remove it. 
            if (to_do_list_input_string.indexOf(input_string) >= 0) {
                // But before returning, check if it's still in the to do list, and if it is, remove it. (This can happen because exact duplicate rows need to be removed from the to do list more than once.)
//                 console.log( 'splicing '+to_do_list_input_string.indexOf(input_string));
                to_do_list_input_string.splice(to_do_list_input_string.indexOf(input_string),1);
            }
            return;
        } else {
            try {
                if (text_obj[input_string].match_status == "correct") {
                    console.log('removing a "correct" row');
                }

				var shouldRemoveFromTable = true;                
                if (shouldRemoveFromTable) {
					var row_to_remove = document.getElementById(input_string).rowIndex;
					document.getElementById("article_table").deleteRow(row_to_remove);
				}
				
//                 console.log( 'spli-sing '+to_do_list_input_string.indexOf(input_string))
                to_do_list_input_string.splice(to_do_list_input_string.indexOf(input_string),1);
        
                text_obj[input_string].removed = true; // I think I did this rather than deleting it because get URL might be looking for it later. 
        
//                 if (text_obj[input_string].doi != '') {
//                     console.log( 'removing row with a doi in it: '+ text_obj[input_string].doi);
//                 }
            }
            catch(err) {
                console.log( '*error in remove_row. input_string='+ input_string + " [error next line]");
                console.log( err);
            }
        }
//         pagelog('Removed: '+input_string)
        updateProgress();
	}

	function decide_whether_to_combine_rows(input_reference_obj, shift) {        
        // dfd But if the doi isn't trustworthy and the score is low,
        // it will need to be more sophisticated about comparing possible situations (e.g., it found 2 dois
        // but by combining them it get's a third doi that's better). 
	    
		if (document.getElementById(input_reference_obj.user_input) == null) { // this can happen when the user_input has changed but the reference obj hasn't)
			console.log( '*in decide whether to combine... null found for '+input_reference_obj.user_input)
			return;
		}
	
// dfdd
// if this is a fragment
//     try to combine. 
//     if the other has no doi, then just regular try to combine
//     if the other has a  doi, then 
//         if the dois are the same, combo is normal
//         if the dois are different, best combo should consider both dois and only combine if the combination is better than both. 
// if this is wrong
//     if the other one doesn't have a doi, return. we'll come back to it when the other gets its doi. 
//     if they both have dois, try to combine, but with the four option approach (a, b, ab, or none). because probably, both dois are wrong. 
// if this is correct
//     try to combine


	    // dfd don't do this
		if (text_obj[input_reference_obj.user_input].match_status == "wrong") {
        	console.log('[returning] decide whether to combine has match status = "wrong" for ' + input_reference_obj.user_input) 
			return;
		}

       	var otherRow_index = input_reference_obj.table_row_number() + shift;

        // don't try it if it would go outside the table
    	if (otherRow_index < 1) { // it's 1 because row 0 is the table header
    	    return;
    	} else if (otherRow_index >= document.getElementById("article_table").rows.length) {
//     	    console.log( 'PASSED END OF TABLE with shift='+shift +', '+input_reference_obj.user_input)
    	    return;
    	}
        
        try {
	        var otherRow_input_string = document.getElementById("article_table").rows[otherRow_index].cells[0].textContent;
// 	        var otherRow_input_string = document.getElementById("article_table").rows[otherRow_index].cells[0].innerHTML;
	    } catch(err) {
	    	console.log( "**error: in decide whether... can't find this row: " + otherRow_index)
	    	return;
	    }
        
        try {
            // don't try to combine with rows that are already settled. 
            // dfd put in something here that says, if they have the same doi, combine them
            if (text_obj[otherRow_input_string].match_status == "correct") {
//                     console.log( "tried to combine this and a row with status=correct, so returned instead. other row: "+ otherRow_input_string)
                return;
            }
        } catch(err) {
            console.log( "*error palm frond for "+otherRow_input_string)
            console.log( err);
        }
        
        if (combine_rows(otherRow_input_string, input_reference_obj) == true) { 
            decide_whether_to_combine_rows(input_reference_obj, shift); // do it again recursively
            return;
        }
	}

	function combine_rows(input_string, input_reference_obj) {
// dfd
// in best combination
// - it should take two targets as parameters and return which combination/target fit is best. 
// in combine_ rows, 
// - when both rows that are being combined have a doi, it needs to learn to prioritize. I think right now it's just whichever it comes to first. 

	    // This figures out the best combination and then, if appropriate, it merges the two rows and then deletes the extra one.
	    // The one it keeps is the input reference obj.  
	    
        var shouldCombine = false;
//         console.log( 

        try {
            if (text_obj[input_string].removed) {
                return false;
            } 
            if (text_obj[input_reference_obj.user_input].removed) {
                console.log( '*tried to combine with a removed reference obj: '+input_reference_obj.user_input); 
                return false;
                // dfd if this happens, it should maybe see if that removed reference was better...
            }

            if (input_reference_obj.doi == text_obj[input_string].doi) {
                // if it finds the same reference twice, combine them
//                 console.log( 'found the same doi twice')
                shouldCombine = true;
            } else if (text_obj[input_string].search_status == "searching") {
                // if it's still searching for a row, return. it'll try again with that row later. 
//                 console.log('search status = searching: ' + input_string + ' [returning in combine rows]');
                return false; 
            }
            
//             console.log('in combine rows, reference obj match status='+text_obj[input_reference_obj.user_input].match_status)
//             console.log('in combine rows, reference obj search status = ' + text_obj[input_reference_obj.user_input].search_status);
//             console.log('search status = ' + text_obj[input_string].search_status + ' for input obj in combine rows');


            if (text_obj[input_reference_obj.user_input].match_status == "correct" && text_obj[input_string].match_status == 'correct') {
                // if both have good dois already
                if (text_obj[input_string].doi !== input_reference_obj.doi) {
                    // if the two dois are not the same
//                     console.log( 'tried to combine two "correct" rows with different dois. returning.')
                    return false;
                }
            }

            // assume input reference obj is correct (i.e., that's the apa string target)
            if (text_obj[input_string].doi != '') {
                if (typeof reference_obj[text_obj[input_string].doi] != "unknown" && reference_obj[text_obj[input_string].doi] != null) { // dfd shouldn't unknown be undefined??
//                     console.log( 'in combine rows, both have dois. ')
//                     console.log( '   input obj score='+ reference_obj[text_obj[input_string].doi].score)
//                     console.log( '   reference obj score='+input_reference_obj.score)
                    if (text_obj[input_string].score > text_obj[input_reference_obj.user_input].score) { dfdd
                        console.log( '***should backweardsyl') //dfd make it treat the other one as the target
                    } else if (text_obj[input_string].score == text_obj[input_reference_obj.user_input].score) {
                        //the stuff below happens when a single reference is split into multiple lines. nothingn to worry about. 
//                         if (reference_obj[text_obj[input_string].doi].user_input == input_reference_obj.user_input) {
//                             console.log( '*combining with itself for '+input_reference_obj.user_input)
//                         } else {
//                             console.log( '*combining strings with the same score '+reference_obj[text_obj[input_string].doi].user_input+ '----and-- reference obj='+input_reference_obj.user_input)
//                         }
                    }
                }
            }
            var bestcombo = best_combination(input_string, input_reference_obj.user_input, input_reference_obj.apa_no_html);
        
            // if the best match is the combo, combine them. 
            if (input_reference_obj.user_input !== bestcombo) {
                shouldCombine = true;
            }

            // if appropriate, remove the row
            if (shouldCombine == true) {
                remove_row(input_string);
                change_user_input(input_reference_obj, bestcombo);
//                 pagelog('[combination] '+bestcombo+"<br>[should match] "+input_reference_obj.apa_no_html);
                return true;
            } else {
                return false;
            }
        }
        catch(err) {
            console.log('*error in combine rows, input_string:')
            console.log( input_string);
            console.log( err)
        }
	}
	
	function change_user_input(from_obj, to_string) {
	    // this changes the user input in: the table, the reference obj, the to do list, and...
	    // it also deletes the input obj and creates a new one in its place.

        try {
            var from_string = from_obj.user_input;
        
            change_elementIDs(from_string, to_string);
        
            // change input obj
            // create a new version of the input obj (with a new array index), but then copy the old one into it. 
            // I think I did this because get url is going to be expecting to return info to this thingy
            text_obj[to_string] = new Text_object(to_string, "","",-1); // not giving it a doi means it won't add 1 to numRows withDOIsTotal
            text_obj[to_string] = Object.assign({}, text_obj[from_obj.user_input]);
            text_obj[to_string].user_input = to_string;
            
            // change to do list
            to_do_list_input_string[to_do_list_input_string.indexOf(from_string)] = to_string;
        
            // update reference obj (i.e., from obj)
            from_obj.user_input = to_string;
            
            text_obj[to_string].update_input('');

            updateProgress();
        }
        catch(err) {
            console.log( '*error in change user input, from = '+from_string+' to = '+to_string+' error:')
            console.log( err)
        }
	}
	
	
	function best_combination(user_input_addition, user_input_target, goal) {
	    // tries the first two input parameters alone and in combination, to see which one matches the 3rd parameter best.
	    // the order of the first two parameters doesn't matter because it reorders them in terms of where they appear in the table. 
		var out = "";
    	var verbose = false;

		// if the new piece by itself is not a good percentage match for the target, don't combine
		var addition_Score_percent = compute_letter_match_percentage(user_input_addition, goal);
		if (addition_Score_percent < good_match_threshold) {
// 			console.log("[returning no change] addition score percent "+addition_Score_percent+" < good match threshold")
			return user_input_target;
		}

		// figure out the input, and put it in the order of the table (so that only forward combos will be accepted)
        if (document.getElementById(user_input_addition).rowIndex > document.getElementById(user_input_target).rowIndex) {
            aText = user_input_target;
            bText = user_input_addition;
		} else {
            aText = user_input_addition;
            bText = user_input_target;
		}
		comboText = aText + " " + bText;
		reverse_comboText = bText + " " + aText;
				
        try {
            aScore = compute_letter_match(aText, goal);
            bScore = compute_letter_match(bText, goal);
            comboScore = compute_letter_match(comboText, goal);
            reverse_comboScore = compute_letter_match(reverse_comboText, goal);
            
            // maybe to really be smart, it should look at where the fragment is (in the goal string). If it's the end, don't add 
            // something after it; if it's the start, don't add something before it. 
            
            if (verbose) {
                console.log( '--running best combination--');
                console.log('a = ['+text_obj[aText].search_status+', '+text_obj[aText].match_status+'] ' + aText)
                console.log('b = ['+text_obj[bText].search_status+', '+text_obj[bText].match_status+'] ' + bText)
                console.log( 'goal = '+goal)
                console.log( aScore, bScore, comboScore, reverse_comboScore)
                console.log( compute_letter_match_percentage(aText, goal),compute_letter_match_percentage(bText, goal),compute_letter_match_percentage(comboText, goal),compute_letter_match_percentage(reverse_comboText, goal))
            }
        }
        catch(err) {
            console.log('*error in best combination:')
            console.log('aText was='+aText);
            console.log('bText was='+bText);
        }
        
        reverse_comboScore = 0; // doing this makes it so reverse can't win. 
		maxScore = Math.max(aScore,bScore,comboScore,reverse_comboScore);
		if (maxScore == comboScore) {
		    if (verbose) {console.log( 'winner=comboText');}
			return comboText;
		} else if (maxScore == reverse_comboScore) {
		    if (verbose) {console.log( 'winner=reverse comboText');}
			return reverse_comboText;
		} else if (maxScore == aScore) {
		    if (verbose) {console.log( 'winner=returning earlier table entry');}
			return aText;
		} else if (maxScore == bScore) {
		    if (verbose) {console.log( 'winner=returning later table entry');}
			return bText;
		}
	}
	
	function compute_score(databaseString, userString) {
		// figure out whether a DOI was found in the user input
		var userDOI = userString.match(doi_pattern); 
		var databaseDOI = databaseString.match(doi_pattern); 
		
		// return a score
		if (typeof userDOI !== 'undefined' && userDOI !== null && userDOI.length > 0) {	// with typeof, put undefined in quotes
			// if there was a valid DOI in the user input, return a score of 100
			if (userDOI[0].toLowerCase() == databaseDOI[0].toLowerCase()) { 
			    // if a doi was found, it returns percentage. why? basically, if it's part of a reference with the right doi, this 
			    // will be high. but if it's the wrong reference, it'll be low. 
			    return compute_letter_match_percentage(userString,databaseString);
			} else {
				// if the user doi wasn't the same as the database one (is this possible?!) return the match strength without removing the doi
				// this happens when there's a bad doi, it searches without the doi, and finds a good doi to replace the bad one
				return compute_letter_match(databaseString,userString);
			}
		} else {
			// if there is not a valid doi in the user input, remove the doi from the database string for the sake of comparison. 
			// this does not use percentage because without a doi, I can't assume either side is good 
			databaseString = remove_doi_from_string(databaseString, databaseDOI);
			return compute_letter_match(databaseString,userString);
		}
	}
	
	function compute_letter_match(a, b) {
		return Math.ceil(100*similarity(a,b));
	}
	
	function compute_letter_match_percentage(a, b) {
        // This returns how good a match it is in terms of doing the best it could. 
        // In other words, the amount of letter match divided by the total possible amount of letter match. 
        
		var tempMatch = compute_letter_match(a, b);
		var maxPossible = a.length / b.length;
		
       // This would make it so that the order of the input parameters would not matter. However, the second parameter (b) is the target string, so here it does matter.
// 		if (maxPossible > 1) {
// 			maxPossible = 1/maxPossible;
// 		}
		maxPossible = 100*maxPossible;
        
        var return_value = Math.ceil(100*tempMatch/maxPossible);
        if (return_value > 100) {
            return_value = 100
        }
// 		console.log('match: ' + tempMatch + '/' + maxPossible + ' = '+ return_value);
		
		return return_value;
	}

	function change_elementIDs(from, to) {
	    try {
            document.getElementById(from).id = to;
            document.getElementById('reference_'+from).id = 'reference_'+to;
            document.getElementById('inputText_'+from).id = 'inputText_'+to;
            document.getElementById('notes_'+from).id = 'notes_'+to;			
        } catch(err) {
            console.log( '*error in change element IDs')
            console.log( 'from = '+from)
            console.log( 'to = '+to)
            console.log( err)
        }
	}
	
	function remove_doi_from_string(input_string, input_doi) {
	    var foof = '';
	    
        foof = input_string.replace("https://doi.org/"+input_doi,""); // assuming what seems like the standard format from the database
        foof = foof.replace(input_doi,""); // in case that wasn't found, remove just the doi
        
        return foof;
	}
	
	function parse_JSON_for_authors(input_json) {
		var tempAuthor_full = "";
		var temp_list_of_co_authors_from_this_article = [];
				
		// figure out author stuff (for author table)
		if (typeof input_json.author === 'undefined') { // if crossref didn't find it, ignore it 
// 			console.log('no authors found ' + input_json.DOI);
		} else {
			for (a = 0; a < input_json.author.length; a++) {
			    if (input_json.author[a].family !== undefined && input_json.author[a].family !== null) {
                    temp_firstname = input_json.author[a].given.replaceAll('. ',' ').replaceAll('.',' ').trim();
                    tempAuthor_full = input_json.author[a].family + ", " + temp_firstname;
                    
                    // keep track of how many times this author has appeared for the table of authors
                    if (author_obj[tempAuthor_full] === undefined) {
                        author_obj[tempAuthor_full] = new Author_object(input_json.author[a].family, temp_firstname);
                    } else {
                        author_obj[tempAuthor_full].citation_count++;
                    }
                    temp_list_of_co_authors_from_this_article.push(tempAuthor_full);
                }
			}

			connect_coauthors(temp_list_of_co_authors_from_this_article);
		}
	}

	function connect_coauthors(list_of_coauthors) {
		var i = 0;
		var j = 0;
		
		// if it's a single-author paper, don't do anything
		if (list_of_coauthors.length == 1) {
			return;
		}
		
// 		go through each pair of authors in the author list and connect each to the other (i.e., add them to each other's list of coauthors)
		for (i = 0; i < list_of_coauthors.length + 1; i++) {			
			for (j = i + 1; j < list_of_coauthors.length; j++) {
				if (author_obj[list_of_coauthors[i]].coauthors.includes(author_obj[list_of_coauthors[j]]) === false) { // if they aren't already connected
					author_obj[list_of_coauthors[i]].coauthors.push(author_obj[list_of_coauthors[j]]);
					author_obj[list_of_coauthors[j]].coauthors.push(author_obj[list_of_coauthors[i]]);
				}
			}
		}
	}
	
	function parse_user_input() {
		var inputText = document.getElementById("myText").value;
		inputText = inputText.replace(/[&\\#$~%'"*?{}]/g, ''); // remove illegal characters
		inputText = inputText.replaceAll("- ","-"); 
		
		var urlSuffix = inputText.split(/\r\n|\r|\n/g);
		var tempDOIArray = [];
		var tempDOItype = "";
        var tempDOI = '';
        var tempDOIsFoundSoFar = [];
        
		// get rid of rows with too few characters
		for (i = urlSuffix.length - 1; i >= 0; i--) { 
			urlSuffix[i] = urlSuffix[i].trim();
			if (urlSuffix[i].length < 5) {
				urlSuffix.splice(i, 1);
			}
		}
			
		for (i = 0; i < urlSuffix.length; i++) {
            tempDOIArray = [];
            tempDOIArray = urlSuffix[i].match(doi_pattern); // match returns an array, so this is just to get that array and help convert it to a string. 
            if (typeof tempDOIArray !== 'undefined' && tempDOIArray !== null && tempDOIArray.length > 0) { // if it found a doi
                var tempArraySplit = urlSuffix[i].split(tempDOIArray[0]);
                var a = tempArraySplit[0]+tempDOIArray[0];
                var b = tempArraySplit[1].trim();
                // if the string after the delimiter has something in it, split that stuff (everything after the 1st doi) into a different string
                if (b.length > 0) {
// 					console.log( 'Splitting:');
// 					console.log( a);
// 					console.log( b);
                    urlSuffix[i] = a; // change suffix to be equal to the first part
                    urlSuffix.splice(i+1, 0, b); // add an item to the suffix array that's got the second part in it. 
                }
                tempDOItype = "from_user";
                tempDOI = tempDOIArray[0];
            } else {
                tempDOItype = "not_found_yet";
                tempDOI = '';
            }
            
            if (tempDOIsFoundSoFar.includes(tempDOI)) { // if the doi has already been found in the user input
                console.log( 'duplicate doi found in user input. not added: ' + tempDOI);
            } else {
                // if there's no doi, or the doi is new, use it. 
                text_obj[urlSuffix[i]] = new Text_object(urlSuffix[i], tempDOI, tempDOItype, i);
                if (tempDOI.length > 0) {
                    tempDOIsFoundSoFar.push(tempDOI);
                }
            }
        }
		build_article_table();
	}
	
	function build_article_table() {
		// Build article table
		var s = '';
		
		articleTableText = "<table id='article_table'>";
		articleTableText += '<tr><th style="width:40%">Input text</th>';
    	articleTableText += '<th style="width:40%">Article found</th>';
    	articleTableText += '<th style="width:20%">Notes</th></tr>';
    	
		for (let key in text_obj) {
		// this loops through all of text_obj
            s = text_obj[key].user_input;
            articleTableText += "<tr id='"+s+"'>";
            articleTableText += "<td id='inputText_"+ s +"'>"+ s +"</td>";
            articleTableText += "<td id='reference_" + s + "'></td>";
            articleTableText += "<td id='notes_" + s + "'></td>";
            articleTableText += "</tr>";
		}

		articleTableText += "</table>";
		
		document.getElementById('articleTable').innerHTML = articleTableText;

	}

	function first_letters(input_string) {
		var foof = "";
		
		for (i = 0; i < input_string.length; i++) {
			foof += input_string[i].slice(0,1)+". "; 
		}
		return foof.trim();
	}

	function authorCheckBoxPress(whichOne) {
		// this is called when a checkbox is pressed
		var i = 0;
		const nameString = whichOne.id;
		author_obj[nameString].checked = whichOne.checked; // set this author's status (i.e., checked or not) to the status of the checkbox
		
		// for this author and their coauthors, compute their status 
		computeStatus(nameString);
		for (i = 0; i < author_obj[nameString].coauthors.length; i++) {
			computeStatus(author_obj[nameString].coauthors[i].name);
		}
	}
	
	function computeStatus(nameString) {
		// this figures out whether an author should be highlighted (i.e., whether they or their coauthors are checked)
		var i = 0;
				
		if (author_obj[nameString].checked == true) {
			// if this author is checked, turn them red
			document.getElementById('name_' + nameString).style.color = 'red';
		} else {
			// if this author has a co-author that is checked, turn them red and return
			for (i = 0; i < author_obj[nameString].coauthors.length; i++) {
				if (author_obj[nameString].coauthors[i].checked) {
					document.getElementById('name_' + nameString).style.color = 'red';
					return;
				}
			}
			// otherwise, turn them black		
			document.getElementById('name_' + nameString).style.color = 'black';
		}
	}

	
    function build_author_table() {
        var authorTableText = "";

        // create the html table 
        authorTableText = "<table><tr>";
        authorTableText += "<th onclick='sortTable(0, "+'"authorTable","checkboxes"'+")' title='Click to Sort'>Highlight</th>";
        authorTableText += "<th onclick='sortTable(1, "+'"authorTable","letters"'+")' title='Click to Sort'>Author</th>";
        authorTableText += "<th onclick='sortTable(2, "+'"authorTable","numbers"'+")' title='Click to Sort'>Citations</th>";
        authorTableText += "<th onclick='sortTable(3, "+'"authorTable","letters"'+")' title='Click to Sort'>Co-Authors</th>";
        authorTableText += "</tr>";

        for (var key in author_obj) {
            authorTableText += "<tr>";
            authorTableText += '<td><input type="checkbox" id="'+key+'" onclick="authorCheckBoxPress(this)"></td>';
            authorTableText += "<td><div id='name_" + author_obj[key].name + "'>" + author_obj[key].name + "</td>";
            authorTableText += "<td>" + author_obj[key].citation_count + "</td>";
            authorTableText +=  "<td>" + author_obj[key].all_coauthors_string();
            authorTableText += "</td></tr>";
        }

        authorTableText += "</table>"
        document.getElementById('authorTable').innerHTML = authorTableText;		
        sortTable(1, "authorTable", "letters");
    }
    
	function showBoxes() {
		var x = document.getElementById("refalyzerArticleListBox");
		x.style.display = "flex";
		x = document.getElementById("refalyzerAuthorsBox");
		x.style.display = "flex";
		x = document.getElementById("progressBox");
		x.style.display = "flex";
	}
	
	function start() {
		author_obj = [];
		reference_obj = [];
		to_do_list_input_string = [];
		text_obj = [];
		startTime = Date.now();
		duplicate_input_text = [];
		document.getElementById("outputText").innerHTML = "";
    
		showBoxes();
		parse_user_input();
		getAllUrls('from_user');
		updateProgress();
	}

	function updateProgress() {
	    var row_text = '';
	    var rows_done = 0;
	    var rows_with_user_dois_total = 0;
	    
        var rows_total = document.getElementById('article_table').rows.length - 1;
        try {
            for (i = 1; i <= rows_total; i++) { // start at 1 to skip header row
                row_text = document.getElementById("article_table").rows[i].cells[0].textContent;
                if (text_obj[row_text].search_status == "done") {
                    rows_done++;
                }
                if (text_obj[row_text].doi_type == "from_user") {
                    rows_with_user_dois_total++;
                }                
            }
        } catch (err) {
            console.log('*error in update progress: '+row_text);
            console.log( err);
        }

// 	    console.log( 'called update Progress: '+rows_done + ' of ' + rows_total + "(" + rows_with_user_dois_total + ")")

		document.getElementById('progressHeader').innerHTML = "Working... ";
		document.getElementById('progressText').innerHTML = '&nbsp;' + rows_done + ' of ' + rows_total + " (" +  Math.floor((Date.now() - startTime)/1000) + ' seconds)';

		if (rows_done >= rows_total) {
			document.getElementById('progressHeader').innerHTML = "Done ";
		} else if (rows_done == rows_with_user_dois_total && started_notFoundYet == false) {
		    started_notFoundYet = true;
			remove_duplicate_rows();
            getAllUrls('not_found_yet');
        }   
	}

</script>
</head>


<body>

	<!--  navigation menu -->
<!-- 
	<nav>
		<ul>
			<li><a href="index.html"><div class="navMenuItem"><img src="images/pm.png" > Masher Home</div></a></li>
			<li><a href="index_CombineAndClean.html"><div class="navMenuItem"><img src="images/cac.png"> Combine Datafiles</div></a></li>
			<li><a href="index_StatBuddy.html"><div class="navMenuItem"><img src="images/ptp.png"> StatBuddy</div></a></li>
			<li style="float:right"><a href="index_About.html"><div class="navMenuItem">About</div></a></li>
		</ul>
	</nav>
 -->

<textarea id="myText" name="inputTextArea" rows="20" cols="80">
Dougherty, M. R., Scheck, P., Nelson, T. O., & Narens, L. (2005). Using the past to predict the future. Memory & Cognition, 33, 1096–1115. https://doi.org/10.3758/BF03193216

Hechler, S., Neyer, F. J., & Kessler, T. (2016). The infamous among us: Enhanced reputational memory for uncooperative ingroup members. Cognition, 157, 1–13. https://doi.org/10.1016/j.cognition.2016.08.001
</textarea>

<!-- 
Heck, D. W., Gronau, F. Q., & Wagenmakers &, E.-J. (2019). metaBMA: Bayesian Model

Averaging for Random and Fixed Effects Meta-Analysis. https://CRAN.R-project.org/package=metaBMA.

Henkel, L. A., Johnson, M. K., & De Leonardis, D. M. (1998). Aging and source monitoring:

Cognitive processes and neuropsychological correlates. Journal of Experimental

Psychology: General, 127, 251–268. https://doi.org/10.1037/0096-3445.127.3.251 Hicks, J. L., & Cockman, D. W. (2003). The effect of general knowledge on source memory

and decision processes. Journal of Memory and Language, 48, 489–501.

https://doi.org/10.1016/S0749-596X(02)00537-5
 -->

<p id="outputText"></p>

<p><button onclick="start()">Run</button>

<div class='bigBox' id='progressBox' style="display: none;">
	<div class='boxAroundTable' style="min-width: 300px">
		<div class='heading' id='progressHeader'>Progress</div>
		<div id='progressText'></div>
	</div>
</div>


<!-- 	Article table 	-->
<div class='bigBox' id='refalyzerArticleListBox' style="display: none">
	<div class='bigBox' display="block"> 
		<div class='boxAroundTable'>
			<div class='heading'>Articles</div><br>
			<p>
			<div id='articleTable' class='dataTable'></div>
		</div>
	</div>
</div>

<!-- 	Author table 	-->
<div class='bigBox' id='refalyzerAuthorsBox' style="display: none">
	<div class='bigBox' display="block"> 
		<div class='boxAroundTable'>
			<div class='heading'>Authors (click headings to sort)</p></div><br>
			<p>
			<div id='authorTable' class='dataTable'></div>
		</div>
	</div>
</div>


</body>
</html>

<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~- -->


<!-- <script src="file_select.js"></script> -->
<!-- <script src="file_importExportContent.js"></script> -->
<!-- <script src="functions_fileOverlap.js"></script> -->
<script src="functions_stats.js"></script>
<script src="functions_indexpage.js"></script>


<p>Besken, M. (2016). Picture-perfect is not perfect for metamemory: Testing the perceptual fluency hypothesis with degraded images. Journal of Experimental Psychology: Learning, Memory, and Cognition, 42, 1417–1433. https://doi.org/10.1037/xlm0000246
<p>Besken, M., & Mulligan, N. W. (2013). Easily perceived, easily remembered? Perceptual interference produces a double dissociation between metamemory and memory performance. Memory & Cognition, 41, 897–903. https://doi.org/10.3758/s13421-013-0307-8
<p>Besken, M., & Mulligan, N. W. (2014). Perceptual fluency, auditory generation, and
metamemory: Analyzing the perceptual fluency hypothesis in the auditory modality. Journal of Experimental Psychology: Learning, Memory, and Cognition, 40, 429–440. https://doi.org/10.1037/a0034407

<p>Bröder, A., & Meiser, T. (2007). Measuring source memory. Zeitschrift für Psychologie/Journal of Psychology, 215, 52–60. https://doi.org/10.1027/0044- 3409.215.1.52
<p>Bui, Y., Pyc, M. A., & Bailey, H. (2018). When people’s judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: the “Displaced-JOL effect”. Memory, 26, 771–783. https://doi.org/10.1080/09658211.2017.1406523
<p>Carroll, M., Mazzoni, G., Andrews, S., & Pocock, P. (1999). Monitoring the future: Object and source memory for real and imagined events. Applied Cognitive Psychology, 13, 373–390. https://doi.org/10.1002/(SICI)1099-0720(199908)13:4<373::AID- ACP605>3.0.CO;2-F
<p>Dodson, C. S., Darragh, J., & Williams, A. (2008). Stereotypes and retrieval-provoked illusory source recollections. Journal of Experimental Psychology: Learning, Memory, and Cognition, 34, 460–477. https://doi.org/10.1037/0278-7393.34.3.460
<p>Dougherty, M. R., Scheck, P., Nelson, T. O., & Narens, L. (2005). Using the past to predict the future. Memory & Cognition, 33, 1096–1115. https://doi.org/10.3758/BF03193216
<p>Dunlosky, J., & Hertzog, C. (2000). Updating knowledge about encoding strategies: A componential analysis of learning about strategy effectiveness from task experience. Psychology and Aging, 15, 462–474. https://doi.org/10.1037//0882-7974.15.3.462
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 53
<p>Dunlosky, J., & Nelson, T. O. (1992). Importance of the kind of cue for judgments of learning (JOL) and the delayed-JOL effect. Memory & Cognition, 20, 374–380. https://doi.org/10.3758/BF03210921
<p>Dunlosky, J., & Nelson, T. O. (1994). Does the sensitivity of judgements of learning (JOLs) to the effects of various study activities depend on when the JOLs occur? Journal of Memory and Language, 33, 545–565. https://doi.org/10.1006/jmla.1994.1026
<p>Dunlosky, J., & Nelson, T. O. (1997). Similarity between the cue for judgments of learning (JOL) and the cue for test is not the primary determinant of JOL accuracy. Journal of Memory and Language, 36, 34–49. https://doi.org/10.1006/jmla.1996.2476
<p>Ehrenberg, K., & Klauer, K. C. (2005). Flexible use of source information: Processing components of the inconsistency effect in person memory. Journal of Experimental Social Psychology, 41, 369–387. https://doi.org/10.1016/j.jesp.2004.08.001
<p>England, B. D., & Serra, M. J. (2012). The contributions of anchoring and past-test performance to the underconfidence-with-practice effect. Psychonomic Bulletin & Review, 19, 715–722. https://doi.org/10.3758/s13423-012-0237-7
<p>Erdfelder, E., Auer, T.-S., Hilbig, B. E., Aßfalg, A., Moshagen, M., & Nadarevic, L. (2009). Multinomial processing tree models: A review of the literature. Zeitschrift für Psychologie/Journal of Psychology, 217, 108–124. https://doi.org/10.1027/0044- 3409.217.3.108
<p>Erdfelder, E., & Bredenkamp, J. (1998). Recognition of script-typical versus script-atypical information: Effects of cognitive elaboration. Memory & Cognition, 26, 922–938. https://doi.org/10.3758/BF03201173
<p>Finley, J. R., Tullis, J. G., & Benjamin, A. S. (2010). Metacognitive control of learning and remembering. In M. S. Knine & I. M. Saleh (Eds.), New Science of Learning (pp. 109– 131). New York, NY: Springer. https://doi.org/10.1007/978-1-4419-5716-0_6
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 54
<p>Finn, B., & Metcalfe, J. (2007). The role of memory for past test in the underconfidence with practice effect. Journal of Experimental Psychology: Learning, Memory, and Cognition, 33, 238–244. https://doi.org/10.1037/0278-7393.33.1.238
<p>Finn, B., & Metcalfe, J. (2008). Judgments of learning are influenced by memory for past test. Journal of Memory and Language, 58, 19–34. https://doi.org/10.1016/j.jml.2007.03.006
<p>Frank, D. J., & Kuhlmann, B. G. (2017). More than just beliefs: Experience and beliefs jointly contribute to volume effects on metacognitive judgments. Journal of Experimental Psychology: Learning, Memory, and Cognition, 43, 680–693. https://doi.org/10.1037/xlm0000332
<p>Friedman, A. (1979). Framing pictures: The role of knowledge in automatized encoding and memory for gist. Journal of Experimental Psychology: General, 108, 316–355. https://doi.org/10.1037/0096-3445.108.3.316
<p>Gelman, A., & Rubin, D. B. (1992). Inference from iterative simulation using multiple sequences. Statistical Science, 7, 457–472. http://dx.doi.org/10.1214/ss/1177011136
<p>Gronau, Q. F., Heck, D. W., Berkhout, S. W., Haaf, J. M., & Wagenmakers, E. (2020, April 24). A Primer on Bayesian Model-Averaged Meta-Analysis. https://doi.org/10.31234/osf.io/97qup
<p>Gronau, Q. F., Van Erp, S., Heck, D. W., Cesario, J., Jonas, K. J., & Wagenmakers, E. J. (2017). A Bayesian model-averaged meta-analysis of the power pose effect with informed and default priors: The case of felt power. Comprehensive Results in Social Psychology, 2, 123–138. https://doi.org/10.1080/23743603.2017.1326760
<p>Hechler, S., Neyer, F. J., & Kessler, T. (2016). The infamous among us: Enhanced reputational memory for uncooperative ingroup members. Cognition, 157, 1–13. https://doi.org/10.1016/j.cognition.2016.08.001
<p>Heck, D. W., Arnold, N. R., & Arnold, D. (2018). TreeBUGS: An R package for hierarchical multinomial-processing-tree modeling. Behavior Research Methods, 50, 264–284.
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 55
<p>https://doi.org/ 10.3758/s13428-017-0869-7
<p>Heck, D. W., Gronau, F. Q., & Wagenmakers &, E.-J. (2019). metaBMA: Bayesian Model
<p>Averaging for Random and Fixed Effects Meta-Analysis. https://CRAN.R-
<p>project.org/package=metaBMA.
<p>Henkel, L. A., Johnson, M. K., & De Leonardis, D. M. (1998). Aging and source monitoring:
<p>Cognitive processes and neuropsychological correlates. Journal of Experimental
<p>Psychology: General, 127, 251–268. https://doi.org/10.1037/0096-3445.127.3.251 Hicks, J. L., & Cockman, D. W. (2003). The effect of general knowledge on source memory
<p>and decision processes. Journal of Memory and Language, 48, 489–501.
<p>https://doi.org/10.1016/S0749-596X(02)00537-5
<p>Johnson, M. K., Hashtroudi, S., & Lindsay, D. S. (1993). Source monitoring. Psychological
<p>Bulletin, 114, 3–28. https://doi.org/10.1037/0033-2909.114.1.3
<p>Johnson, M. K., Kounios, J., & Reeder, J. A. (1994). Time-course studies of reality
<p>monitoring and recognition. Journal of Experimental Psychology: Learning, Memory,
<p>and Cognition, 20, 1409–1419. https://doi.org/10.1037/0278-7393.20.6.1409
<p>Kelemen, W. L. (2000). Metamemory cues and monitoring accuracy: Judging what you know
<p>and what you will know. Journal of Educational Psychology, 92, 800–810.
<p>https://doi.org/10.1037/0022-0663.92.4.800
<p>Kelemen, W. L., & Weaver, C. A. III (1997). Enhanced memory at delays: Why do judgments
<p>of learning improve over time? Journal of Experimental Psychology: Learning, Memory,
<p>and Cognition, 23(6), 1394–1409. https://doi.org/10.1037/0278-7393.23.6.1394 Kelley, C. M., & Jacoby, L. L. (1996). Adult egocentrism: Subjective experience versus
<p>analytic bases for judgment. Journal of Memory and Language, 35, 157–175.
<p>https://doi.org/10.1006/jmla.1996.0009
<p>Kenny, D. A., Korchmaros, J. D., & Bolger, N. (2003). Lower level mediation in multilevel
<p>models. Psychological Methods, 8, 115–128. https://doi.org/10.1037/1082-989X.8.2.115
<!-- 
<p>
DELAYED JUDGMENTS IN SOURCE MONITORING 56
<p>Kimball, D. R., & Metcalfe, J. (2003). Delaying judgments of learning affects memory, not metamemory. Memory & Cognition, 31, 918–929. https://doi.org/10.3758/BF03196445
<p>Kimball, D. R., Smith, T. A., & Muntean, W. J. (2012). Does delaying judgments of learning really improve the efficacy of study decisions? Not so much. Journal of Experimental Psychology: Learning, Memory, and Cognition, 38, 923–954. https://doi.org/10.1037/a0026936
<p>King, J. F., Zechmeister, E. B., & Shaughnessy, J. J. (1980). Judgments of knowing: The influence of retrieval practice. The American Journal of Psychology, 329–343. https://doi.org/10.2307/1422236
<p>Klauer, K. C. (2010). Hierarchical multinomial processing tree models: A latent-trait approach. Psychometrika, 75, 70–98. doi: 10.1007/S11336-009-9141-0
<p>Konopka, A. E., & Benjamin, A. S. (2009). Schematic knowledge changes what judgments of learning predict in a source memory task. Memory & Cognition, 37, 42–51. https://doi.org/10.3758/MC.37.1.42
<p>Koriat, A. (1997). Monitoring one’s own knowledge during study: A cue-utilization approach to judgments of learning. Journal of Experimental Psychology: General, 126, 349–370. https://doi.org/10.1037/0096-3445.126.4.349
<p>Koriat, A., & Bjork, R. A. (2006a). Illusions of competence during study can be remedied by manipulations that enhance learners’ sensitivity to retrieval conditions at test. Memory & Cognition, 34, 959–972. https://doi.org/10.3758/BF03193244
<p>Koriat, A., & Bjork, R. A. (2006b). Mending metacognitive illusions: A comparison of mnemonic-based and theory-based procedures. Journal of Experimental Psychology: Learning, Memory, and Cognition, 32, 1133–1145. https://doi.org/10.1037/0278- 7393.32.5.1133
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 57
<p>Koriat, A., & Ma’ayan, H. (2005). The effects of encoding fluency and retrieval fluency on judgments of learning. Journal of memory and Language, 52, 478–492. https://doi.org/10.1016/j.jml.2005.01.001
<p>Kornell, N., & Bjork, R. A. (2008). Optimising self-regulated study: The benefits—and costs—of dropping flashcards. Memory, 16, 125–136. https://doi.org/10.1080/09658210701763899
<p>Kranz, D., Nadarevic, L., & Erdfelder, E. (2019). Bald and bad? Experimental evidence for a dual-process account of baldness stereotyping. Experimental Psychology, 66, 331– 345. https://doi.org/10.1027/1618-3169/a000457
<p>Kroneisen, M., & Bell, R. (2013). Sex, cheating, and disgust: Enhanced source memory for trait information that violates gender stereotypes. Memory, 21, 167–181. https://doi.org/10.1080/09658211.2012.713971
<p>Kroneisen, M., Woehe, L., & Rausch, L. S. (2015). Expectancy effects in source memory: How moving to a bad neighborhood can change your memory. Psychonomic Bulletin & Review, 22, 179–189. https://doi.org/10.3758/s13423-014-0655-9
<p>Krull, J. L., & Mackinnon, D. P. (2001). Multilevel modeling of individual and group level mediated effects. Multivariate Behavioral Research, 36, 249–277. https://doi.org/10.1207/S15327906MBR3602
<p>Kuhlmann, B. G., & Bayen, U. J. (2016). Metacognitive aspects of source monitoring. In J. Dunlosky & S. U. Tauber (Eds.), The Oxford Handbook of Metamemory (pp. 149–168). New York, NY: Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199336746.013.8
<p>Kuhlmann, B. G., & Touron, D. R. (2011). Older adults’ use of metacognitive knowledge in source monitoring: Spared monitoring but impaired control. Psychology and Aging, 26, 143–149. https://doi.org/ 10.1037/a0021055
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 58
<p>Kuhlmann, B. G., Vaterrodt, B., & Bayen, U. J. (2012). Schema bias in source monitoring varies with encoding conditions: Support for a probability-matching account. Journal of Experimental Psychology: Learning, Memory, and Cognition, 38, 1365–1376. https://doi.org/10.1037/a0028147
<p>Küppers, V., & Bayen, U. J. (2014). Inconsistency effects in source memory and compensatory schema-consistent guessing. The Quarterly Journal of Experimental Psychology, 67, 2042–2059. https://doi.org/10.1080/17470218.2014.904914
<p>Kuznetsova, A., Brockhoff, P. B., & Christensen, R. H. B. (2014). lmerTest: Tests for random and fixed effects for linear mixed effect models (lmer objects of lme4 package) (R package version 2.0-6) [Software]. Retrieved from http://cran.r- project.org/package=lmerTest
<p>Loftus, G. R., & Mackworth, N. H. (1978). Cognitive determinants of fixation location during picture viewing. Journal of Experimental Psychology: Human Perception and Performance, 4, 565–572. https://doi.org/10.1037/0096-1523.4.4.565
<p>Loftus, G. R., & Masson, M. E. J. (1994). Using confidence intervals in within-subject designs. Psychonomic Bulletin & Review, 1, 476–490. https://doi.org/10.3758/BF03210951
<p>Luna, K., Martín-Luengo, B., & Albuquerque, P. B. (2018). Do delayed judgements of learning reduce metamemory illusions? A meta-analysis. Quarterly Journal of Experimental Psychology, 71(7), 1626-1636. https://doi.org/10.1080/17470218.2017.1343362
<p>Marsh, R., Cook, G., & Hicks, J. L. (2006). Gender and orientation stereotypes bias source- monitoring attributions. Memory, 14, 148–160. https://doi.org/10.1080/09658210544000015
<p>Mather, M., Johnson, M. K., & De Leonardis, D. M. (1999). Stereotype reliance in source monitoring: Age differences and neuropsychological test correlates. Cognitive
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 59
<p>Neuropsychology, 16, 437–458. https://doi.org/10.1080/026432999380870
<p>Meeter, M., & Nelson, T. O. (2003). Multiple study trials and judgments of learning. Acta
<p>Psychologica, 113, 123–132. https://doi.org/10.1016/S0001-6918(03)00023-4 Meiser, T., & Hewstone, M. (2001). Crossed categorization effects on the formation of
<p>illusory correlations. European Journal of Social Psychology, 31, 443–466.
<p>https://doi.org/10.1002/ejsp.55
<p>Meiser, T., Sattler, C., & Von Hecker, U. (2007). Metacognitive inferences in source memory
<p>judgements: The role of perceived differences in item recognition. Quarterly Journal of
<p>Experimental Psychology, 60, 1015–1040. https://doi.org/10.1080/17470210600875215 Metcalfe, J. (2009). Metacognitive judgments and control of study. Current Directions in
<p>Psychological Science, 18, 159-163. https://doi.org/10.1111/j.1467-8721.2009.01628.x Metcalfe, J., & Finn, B. (2008). Evidence that judgments of learning are causally related to
<p>study choice. Psychonomic Bulletin & Review, 15, 174–179.
<p>https://doi.org/10.3758/PBR.15.1.174
<p>Mieth, L., Bell, R., & Buchner, A. (2016). Facial likability and smiling enhance cooperation,
<p>but have no direct effect on moralistic punishment. Experimental Psychology, 63, 263–
<p>277. http://dx.doi.org/10.1027/1618-3169/a000338
<p>Mieth, L., Schaper, M. L., Kuhlmann, B. G., & Bell, R. (2020). Memory and metamemory for
<p>social interactions: Evidence for a metamemory expectancy illusion. Memory &
<p>Cognition, 49, 14–31. https://doi.org/10.3758/s13421-020-01071-z
<p>Misirlisoy, M., Tanyas, H., & Atalay, N. B. (2019). Does survival context enhance memory
<p>for source? A within-subjects comparison. Memory, 27, 780–791.
<p>https://doi.org/10.1080/09658211.2019.1566928
<p>Mitchum, A. L., Kelley, C. M., & Fox, M. C. (2016). When asking the question changes the
<p>ultimate answer: Metamemory judgments change memory. Journal of Experimental Psychology: General, 145, 200–219. http://doi.org/10.1037/a0039923
<p>
<p>Mueller, M. L., & Dunlosky, J. (2017). How beliefs can impact judgments of learning: Evaluating analytic processing theory with beliefs about fluency. Journal of Memory and Language, 93, 245–258. https://doi.org/10.1016/j.jml.2016.10.008
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 60
<p>Mueller, M. L., Dunlosky, J., & Tauber, S. K. (2016). The effect of identical word pairs on people’s metamemory judgments: What are the contributions of processing fluency and beliefs about memory? The Quarterly Journal of Experimental Psychology, 69, 781–799. https://doi.org/10.1080/17470218.2015.1058404
<p>Mueller, M. L., Dunlosky, J., Tauber, S. K., & Rhodes, M. G. (2014). The font-size effect on judgments of learning: Does it exemplify fluency effects or reflect people’s beliefs about memory? Journal of Memory and Language, 70, 1–12. https://doi.org/10.1016/j.jml.2013.09.007
<p>Mueller, M. L., Tauber, S. K., & Dunlosky, J. (2013). Contributions of beliefs and processing fluency to the effect of relatedness on judgments of learning. Psychonomic Bulletin & Review, 20, 378–384. https://doi.org/10.3758/s13423-012-0343-6
<p>Murnane, K., & Bayen, U. J. (1996). An evaluation of empirical measures of source identification. Memory and Cognition, 24, 417–428. https://doi.org/10.3758/BF03200931
<p>Murnane, K., & Bayen, U. J. (1998). Measuring memory for source: Some theoretical assumptions and technical limitations. Memory & Cognition, 26, 674–677. https://doi.org/10.3758/BF03211387
<p>Nelson, T. O., & Dunlosky, J. (1991). When people's judgments of learning (JOLs) are extremely accurate at predicting subsequent recall: The “delayed-JOL effect”. Psychological Science, 2, 267–271. https://doi.org/10.1111/j.1467-9280.1991.tb00147.x
<p>Nelson, T. O., Dunlosky, J., Graf, A., & Narens, L. (1994). Utilization of metacognitive judgments in the allocation of study during multitrial learning. Psychological Science, 5, 207–213. https://doi.org/10.1111/j.1467-9280.1994.tb00502.x
<p>Nelson, T. O., & Narens, L. (1990). Metamemory: A theoretical framework and new findings.
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 61
<p>In G. H. Bower (Ed.), The Psychology of Learning and Motivation (Vol. 26, pp. 125–
<p>141). San Diego, CA: Academic Press. https://doi.org/10.1016/S0079-7421(08)60053-5 Nelson, T. O., & Narens, L. (1994). Why investigate metacognition. In J. Metcalfe & A. P.
<p>Shimamura (Eds.), Metacognition: Knowing about Knowing (pp. 1-25). Cambridge, MA:
<p>MIT Press.
<p>Nelson, T. O., Narens, L., & Dunlosky, J. (2004). A revised methodology for research on
<p>metamemory: Pre-judgment recall and monitoring (PRAM). Psychological methods, 9,
<p>53–69. https://doi.org/10.1037/1082-989X.9.1.53
<p>Nieznański, M. (2014a). Context reinstatement and memory for intrinsic versus extrinsic
<p>context: The role of item generation at encoding or retrieval. Scandinavian Journal of
<p>Psychology, 55, 409–419. https://doi.org/10.1111/sjop.12153
<p>Nieznański, M. (2014b). The role of reinstating generation operations in recognition memory
<p>and reality monitoring. Polish Psychological Bulletin, 45, 363–371. https://doi.org/10.2478/ppb-2014-0044
<p> Pyc, M. A., Rawson, K. A., & Aschenbrenner, A. J. (2014). Metacognitive monitoring during criterion learning: When and why are judgments accurate? Memory & Cognition, 42(6), 886–897. https://doi.org/10.3758/s13421-014-0403-4
<p>Raftery, A. E. (1995). Bayesian model selection in social research. Sociological Methodology, 25, 111–163. https://doi.org/10.2307/271063
<p>R Core Team (2020). R: A language and environment for statistical computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.
<p>Rhodes, M. G. (2016). Judgments of learning: Methods, data, and theory. In J. Dunlosky & S. U. Tauber (Eds.), The Oxford Handbook of Metamemory (pp. 65–80). New York, NY: Oxford University Press. https://doi.org/10.1093/oxfordhb/9780199336746.013.4
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 62
<p>Rhodes, M. G., & Tauber, S. K. (2011). The influence of delaying judgments of learning on metacognitive accuracy: A meta-analytic review. Psychological Bulletin, 137(1), 131– 148. https://doi.org/10.1037/a0021705
<p>Robey, A. M., Dougherty, M. R., & Buttaccio, D. R. (2017). Making retrospective confidence judgments improves learners’ ability to decide what not to study. Psychological Science, 28, 1683–1893. https://doi.org/10.1177/0956797617718800
<p>Schaper, M. L., & Bayen, U. J. (2021). The metamemory expectancy illusion in source monitoring affects metamemory control and memory. Cognition, 206, 104468. https://doi.org/10.1016/j.cognition.2020.104468
<p>Schaper, M. L., Kuhlmann, B. G., & Bayen, U. J. (2019a). Metamemory expectancy illusion and schema-consistent guessing in source monitoring. Journal of Experimental Psychology: Learning, Memory, and Cognition. 45, 470-496. https://doi.org/10.1037/xlm0000602
<p>Schaper, M. L., Kuhlmann, B. G., & Bayen, U. J. (2019b). Metacognitive expectancy effects in source monitoring: Beliefs, in-the-moment experiences, or both? Journal of Memory and Language, 107, 95-110. https://doi.org/10.1016/j.jml.2019.03.009
<p>Serra, M. J., & Ariel, R. (2014). People use the memory for past-test heuristic as an explicit cue for judgments of learning. Memory & Cognition, 42, 1260–1272. https://doi.org/10.3758/s13421-014-0431-0
<p>Sherman, J. W., & Bessenoff, G. R. (1999). Stereotypes as source-monitoring cues: On the interaction between episodic and semantic memory. Psychological Science, 10, 106–110. https://doi.org/10.1111/1467-9280.00116
<p>Sherman, J. W., Lee, A. Y., Bessenoff, G. R., & Frost, L. A. (1998). Stereotype efficiency reconsidered: Encoding flexibility under cognitive load. Journal of Personality and Social Psychology, 75, 589–606. https://doi.org/0.1037/0022-3514.75.3.589
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 63
<p>Shi, L.-Z., Tang, W.-H., & Liu, X.-P. (2012). Age-related schema reliance of judgments of learning in predicting source memory. Aging, Neuropsychology, and Cognition, 19, 301– 318. https://doi.org/10.1080/13825585.2011.632616
<p>Smith, J. B., & Batchelder, W. H. (2010). Beta-MPT: Multinomial processing tree models for addressing individual differences. Journal of Mathematical Psychology, 54, 167–183. https://doi.org/10.1016/j.jmp.2009.06.007
<p>Soderstrom, N. C., Clark, C. T., Halamish, V., & Bjork, E. L. (2015). Judgments of learning as memory modifiers. Journal of Experimental Psychology: Learning, Memory, and Cognition, 41, 553–558. https://doi.org/10.1037/a0038388
<p>Spaniol, J., & Bayen, U. J. (2002). When is schematic knowledge used in source monitoring? Journal of Experimental Psychology: Learning, Memory, and Cognition, 28, 631–651. https://doi.org/10.1037/0278-7393.28.4.631
<p>Starns, J. J., & Hicks, J. L. (2013). Internal reinstatement hides cuing effects in source memory tasks. Memory & Cognition, 41, 953–966. https://doi.org/10.3758/s13421-013- 0325-6
<p>Susser, J. A., Mulligan, N. W., & Besken, M. (2013). The effects of list composition and perceptual fluency on judgments of learning (JOLs). Memory & Cognition, 41, 1000– 1011. https://doi.org/10.3758/s13421-013-0323-8
<p>Tauber, S. K., & Rhodes, M. G. (2012). Multiple bases for young and older adults' judgments of learning in multitrial learning. Psychology and Aging, 27, 474–-483. https://doi.org/10.1037/a0025246
<p>Thiede, K. W., Anderson, M., & Therriault, D. (2003). Accuracy of metacognitive monitoring affects learning of texts. Journal of Educational Psychology, 95, 66–73. https://doi.org/10.1037/0022-0663.95.1.66
<p>Tullis, J. G., & Benjamin, A. S. (2011). On the effectiveness of self-paced learning. Journal of Memory and Language, 64, 109–118. https://doi.org/10.1016/j.jml.2010.11.002
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 64
<p>Tullis, J. G., Finley, J. R., & Benjamin, A. S. (2013). Metacognition of the testing effect: Guiding learners to predict the benefits of retrieval. Memory & Cognition, 41, 429–442. https://doi.org/10.3758/s13421-012-0274-5
<p>Undorf, M., & Erdfelder, E. (2011). Judgments of learning reflect encoding fluency: Conclusive evidence for the ease-of-processing hypothesis. Journal of Experimental Psychology: Learning, Memory, and Cognition, 37, 1264–1269. https://doi.org/10.1037/a0023719
<p>Undorf, M., & Erdfelder, E. (2013). Separation of encoding fluency and item difficulty effects on judgements of learning. Quarterly Journal of Experimental Psychology, 66, 2060– 2072. https://doi.org/10.1080/17470218.2013.777751
<p>Undorf, M., & Erdfelder, E. (2015). The relatedness effect on judgments of learning: A closer look at the contribution of processing fluency. Memory & Cognition, 43, 647–658. https://doi.org/10.3758/s13421-014-0479-x
<p>Van Overschelde, J. P., & Nelson, T. O. (2006). Delayed judgments of learning cause both a decrease in absolute accuracy (calibration) and an increase in relative accuracy (resolution). Memory & cognition, 34, 1527–1538. https://doi.org/10.3758/BF03195916
<p>Vesonder, G. T., & Voss, J. F. (1985). On the ability to predict one's own responses while learning. Journal of Memory and Language, 24, 363–376. https://doi.org/10.1016/0749- 596X(85)90034-8
<p>Weaver, C. A. III, & Kelemen, W. L. (1997). Judgments of learning at delays: Shifts in response patterns or increased metamemory accuracy? Psychological Science, 8, 318– 321. https://doi.org/10.1111/j.1467-9280.1997.tb00445.x
<p>Wulff, L., & Kuhlmann, B. G. (2020). Is knowledge reliance in source guessing a cognitive trait? Examining stability across time and domain. Memory & Cognition, 48, 256–276. https://doi.org/10.3758/s13421-019-01008-1
<p>
<p>DELAYED JUDGMENTS IN SOURCE MONITORING 65
<p>Yan, V. X., Bjork, E. L., & Bjork, R. A. (2016). On the difficulty of mending metacognitive illusions: A priori theories, fluency effects, and misattributions of the interleaving benefit. Journal of Experimental Psychology: General, 145, 918–933. https://doi.org/10.1037/xge0000177
<p>Yang, C., Potts, R., & Shanks, D. R. (2017). Metacognitive unawareness of the errorful generation benefit and its effects on self-regulated learning. Journal of Experimental Psychology: Learning, Memory, and Cognition, 43, 1073–1092. https://doi.org/10.1037/xlm0000363
<p>Zechmeister, E. B., & Shaughnessy, J. J. (1980). When you know that you know and when you think that you know but you don’t. Bulletin of the Psychonomic Society, 15, 41–44. https://doi.org/10.3758/BF03329756
<p>Zhang, Y., Pan, Z., Li, K., & Guo, Y. (2018). Self-serving bias in memories: Selectively forgetting the connection between negative information and the self. Experimental Psychology, 65, 236–244. http://dx.doi.org/10.1027/1618-3169/a000409
 -->
